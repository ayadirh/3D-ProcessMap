// Version 1.69.2 3d-force-graph - https://github.com/vasturiano/3d-force-graph
!function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).ForceGraph3D = t()
}(this, (function() {
    "use strict";
    function e(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n,
        e
    }
    function t(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            }
            ))),
            n.push.apply(n, r)
        }
        return n
    }
    function n(n) {
        for (var r = 1; r < arguments.length; r++) {
            var i = null != arguments[r] ? arguments[r] : {};
            r % 2 ? t(Object(i), !0).forEach((function(t) {
                e(n, t, i[t])
            }
            )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(i)) : t(Object(i)).forEach((function(e) {
                Object.defineProperty(n, e, Object.getOwnPropertyDescriptor(i, e))
            }
            ))
        }
        return n
    }
    function r(e) {
        return function(e) {
            if (Array.isArray(e))
                return i(e)
        }(e) || function(e) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e))
                return Array.from(e)
        }(e) || function(e, t) {
            if (!e)
                return;
            if ("string" == typeof e)
                return i(e, t);
            var n = Object.prototype.toString.call(e).slice(8, -1);
            "Object" === n && e.constructor && (n = e.constructor.name);
            if ("Map" === n || "Set" === n)
                return Array.from(e);
            if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
                return i(e, t)
        }(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function i(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, r = new Array(t); n < t; n++)
            r[n] = e[n];
        return r
    }
    !function(e, t) {
        void 0 === t && (t = {});
        var n = t.insertAt;
        if (e && "undefined" != typeof document) {
            var r = document.head || document.getElementsByTagName("head")[0]
              , i = document.createElement("style");
            i.type = "text/css",
            "top" === n && r.firstChild ? r.insertBefore(i, r.firstChild) : r.appendChild(i),
            i.styleSheet ? i.styleSheet.cssText = e : i.appendChild(document.createTextNode(e))
        }
    }(".graph-info-msg {\n  top: 50%;\n  width: 100%;\n  text-align: center;\n  color: lavender;\n  opacity: 0.7;\n  font-size: 22px;\n  position: absolute;\n  font-family: Sans-serif;\n}\n\n.grabbable {\n  cursor: move;\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n\n.grabbable:active {\n  cursor: grabbing;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n}");
    const o = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
    }
      , a = 0
      , s = 1
      , c = 2
      , l = 3
      , u = 100
      , h = 1e3
      , d = 1001
      , p = 1002
      , f = 1003
      , m = 1006
      , g = 1008
      , v = 1009
      , y = 1012
      , b = 1014
      , x = 1015
      , _ = 1016
      , w = 1020
      , M = 1022
      , E = 1023
      , S = 1026
      , T = 1027
      , L = 3e3
      , A = 7680
      , P = 35044
      , C = 35048
      , R = "300 es";
    function D() {}
    Object.assign(D.prototype, {
        addEventListener: function(e, t) {
            void 0 === this._listeners && (this._listeners = {});
            const n = this._listeners;
            void 0 === n[e] && (n[e] = []),
            -1 === n[e].indexOf(t) && n[e].push(t)
        },
        hasEventListener: function(e, t) {
            if (void 0 === this._listeners)
                return !1;
            const n = this._listeners;
            return void 0 !== n[e] && -1 !== n[e].indexOf(t)
        },
        removeEventListener: function(e, t) {
            if (void 0 === this._listeners)
                return;
            const n = this._listeners[e];
            if (void 0 !== n) {
                const e = n.indexOf(t);
                -1 !== e && n.splice(e, 1)
            }
        },
        dispatchEvent: function(e) {
            if (void 0 === this._listeners)
                return;
            const t = this._listeners[e.type];
            if (void 0 !== t) {
                e.target = this;
                const n = t.slice(0);
                for (let t = 0, r = n.length; t < r; t++)
                    n[t].call(this, e);
                e.target = null
            }
        }
    });
    const O = [];
    for (let e = 0; e < 256; e++)
        O[e] = (e < 16 ? "0" : "") + e.toString(16);
    let N = 1234567;
    const I = {
        DEG2RAD: Math.PI / 180,
        RAD2DEG: 180 / Math.PI,
        generateUUID: function() {
            const e = 4294967295 * Math.random() | 0
              , t = 4294967295 * Math.random() | 0
              , n = 4294967295 * Math.random() | 0
              , r = 4294967295 * Math.random() | 0;
            return (O[255 & e] + O[e >> 8 & 255] + O[e >> 16 & 255] + O[e >> 24 & 255] + "-" + O[255 & t] + O[t >> 8 & 255] + "-" + O[t >> 16 & 15 | 64] + O[t >> 24 & 255] + "-" + O[63 & n | 128] + O[n >> 8 & 255] + "-" + O[n >> 16 & 255] + O[n >> 24 & 255] + O[255 & r] + O[r >> 8 & 255] + O[r >> 16 & 255] + O[r >> 24 & 255]).toUpperCase()
        },
        clamp: function(e, t, n) {
            return Math.max(t, Math.min(n, e))
        },
        euclideanModulo: function(e, t) {
            return (e % t + t) % t
        },
        mapLinear: function(e, t, n, r, i) {
            return r + (e - t) * (i - r) / (n - t)
        },
        inverseLerp: function(e, t, n) {
            return e !== t ? (n - e) / (t - e) : 0
        },
        lerp: function(e, t, n) {
            return (1 - n) * e + n * t
        },
        damp: function(e, t, n, r) {
            return I.lerp(e, t, 1 - Math.exp(-n * r))
        },
        pingpong: function(e, t=1) {
            return t - Math.abs(I.euclideanModulo(e, 2 * t) - t)
        },
        smoothstep: function(e, t, n) {
            return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * (3 - 2 * e)
        },
        smootherstep: function(e, t, n) {
            return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10)
        },
        randInt: function(e, t) {
            return e + Math.floor(Math.random() * (t - e + 1))
        },
        randFloat: function(e, t) {
            return e + Math.random() * (t - e)
        },
        randFloatSpread: function(e) {
            return e * (.5 - Math.random())
        },
        seededRandom: function(e) {
            return void 0 !== e && (N = e % 2147483647),
            N = 16807 * N % 2147483647,
            (N - 1) / 2147483646
        },
        degToRad: function(e) {
            return e * I.DEG2RAD
        },
        radToDeg: function(e) {
            return e * I.RAD2DEG
        },
        isPowerOfTwo: function(e) {
            return 0 == (e & e - 1) && 0 !== e
        },
        ceilPowerOfTwo: function(e) {
            return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2))
        },
        floorPowerOfTwo: function(e) {
            return Math.pow(2, Math.floor(Math.log(e) / Math.LN2))
        },
        setQuaternionFromProperEuler: function(e, t, n, r, i) {
            const o = Math.cos
              , a = Math.sin
              , s = o(n / 2)
              , c = a(n / 2)
              , l = o((t + r) / 2)
              , u = a((t + r) / 2)
              , h = o((t - r) / 2)
              , d = a((t - r) / 2)
              , p = o((r - t) / 2)
              , f = a((r - t) / 2);
            switch (i) {
            case "XYX":
                e.set(s * u, c * h, c * d, s * l);
                break;
            case "YZY":
                e.set(c * d, s * u, c * h, s * l);
                break;
            case "ZXZ":
                e.set(c * h, c * d, s * u, s * l);
                break;
            case "XZX":
                e.set(s * u, c * f, c * p, s * l);
                break;
            case "YXY":
                e.set(c * p, s * u, c * f, s * l);
                break;
            case "ZYZ":
                e.set(c * f, c * p, s * u, s * l);
                break;
            default:
                console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
            }
        }
    };
    class k {
        constructor(e=0, t=0) {
            this.x = e,
            this.y = t
        }
        get width() {
            return this.x
        }
        set width(e) {
            this.x = e
        }
        get height() {
            return this.y
        }
        set height(e) {
            this.y = e
        }
        set(e, t) {
            return this.x = e,
            this.y = t,
            this
        }
        setScalar(e) {
            return this.x = e,
            this.y = e,
            this
        }
        setX(e) {
            return this.x = e,
            this
        }
        setY(e) {
            return this.y = e,
            this
        }
        setComponent(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y)
        }
        copy(e) {
            return this.x = e.x,
            this.y = e.y,
            this
        }
        add(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this)
        }
        addScalar(e) {
            return this.x += e,
            this.y += e,
            this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this
        }
        sub(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this)
        }
        subScalar(e) {
            return this.x -= e,
            this.y -= e,
            this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this
        }
        multiply(e) {
            return this.x *= e.x,
            this.y *= e.y,
            this
        }
        multiplyScalar(e) {
            return this.x *= e,
            this.y *= e,
            this
        }
        divide(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        applyMatrix3(e) {
            const t = this.x
              , n = this.y
              , r = e.elements;
            return this.x = r[0] * t + r[3] * n + r[6],
            this.y = r[1] * t + r[4] * n + r[7],
            this
        }
        min(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this
        }
        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this
        }
        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y
        }
        cross(e) {
            return this.x * e.y - this.y * e.x
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        angle() {
            return Math.atan2(-this.y, -this.x) + Math.PI
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
        distanceToSquared(e) {
            const t = this.x - e.x
              , n = this.y - e.y;
            return t * t + n * n
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n,
            this.y = e.y + (t.y - e.y) * n,
            this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y
        }
        fromArray(e, t=0) {
            return this.x = e[t],
            this.y = e[t + 1],
            this
        }
        toArray(e=[], t=0) {
            return e[t] = this.x,
            e[t + 1] = this.y,
            e
        }
        fromBufferAttribute(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this
        }
        rotateAround(e, t) {
            const n = Math.cos(t)
              , r = Math.sin(t)
              , i = this.x - e.x
              , o = this.y - e.y;
            return this.x = i * n - o * r + e.x,
            this.y = i * r + o * n + e.y,
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this
        }
    }
    k.prototype.isVector2 = !0;
    class z {
        constructor() {
            this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
        }
        set(e, t, n, r, i, o, a, s, c) {
            const l = this.elements;
            return l[0] = e,
            l[1] = r,
            l[2] = a,
            l[3] = t,
            l[4] = i,
            l[5] = s,
            l[6] = n,
            l[7] = o,
            l[8] = c,
            this
        }
        identity() {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
            this
        }
        copy(e) {
            const t = this.elements
              , n = e.elements;
            return t[0] = n[0],
            t[1] = n[1],
            t[2] = n[2],
            t[3] = n[3],
            t[4] = n[4],
            t[5] = n[5],
            t[6] = n[6],
            t[7] = n[7],
            t[8] = n[8],
            this
        }
        extractBasis(e, t, n) {
            return e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
        }
        setFromMatrix4(e) {
            const t = e.elements;
            return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
        }
        multiply(e) {
            return this.multiplyMatrices(this, e)
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }
        multiplyMatrices(e, t) {
            const n = e.elements
              , r = t.elements
              , i = this.elements
              , o = n[0]
              , a = n[3]
              , s = n[6]
              , c = n[1]
              , l = n[4]
              , u = n[7]
              , h = n[2]
              , d = n[5]
              , p = n[8]
              , f = r[0]
              , m = r[3]
              , g = r[6]
              , v = r[1]
              , y = r[4]
              , b = r[7]
              , x = r[2]
              , _ = r[5]
              , w = r[8];
            return i[0] = o * f + a * v + s * x,
            i[3] = o * m + a * y + s * _,
            i[6] = o * g + a * b + s * w,
            i[1] = c * f + l * v + u * x,
            i[4] = c * m + l * y + u * _,
            i[7] = c * g + l * b + u * w,
            i[2] = h * f + d * v + p * x,
            i[5] = h * m + d * y + p * _,
            i[8] = h * g + d * b + p * w,
            this
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e,
            t[3] *= e,
            t[6] *= e,
            t[1] *= e,
            t[4] *= e,
            t[7] *= e,
            t[2] *= e,
            t[5] *= e,
            t[8] *= e,
            this
        }
        determinant() {
            const e = this.elements
              , t = e[0]
              , n = e[1]
              , r = e[2]
              , i = e[3]
              , o = e[4]
              , a = e[5]
              , s = e[6]
              , c = e[7]
              , l = e[8];
            return t * o * l - t * a * c - n * i * l + n * a * s + r * i * c - r * o * s
        }
        invert() {
            const e = this.elements
              , t = e[0]
              , n = e[1]
              , r = e[2]
              , i = e[3]
              , o = e[4]
              , a = e[5]
              , s = e[6]
              , c = e[7]
              , l = e[8]
              , u = l * o - a * c
              , h = a * s - l * i
              , d = c * i - o * s
              , p = t * u + n * h + r * d;
            if (0 === p)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
            const f = 1 / p;
            return e[0] = u * f,
            e[1] = (r * c - l * n) * f,
            e[2] = (a * n - r * o) * f,
            e[3] = h * f,
            e[4] = (l * t - r * s) * f,
            e[5] = (r * i - a * t) * f,
            e[6] = d * f,
            e[7] = (n * s - c * t) * f,
            e[8] = (o * t - n * i) * f,
            this
        }
        transpose() {
            let e;
            const t = this.elements;
            return e = t[1],
            t[1] = t[3],
            t[3] = e,
            e = t[2],
            t[2] = t[6],
            t[6] = e,
            e = t[5],
            t[5] = t[7],
            t[7] = e,
            this
        }
        getNormalMatrix(e) {
            return this.setFromMatrix4(e).invert().transpose()
        }
        transposeIntoArray(e) {
            const t = this.elements;
            return e[0] = t[0],
            e[1] = t[3],
            e[2] = t[6],
            e[3] = t[1],
            e[4] = t[4],
            e[5] = t[7],
            e[6] = t[2],
            e[7] = t[5],
            e[8] = t[8],
            this
        }
        setUvTransform(e, t, n, r, i, o, a) {
            const s = Math.cos(i)
              , c = Math.sin(i);
            return this.set(n * s, n * c, -n * (s * o + c * a) + o + e, -r * c, r * s, -r * (-c * o + s * a) + a + t, 0, 0, 1),
            this
        }
        scale(e, t) {
            const n = this.elements;
            return n[0] *= e,
            n[3] *= e,
            n[6] *= e,
            n[1] *= t,
            n[4] *= t,
            n[7] *= t,
            this
        }
        rotate(e) {
            const t = Math.cos(e)
              , n = Math.sin(e)
              , r = this.elements
              , i = r[0]
              , o = r[3]
              , a = r[6]
              , s = r[1]
              , c = r[4]
              , l = r[7];
            return r[0] = t * i + n * s,
            r[3] = t * o + n * c,
            r[6] = t * a + n * l,
            r[1] = -n * i + t * s,
            r[4] = -n * o + t * c,
            r[7] = -n * a + t * l,
            this
        }
        translate(e, t) {
            const n = this.elements;
            return n[0] += e * n[2],
            n[3] += e * n[5],
            n[6] += e * n[8],
            n[1] += t * n[2],
            n[4] += t * n[5],
            n[7] += t * n[8],
            this
        }
        equals(e) {
            const t = this.elements
              , n = e.elements;
            for (let e = 0; e < 9; e++)
                if (t[e] !== n[e])
                    return !1;
            return !0
        }
        fromArray(e, t=0) {
            for (let n = 0; n < 9; n++)
                this.elements[n] = e[n + t];
            return this
        }
        toArray(e=[], t=0) {
            const n = this.elements;
            return e[t] = n[0],
            e[t + 1] = n[1],
            e[t + 2] = n[2],
            e[t + 3] = n[3],
            e[t + 4] = n[4],
            e[t + 5] = n[5],
            e[t + 6] = n[6],
            e[t + 7] = n[7],
            e[t + 8] = n[8],
            e
        }
        clone() {
            return (new this.constructor).fromArray(this.elements)
        }
    }
    let F;
    z.prototype.isMatrix3 = !0;
    const B = {
        getDataURL: function(e) {
            if (/^data:/i.test(e.src))
                return e.src;
            if ("undefined" == typeof HTMLCanvasElement)
                return e.src;
            let t;
            if (e instanceof HTMLCanvasElement)
                t = e;
            else {
                void 0 === F && (F = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")),
                F.width = e.width,
                F.height = e.height;
                const n = F.getContext("2d");
                e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
                t = F
            }
            return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
            t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
        }
    };
    let U = 0;
    class H extends D {
        constructor(e=H.DEFAULT_IMAGE, t=H.DEFAULT_MAPPING, n=1001, r=1001, i=1006, o=1008, a=1023, s=1009, c=1, l=3e3) {
            super(),
            Object.defineProperty(this, "id", {
                value: U++
            }),
            this.uuid = I.generateUUID(),
            this.name = "",
            this.image = e,
            this.mipmaps = [],
            this.mapping = t,
            this.wrapS = n,
            this.wrapT = r,
            this.magFilter = i,
            this.minFilter = o,
            this.anisotropy = c,
            this.format = a,
            this.internalFormat = null,
            this.type = s,
            this.offset = new k(0,0),
            this.repeat = new k(1,1),
            this.center = new k(0,0),
            this.rotation = 0,
            this.matrixAutoUpdate = !0,
            this.matrix = new z,
            this.generateMipmaps = !0,
            this.premultiplyAlpha = !1,
            this.flipY = !0,
            this.unpackAlignment = 4,
            this.encoding = l,
            this.version = 0,
            this.onUpdate = null
        }
        updateMatrix() {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            return this.name = e.name,
            this.image = e.image,
            this.mipmaps = e.mipmaps.slice(0),
            this.mapping = e.mapping,
            this.wrapS = e.wrapS,
            this.wrapT = e.wrapT,
            this.magFilter = e.magFilter,
            this.minFilter = e.minFilter,
            this.anisotropy = e.anisotropy,
            this.format = e.format,
            this.internalFormat = e.internalFormat,
            this.type = e.type,
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            this.rotation = e.rotation,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrix.copy(e.matrix),
            this.generateMipmaps = e.generateMipmaps,
            this.premultiplyAlpha = e.premultiplyAlpha,
            this.flipY = e.flipY,
            this.unpackAlignment = e.unpackAlignment,
            this.encoding = e.encoding,
            this
        }
        toJSON(e) {
            const t = void 0 === e || "string" == typeof e;
            if (!t && void 0 !== e.textures[this.uuid])
                return e.textures[this.uuid];
            const n = {
                metadata: {
                    version: 4.5,
                    type: "Texture",
                    generator: "Texture.toJSON"
                },
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                const r = this.image;
                if (void 0 === r.uuid && (r.uuid = I.generateUUID()),
                !t && void 0 === e.images[r.uuid]) {
                    let t;
                    if (Array.isArray(r)) {
                        t = [];
                        for (let e = 0, n = r.length; e < n; e++)
                            r[e].isDataTexture ? t.push(j(r[e].image)) : t.push(j(r[e]))
                    } else
                        t = j(r);
                    e.images[r.uuid] = {
                        uuid: r.uuid,
                        url: t
                    }
                }
                n.image = r.uuid
            }
            return t || (e.textures[this.uuid] = n),
            n
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
        transformUv(e) {
            if (300 !== this.mapping)
                return e;
            if (e.applyMatrix3(this.matrix),
            e.x < 0 || e.x > 1)
                switch (this.wrapS) {
                case h:
                    e.x = e.x - Math.floor(e.x);
                    break;
                case d:
                    e.x = e.x < 0 ? 0 : 1;
                    break;
                case p:
                    1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x)
                }
            if (e.y < 0 || e.y > 1)
                switch (this.wrapT) {
                case h:
                    e.y = e.y - Math.floor(e.y);
                    break;
                case d:
                    e.y = e.y < 0 ? 0 : 1;
                    break;
                case p:
                    1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y)
                }
            return this.flipY && (e.y = 1 - e.y),
            e
        }
        set needsUpdate(e) {
            !0 === e && this.version++
        }
    }
    function j(e) {
        return "undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap ? B.getDataURL(e) : e.data ? {
            data: Array.prototype.slice.call(e.data),
            width: e.width,
            height: e.height,
            type: e.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."),
        {})
    }
    H.DEFAULT_IMAGE = void 0,
    H.DEFAULT_MAPPING = 300,
    H.prototype.isTexture = !0;
    class G {
        constructor(e=0, t=0, n=0, r=1) {
            this.x = e,
            this.y = t,
            this.z = n,
            this.w = r
        }
        get width() {
            return this.z
        }
        set width(e) {
            this.z = e
        }
        get height() {
            return this.w
        }
        set height(e) {
            this.w = e
        }
        set(e, t, n, r) {
            return this.x = e,
            this.y = t,
            this.z = n,
            this.w = r,
            this
        }
        setScalar(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this.w = e,
            this
        }
        setX(e) {
            return this.x = e,
            this
        }
        setY(e) {
            return this.y = e,
            this
        }
        setZ(e) {
            return this.z = e,
            this
        }
        setW(e) {
            return this.w = e,
            this
        }
        setComponent(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y,this.z,this.w)
        }
        copy(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this.w = void 0 !== e.w ? e.w : 1,
            this
        }
        add(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this.w += e.w,
            this)
        }
        addScalar(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this.w += e,
            this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this.w = e.w + t.w,
            this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this.w += e.w * t,
            this
        }
        sub(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this.w -= e.w,
            this)
        }
        subScalar(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this.w -= e,
            this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this.w = e.w - t.w,
            this
        }
        multiply(e) {
            return this.x *= e.x,
            this.y *= e.y,
            this.z *= e.z,
            this.w *= e.w,
            this
        }
        multiplyScalar(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this.w *= e,
            this
        }
        applyMatrix4(e) {
            const t = this.x
              , n = this.y
              , r = this.z
              , i = this.w
              , o = e.elements;
            return this.x = o[0] * t + o[4] * n + o[8] * r + o[12] * i,
            this.y = o[1] * t + o[5] * n + o[9] * r + o[13] * i,
            this.z = o[2] * t + o[6] * n + o[10] * r + o[14] * i,
            this.w = o[3] * t + o[7] * n + o[11] * r + o[15] * i,
            this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        setAxisAngleFromQuaternion(e) {
            this.w = 2 * Math.acos(e.w);
            const t = Math.sqrt(1 - e.w * e.w);
            return t < 1e-4 ? (this.x = 1,
            this.y = 0,
            this.z = 0) : (this.x = e.x / t,
            this.y = e.y / t,
            this.z = e.z / t),
            this
        }
        setAxisAngleFromRotationMatrix(e) {
            let t, n, r, i;
            const o = .01
              , a = .1
              , s = e.elements
              , c = s[0]
              , l = s[4]
              , u = s[8]
              , h = s[1]
              , d = s[5]
              , p = s[9]
              , f = s[2]
              , m = s[6]
              , g = s[10];
            if (Math.abs(l - h) < o && Math.abs(u - f) < o && Math.abs(p - m) < o) {
                if (Math.abs(l + h) < a && Math.abs(u + f) < a && Math.abs(p + m) < a && Math.abs(c + d + g - 3) < a)
                    return this.set(1, 0, 0, 0),
                    this;
                t = Math.PI;
                const e = (c + 1) / 2
                  , s = (d + 1) / 2
                  , v = (g + 1) / 2
                  , y = (l + h) / 4
                  , b = (u + f) / 4
                  , x = (p + m) / 4;
                return e > s && e > v ? e < o ? (n = 0,
                r = .707106781,
                i = .707106781) : (n = Math.sqrt(e),
                r = y / n,
                i = b / n) : s > v ? s < o ? (n = .707106781,
                r = 0,
                i = .707106781) : (r = Math.sqrt(s),
                n = y / r,
                i = x / r) : v < o ? (n = .707106781,
                r = .707106781,
                i = 0) : (i = Math.sqrt(v),
                n = b / i,
                r = x / i),
                this.set(n, r, i, t),
                this
            }
            let v = Math.sqrt((m - p) * (m - p) + (u - f) * (u - f) + (h - l) * (h - l));
            return Math.abs(v) < .001 && (v = 1),
            this.x = (m - p) / v,
            this.y = (u - f) / v,
            this.z = (h - l) / v,
            this.w = Math.acos((c + d + g - 1) / 2),
            this
        }
        min(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this.w = Math.min(this.w, e.w),
            this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this.w = Math.max(this.w, e.w),
            this
        }
        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this.w = Math.max(e.w, Math.min(t.w, this.w)),
            this
        }
        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this.z = Math.max(e, Math.min(t, this.z)),
            this.w = Math.max(e, Math.min(t, this.w)),
            this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this.w = Math.floor(this.w),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this.w = Math.ceil(this.w),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this.w = Math.round(this.w),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this.w = -this.w,
            this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this.w += (e.w - this.w) * t,
            this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n,
            this.y = e.y + (t.y - e.y) * n,
            this.z = e.z + (t.z - e.z) * n,
            this.w = e.w + (t.w - e.w) * n,
            this
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
        }
        fromArray(e, t=0) {
            return this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this.w = e[t + 3],
            this
        }
        toArray(e=[], t=0) {
            return e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e[t + 3] = this.w,
            e
        }
        fromBufferAttribute(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this.w = e.getW(t),
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this.w = Math.random(),
            this
        }
    }
    G.prototype.isVector4 = !0;
    class V extends D {
        constructor(e, t, n) {
            super(),
            this.width = e,
            this.height = t,
            this.depth = 1,
            this.scissor = new G(0,0,e,t),
            this.scissorTest = !1,
            this.viewport = new G(0,0,e,t),
            n = n || {},
            this.texture = new H(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),
            this.texture.image = {},
            this.texture.image.width = e,
            this.texture.image.height = t,
            this.texture.image.depth = 1,
            this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps,
            this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : m,
            this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer,
            this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer,
            this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
        }
        setTexture(e) {
            e.image = {
                width: this.width,
                height: this.height,
                depth: this.depth
            },
            this.texture = e
        }
        setSize(e, t, n=1) {
            this.width === e && this.height === t && this.depth === n || (this.width = e,
            this.height = t,
            this.depth = n,
            this.texture.image.width = e,
            this.texture.image.height = t,
            this.texture.image.depth = n,
            this.dispose()),
            this.viewport.set(0, 0, e, t),
            this.scissor.set(0, 0, e, t)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            return this.width = e.width,
            this.height = e.height,
            this.depth = e.depth,
            this.viewport.copy(e.viewport),
            this.texture = e.texture.clone(),
            this.depthBuffer = e.depthBuffer,
            this.stencilBuffer = e.stencilBuffer,
            this.depthTexture = e.depthTexture,
            this
        }
        dispose() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }
    V.prototype.isWebGLRenderTarget = !0;
    class W {
        constructor(e=0, t=0, n=0, r=1) {
            this._x = e,
            this._y = t,
            this._z = n,
            this._w = r
        }
        static slerp(e, t, n, r) {
            return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),
            n.slerpQuaternions(e, t, r)
        }
        static slerpFlat(e, t, n, r, i, o, a) {
            let s = n[r + 0]
              , c = n[r + 1]
              , l = n[r + 2]
              , u = n[r + 3];
            const h = i[o + 0]
              , d = i[o + 1]
              , p = i[o + 2]
              , f = i[o + 3];
            if (0 === a)
                return e[t + 0] = s,
                e[t + 1] = c,
                e[t + 2] = l,
                void (e[t + 3] = u);
            if (1 === a)
                return e[t + 0] = h,
                e[t + 1] = d,
                e[t + 2] = p,
                void (e[t + 3] = f);
            if (u !== f || s !== h || c !== d || l !== p) {
                let e = 1 - a;
                const t = s * h + c * d + l * p + u * f
                  , n = t >= 0 ? 1 : -1
                  , r = 1 - t * t;
                if (r > Number.EPSILON) {
                    const i = Math.sqrt(r)
                      , o = Math.atan2(i, t * n);
                    e = Math.sin(e * o) / i,
                    a = Math.sin(a * o) / i
                }
                const i = a * n;
                if (s = s * e + h * i,
                c = c * e + d * i,
                l = l * e + p * i,
                u = u * e + f * i,
                e === 1 - a) {
                    const e = 1 / Math.sqrt(s * s + c * c + l * l + u * u);
                    s *= e,
                    c *= e,
                    l *= e,
                    u *= e
                }
            }
            e[t] = s,
            e[t + 1] = c,
            e[t + 2] = l,
            e[t + 3] = u
        }
        static multiplyQuaternionsFlat(e, t, n, r, i, o) {
            const a = n[r]
              , s = n[r + 1]
              , c = n[r + 2]
              , l = n[r + 3]
              , u = i[o]
              , h = i[o + 1]
              , d = i[o + 2]
              , p = i[o + 3];
            return e[t] = a * p + l * u + s * d - c * h,
            e[t + 1] = s * p + l * h + c * u - a * d,
            e[t + 2] = c * p + l * d + a * h - s * u,
            e[t + 3] = l * p - a * u - s * h - c * d,
            e
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x = e,
            this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y = e,
            this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(e) {
            this._z = e,
            this._onChangeCallback()
        }
        get w() {
            return this._w
        }
        set w(e) {
            this._w = e,
            this._onChangeCallback()
        }
        set(e, t, n, r) {
            return this._x = e,
            this._y = t,
            this._z = n,
            this._w = r,
            this._onChangeCallback(),
            this
        }
        clone() {
            return new this.constructor(this._x,this._y,this._z,this._w)
        }
        copy(e) {
            return this._x = e.x,
            this._y = e.y,
            this._z = e.z,
            this._w = e.w,
            this._onChangeCallback(),
            this
        }
        setFromEuler(e, t) {
            if (!e || !e.isEuler)
                throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            const n = e._x
              , r = e._y
              , i = e._z
              , o = e._order
              , a = Math.cos
              , s = Math.sin
              , c = a(n / 2)
              , l = a(r / 2)
              , u = a(i / 2)
              , h = s(n / 2)
              , d = s(r / 2)
              , p = s(i / 2);
            switch (o) {
            case "XYZ":
                this._x = h * l * u + c * d * p,
                this._y = c * d * u - h * l * p,
                this._z = c * l * p + h * d * u,
                this._w = c * l * u - h * d * p;
                break;
            case "YXZ":
                this._x = h * l * u + c * d * p,
                this._y = c * d * u - h * l * p,
                this._z = c * l * p - h * d * u,
                this._w = c * l * u + h * d * p;
                break;
            case "ZXY":
                this._x = h * l * u - c * d * p,
                this._y = c * d * u + h * l * p,
                this._z = c * l * p + h * d * u,
                this._w = c * l * u - h * d * p;
                break;
            case "ZYX":
                this._x = h * l * u - c * d * p,
                this._y = c * d * u + h * l * p,
                this._z = c * l * p - h * d * u,
                this._w = c * l * u + h * d * p;
                break;
            case "YZX":
                this._x = h * l * u + c * d * p,
                this._y = c * d * u + h * l * p,
                this._z = c * l * p - h * d * u,
                this._w = c * l * u - h * d * p;
                break;
            case "XZY":
                this._x = h * l * u - c * d * p,
                this._y = c * d * u - h * l * p,
                this._z = c * l * p + h * d * u,
                this._w = c * l * u + h * d * p;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
            }
            return !1 !== t && this._onChangeCallback(),
            this
        }
        setFromAxisAngle(e, t) {
            const n = t / 2
              , r = Math.sin(n);
            return this._x = e.x * r,
            this._y = e.y * r,
            this._z = e.z * r,
            this._w = Math.cos(n),
            this._onChangeCallback(),
            this
        }
        setFromRotationMatrix(e) {
            const t = e.elements
              , n = t[0]
              , r = t[4]
              , i = t[8]
              , o = t[1]
              , a = t[5]
              , s = t[9]
              , c = t[2]
              , l = t[6]
              , u = t[10]
              , h = n + a + u;
            if (h > 0) {
                const e = .5 / Math.sqrt(h + 1);
                this._w = .25 / e,
                this._x = (l - s) * e,
                this._y = (i - c) * e,
                this._z = (o - r) * e
            } else if (n > a && n > u) {
                const e = 2 * Math.sqrt(1 + n - a - u);
                this._w = (l - s) / e,
                this._x = .25 * e,
                this._y = (r + o) / e,
                this._z = (i + c) / e
            } else if (a > u) {
                const e = 2 * Math.sqrt(1 + a - n - u);
                this._w = (i - c) / e,
                this._x = (r + o) / e,
                this._y = .25 * e,
                this._z = (s + l) / e
            } else {
                const e = 2 * Math.sqrt(1 + u - n - a);
                this._w = (o - r) / e,
                this._x = (i + c) / e,
                this._y = (s + l) / e,
                this._z = .25 * e
            }
            return this._onChangeCallback(),
            this
        }
        setFromUnitVectors(e, t) {
            let n = e.dot(t) + 1;
            return n < Number.EPSILON ? (n = 0,
            Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
            this._y = e.x,
            this._z = 0,
            this._w = n) : (this._x = 0,
            this._y = -e.z,
            this._z = e.y,
            this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
            this._y = e.z * t.x - e.x * t.z,
            this._z = e.x * t.y - e.y * t.x,
            this._w = n),
            this.normalize()
        }
        angleTo(e) {
            return 2 * Math.acos(Math.abs(I.clamp(this.dot(e), -1, 1)))
        }
        rotateTowards(e, t) {
            const n = this.angleTo(e);
            if (0 === n)
                return this;
            const r = Math.min(1, t / n);
            return this.slerp(e, r),
            this
        }
        identity() {
            return this.set(0, 0, 0, 1)
        }
        invert() {
            return this.conjugate()
        }
        conjugate() {
            return this._x *= -1,
            this._y *= -1,
            this._z *= -1,
            this._onChangeCallback(),
            this
        }
        dot(e) {
            return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
        }
        lengthSq() {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }
        length() {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }
        normalize() {
            let e = this.length();
            return 0 === e ? (this._x = 0,
            this._y = 0,
            this._z = 0,
            this._w = 1) : (e = 1 / e,
            this._x = this._x * e,
            this._y = this._y * e,
            this._z = this._z * e,
            this._w = this._w * e),
            this._onChangeCallback(),
            this
        }
        multiply(e, t) {
            return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
            this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
        }
        premultiply(e) {
            return this.multiplyQuaternions(e, this)
        }
        multiplyQuaternions(e, t) {
            const n = e._x
              , r = e._y
              , i = e._z
              , o = e._w
              , a = t._x
              , s = t._y
              , c = t._z
              , l = t._w;
            return this._x = n * l + o * a + r * c - i * s,
            this._y = r * l + o * s + i * a - n * c,
            this._z = i * l + o * c + n * s - r * a,
            this._w = o * l - n * a - r * s - i * c,
            this._onChangeCallback(),
            this
        }
        slerp(e, t) {
            if (0 === t)
                return this;
            if (1 === t)
                return this.copy(e);
            const n = this._x
              , r = this._y
              , i = this._z
              , o = this._w;
            let a = o * e._w + n * e._x + r * e._y + i * e._z;
            if (a < 0 ? (this._w = -e._w,
            this._x = -e._x,
            this._y = -e._y,
            this._z = -e._z,
            a = -a) : this.copy(e),
            a >= 1)
                return this._w = o,
                this._x = n,
                this._y = r,
                this._z = i,
                this;
            const s = 1 - a * a;
            if (s <= Number.EPSILON) {
                const e = 1 - t;
                return this._w = e * o + t * this._w,
                this._x = e * n + t * this._x,
                this._y = e * r + t * this._y,
                this._z = e * i + t * this._z,
                this.normalize(),
                this._onChangeCallback(),
                this
            }
            const c = Math.sqrt(s)
              , l = Math.atan2(c, a)
              , u = Math.sin((1 - t) * l) / c
              , h = Math.sin(t * l) / c;
            return this._w = o * u + this._w * h,
            this._x = n * u + this._x * h,
            this._y = r * u + this._y * h,
            this._z = i * u + this._z * h,
            this._onChangeCallback(),
            this
        }
        slerpQuaternions(e, t, n) {
            this.copy(e).slerp(t, n)
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
        }
        fromArray(e, t=0) {
            return this._x = e[t],
            this._y = e[t + 1],
            this._z = e[t + 2],
            this._w = e[t + 3],
            this._onChangeCallback(),
            this
        }
        toArray(e=[], t=0) {
            return e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._w,
            e
        }
        fromBufferAttribute(e, t) {
            return this._x = e.getX(t),
            this._y = e.getY(t),
            this._z = e.getZ(t),
            this._w = e.getW(t),
            this
        }
        _onChange(e) {
            return this._onChangeCallback = e,
            this
        }
        _onChangeCallback() {}
    }
    W.prototype.isQuaternion = !0;
    class q {
        constructor(e=0, t=0, n=0) {
            this.x = e,
            this.y = t,
            this.z = n
        }
        set(e, t, n) {
            return void 0 === n && (n = this.z),
            this.x = e,
            this.y = t,
            this.z = n,
            this
        }
        setScalar(e) {
            return this.x = e,
            this.y = e,
            this.z = e,
            this
        }
        setX(e) {
            return this.x = e,
            this
        }
        setY(e) {
            return this.y = e,
            this
        }
        setZ(e) {
            return this.z = e,
            this
        }
        setComponent(e, t) {
            switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
            }
            return this
        }
        getComponent(e) {
            switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + e)
            }
        }
        clone() {
            return new this.constructor(this.x,this.y,this.z)
        }
        copy(e) {
            return this.x = e.x,
            this.y = e.y,
            this.z = e.z,
            this
        }
        add(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(e, t)) : (this.x += e.x,
            this.y += e.y,
            this.z += e.z,
            this)
        }
        addScalar(e) {
            return this.x += e,
            this.y += e,
            this.z += e,
            this
        }
        addVectors(e, t) {
            return this.x = e.x + t.x,
            this.y = e.y + t.y,
            this.z = e.z + t.z,
            this
        }
        addScaledVector(e, t) {
            return this.x += e.x * t,
            this.y += e.y * t,
            this.z += e.z * t,
            this
        }
        sub(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(e, t)) : (this.x -= e.x,
            this.y -= e.y,
            this.z -= e.z,
            this)
        }
        subScalar(e) {
            return this.x -= e,
            this.y -= e,
            this.z -= e,
            this
        }
        subVectors(e, t) {
            return this.x = e.x - t.x,
            this.y = e.y - t.y,
            this.z = e.z - t.z,
            this
        }
        multiply(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(e, t)) : (this.x *= e.x,
            this.y *= e.y,
            this.z *= e.z,
            this)
        }
        multiplyScalar(e) {
            return this.x *= e,
            this.y *= e,
            this.z *= e,
            this
        }
        multiplyVectors(e, t) {
            return this.x = e.x * t.x,
            this.y = e.y * t.y,
            this.z = e.z * t.z,
            this
        }
        applyEuler(e) {
            return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
            this.applyQuaternion(Y.setFromEuler(e))
        }
        applyAxisAngle(e, t) {
            return this.applyQuaternion(Y.setFromAxisAngle(e, t))
        }
        applyMatrix3(e) {
            const t = this.x
              , n = this.y
              , r = this.z
              , i = e.elements;
            return this.x = i[0] * t + i[3] * n + i[6] * r,
            this.y = i[1] * t + i[4] * n + i[7] * r,
            this.z = i[2] * t + i[5] * n + i[8] * r,
            this
        }
        applyNormalMatrix(e) {
            return this.applyMatrix3(e).normalize()
        }
        applyMatrix4(e) {
            const t = this.x
              , n = this.y
              , r = this.z
              , i = e.elements
              , o = 1 / (i[3] * t + i[7] * n + i[11] * r + i[15]);
            return this.x = (i[0] * t + i[4] * n + i[8] * r + i[12]) * o,
            this.y = (i[1] * t + i[5] * n + i[9] * r + i[13]) * o,
            this.z = (i[2] * t + i[6] * n + i[10] * r + i[14]) * o,
            this
        }
        applyQuaternion(e) {
            const t = this.x
              , n = this.y
              , r = this.z
              , i = e.x
              , o = e.y
              , a = e.z
              , s = e.w
              , c = s * t + o * r - a * n
              , l = s * n + a * t - i * r
              , u = s * r + i * n - o * t
              , h = -i * t - o * n - a * r;
            return this.x = c * s + h * -i + l * -a - u * -o,
            this.y = l * s + h * -o + u * -i - c * -a,
            this.z = u * s + h * -a + c * -o - l * -i,
            this
        }
        project(e) {
            return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
        }
        unproject(e) {
            return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
        }
        transformDirection(e) {
            const t = this.x
              , n = this.y
              , r = this.z
              , i = e.elements;
            return this.x = i[0] * t + i[4] * n + i[8] * r,
            this.y = i[1] * t + i[5] * n + i[9] * r,
            this.z = i[2] * t + i[6] * n + i[10] * r,
            this.normalize()
        }
        divide(e) {
            return this.x /= e.x,
            this.y /= e.y,
            this.z /= e.z,
            this
        }
        divideScalar(e) {
            return this.multiplyScalar(1 / e)
        }
        min(e) {
            return this.x = Math.min(this.x, e.x),
            this.y = Math.min(this.y, e.y),
            this.z = Math.min(this.z, e.z),
            this
        }
        max(e) {
            return this.x = Math.max(this.x, e.x),
            this.y = Math.max(this.y, e.y),
            this.z = Math.max(this.z, e.z),
            this
        }
        clamp(e, t) {
            return this.x = Math.max(e.x, Math.min(t.x, this.x)),
            this.y = Math.max(e.y, Math.min(t.y, this.y)),
            this.z = Math.max(e.z, Math.min(t.z, this.z)),
            this
        }
        clampScalar(e, t) {
            return this.x = Math.max(e, Math.min(t, this.x)),
            this.y = Math.max(e, Math.min(t, this.y)),
            this.z = Math.max(e, Math.min(t, this.z)),
            this
        }
        clampLength(e, t) {
            const n = this.length();
            return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
        }
        floor() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this.z = Math.floor(this.z),
            this
        }
        ceil() {
            return this.x = Math.ceil(this.x),
            this.y = Math.ceil(this.y),
            this.z = Math.ceil(this.z),
            this
        }
        round() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this.z = Math.round(this.z),
            this
        }
        roundToZero() {
            return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x),
            this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y),
            this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z),
            this
        }
        negate() {
            return this.x = -this.x,
            this.y = -this.y,
            this.z = -this.z,
            this
        }
        dot(e) {
            return this.x * e.x + this.y * e.y + this.z * e.z
        }
        lengthSq() {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }
        length() {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }
        manhattanLength() {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }
        normalize() {
            return this.divideScalar(this.length() || 1)
        }
        setLength(e) {
            return this.normalize().multiplyScalar(e)
        }
        lerp(e, t) {
            return this.x += (e.x - this.x) * t,
            this.y += (e.y - this.y) * t,
            this.z += (e.z - this.z) * t,
            this
        }
        lerpVectors(e, t, n) {
            return this.x = e.x + (t.x - e.x) * n,
            this.y = e.y + (t.y - e.y) * n,
            this.z = e.z + (t.z - e.z) * n,
            this
        }
        cross(e, t) {
            return void 0 !== t ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(e, t)) : this.crossVectors(this, e)
        }
        crossVectors(e, t) {
            const n = e.x
              , r = e.y
              , i = e.z
              , o = t.x
              , a = t.y
              , s = t.z;
            return this.x = r * s - i * a,
            this.y = i * o - n * s,
            this.z = n * a - r * o,
            this
        }
        projectOnVector(e) {
            const t = e.lengthSq();
            if (0 === t)
                return this.set(0, 0, 0);
            const n = e.dot(this) / t;
            return this.copy(e).multiplyScalar(n)
        }
        projectOnPlane(e) {
            return X.copy(this).projectOnVector(e),
            this.sub(X)
        }
        reflect(e) {
            return this.sub(X.copy(e).multiplyScalar(2 * this.dot(e)))
        }
        angleTo(e) {
            const t = Math.sqrt(this.lengthSq() * e.lengthSq());
            if (0 === t)
                return Math.PI / 2;
            const n = this.dot(e) / t;
            return Math.acos(I.clamp(n, -1, 1))
        }
        distanceTo(e) {
            return Math.sqrt(this.distanceToSquared(e))
        }
        distanceToSquared(e) {
            const t = this.x - e.x
              , n = this.y - e.y
              , r = this.z - e.z;
            return t * t + n * n + r * r
        }
        manhattanDistanceTo(e) {
            return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
        }
        setFromSpherical(e) {
            return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
        }
        setFromSphericalCoords(e, t, n) {
            const r = Math.sin(t) * e;
            return this.x = r * Math.sin(n),
            this.y = Math.cos(t) * e,
            this.z = r * Math.cos(n),
            this
        }
        setFromCylindrical(e) {
            return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
        }
        setFromCylindricalCoords(e, t, n) {
            return this.x = e * Math.sin(t),
            this.y = n,
            this.z = e * Math.cos(t),
            this
        }
        setFromMatrixPosition(e) {
            const t = e.elements;
            return this.x = t[12],
            this.y = t[13],
            this.z = t[14],
            this
        }
        setFromMatrixScale(e) {
            const t = this.setFromMatrixColumn(e, 0).length()
              , n = this.setFromMatrixColumn(e, 1).length()
              , r = this.setFromMatrixColumn(e, 2).length();
            return this.x = t,
            this.y = n,
            this.z = r,
            this
        }
        setFromMatrixColumn(e, t) {
            return this.fromArray(e.elements, 4 * t)
        }
        setFromMatrix3Column(e, t) {
            return this.fromArray(e.elements, 3 * t)
        }
        equals(e) {
            return e.x === this.x && e.y === this.y && e.z === this.z
        }
        fromArray(e, t=0) {
            return this.x = e[t],
            this.y = e[t + 1],
            this.z = e[t + 2],
            this
        }
        toArray(e=[], t=0) {
            return e[t] = this.x,
            e[t + 1] = this.y,
            e[t + 2] = this.z,
            e
        }
        fromBufferAttribute(e, t, n) {
            return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),
            this.x = e.getX(t),
            this.y = e.getY(t),
            this.z = e.getZ(t),
            this
        }
        random() {
            return this.x = Math.random(),
            this.y = Math.random(),
            this.z = Math.random(),
            this
        }
    }
    q.prototype.isVector3 = !0;
    const X = new q
      , Y = new W;
    class Z {
        constructor(e=new q(1 / 0,1 / 0,1 / 0), t=new q(-1 / 0,-1 / 0,-1 / 0)) {
            this.min = e,
            this.max = t
        }
        set(e, t) {
            return this.min.copy(e),
            this.max.copy(t),
            this
        }
        setFromArray(e) {
            let t = 1 / 0
              , n = 1 / 0
              , r = 1 / 0
              , i = -1 / 0
              , o = -1 / 0
              , a = -1 / 0;
            for (let s = 0, c = e.length; s < c; s += 3) {
                const c = e[s]
                  , l = e[s + 1]
                  , u = e[s + 2];
                c < t && (t = c),
                l < n && (n = l),
                u < r && (r = u),
                c > i && (i = c),
                l > o && (o = l),
                u > a && (a = u)
            }
            return this.min.set(t, n, r),
            this.max.set(i, o, a),
            this
        }
        setFromBufferAttribute(e) {
            let t = 1 / 0
              , n = 1 / 0
              , r = 1 / 0
              , i = -1 / 0
              , o = -1 / 0
              , a = -1 / 0;
            for (let s = 0, c = e.count; s < c; s++) {
                const c = e.getX(s)
                  , l = e.getY(s)
                  , u = e.getZ(s);
                c < t && (t = c),
                l < n && (n = l),
                u < r && (r = u),
                c > i && (i = c),
                l > o && (o = l),
                u > a && (a = u)
            }
            return this.min.set(t, n, r),
            this.max.set(i, o, a),
            this
        }
        setFromPoints(e) {
            this.makeEmpty();
            for (let t = 0, n = e.length; t < n; t++)
                this.expandByPoint(e[t]);
            return this
        }
        setFromCenterAndSize(e, t) {
            const n = J.copy(t).multiplyScalar(.5);
            return this.min.copy(e).sub(n),
            this.max.copy(e).add(n),
            this
        }
        setFromObject(e) {
            return this.makeEmpty(),
            this.expandByObject(e)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            return this.min.copy(e.min),
            this.max.copy(e.max),
            this
        }
        makeEmpty() {
            return this.min.x = this.min.y = this.min.z = 1 / 0,
            this.max.x = this.max.y = this.max.z = -1 / 0,
            this
        }
        isEmpty() {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }
        getCenter(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getCenter() target is now required"),
            e = new q),
            this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
        }
        getSize(e) {
            return void 0 === e && (console.warn("THREE.Box3: .getSize() target is now required"),
            e = new q),
            this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
        }
        expandByPoint(e) {
            return this.min.min(e),
            this.max.max(e),
            this
        }
        expandByVector(e) {
            return this.min.sub(e),
            this.max.add(e),
            this
        }
        expandByScalar(e) {
            return this.min.addScalar(-e),
            this.max.addScalar(e),
            this
        }
        expandByObject(e) {
            e.updateWorldMatrix(!1, !1);
            const t = e.geometry;
            void 0 !== t && (null === t.boundingBox && t.computeBoundingBox(),
            Q.copy(t.boundingBox),
            Q.applyMatrix4(e.matrixWorld),
            this.union(Q));
            const n = e.children;
            for (let e = 0, t = n.length; e < t; e++)
                this.expandByObject(n[e]);
            return this
        }
        containsPoint(e) {
            return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z)
        }
        containsBox(e) {
            return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
        }
        getParameter(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .getParameter() target is now required"),
            t = new q),
            t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
        }
        intersectsBox(e) {
            return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z)
        }
        intersectsSphere(e) {
            return this.clampPoint(e.center, J),
            J.distanceToSquared(e.center) <= e.radius * e.radius
        }
        intersectsPlane(e) {
            let t, n;
            return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
            n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
            n = e.normal.x * this.min.x),
            e.normal.y > 0 ? (t += e.normal.y * this.min.y,
            n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
            n += e.normal.y * this.min.y),
            e.normal.z > 0 ? (t += e.normal.z * this.min.z,
            n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
            n += e.normal.z * this.min.z),
            t <= -e.constant && n >= -e.constant
        }
        intersectsTriangle(e) {
            if (this.isEmpty())
                return !1;
            this.getCenter(oe),
            ae.subVectors(this.max, oe),
            K.subVectors(e.a, oe),
            ee.subVectors(e.b, oe),
            te.subVectors(e.c, oe),
            ne.subVectors(ee, K),
            re.subVectors(te, ee),
            ie.subVectors(K, te);
            let t = [0, -ne.z, ne.y, 0, -re.z, re.y, 0, -ie.z, ie.y, ne.z, 0, -ne.x, re.z, 0, -re.x, ie.z, 0, -ie.x, -ne.y, ne.x, 0, -re.y, re.x, 0, -ie.y, ie.x, 0];
            return !!le(t, K, ee, te, ae) && (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
            !!le(t, K, ee, te, ae) && (se.crossVectors(ne, re),
            t = [se.x, se.y, se.z],
            le(t, K, ee, te, ae)))
        }
        clampPoint(e, t) {
            return void 0 === t && (console.warn("THREE.Box3: .clampPoint() target is now required"),
            t = new q),
            t.copy(e).clamp(this.min, this.max)
        }
        distanceToPoint(e) {
            return J.copy(e).clamp(this.min, this.max).sub(e).length()
        }
        getBoundingSphere(e) {
            return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"),
            this.getCenter(e.center),
            e.radius = .5 * this.getSize(J).length(),
            e
        }
        intersect(e) {
            return this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
        }
        union(e) {
            return this.min.min(e.min),
            this.max.max(e.max),
            this
        }
        applyMatrix4(e) {
            return this.isEmpty() || ($[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
            $[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
            $[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
            $[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
            $[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
            $[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
            $[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
            $[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
            this.setFromPoints($)),
            this
        }
        translate(e) {
            return this.min.add(e),
            this.max.add(e),
            this
        }
        equals(e) {
            return e.min.equals(this.min) && e.max.equals(this.max)
        }
    }
    Z.prototype.isBox3 = !0;
    const $ = [new q, new q, new q, new q, new q, new q, new q, new q]
      , J = new q
      , Q = new Z
      , K = new q
      , ee = new q
      , te = new q
      , ne = new q
      , re = new q
      , ie = new q
      , oe = new q
      , ae = new q
      , se = new q
      , ce = new q;
    function le(e, t, n, r, i) {
        for (let o = 0, a = e.length - 3; o <= a; o += 3) {
            ce.fromArray(e, o);
            const a = i.x * Math.abs(ce.x) + i.y * Math.abs(ce.y) + i.z * Math.abs(ce.z)
              , s = t.dot(ce)
              , c = n.dot(ce)
              , l = r.dot(ce);
            if (Math.max(-Math.max(s, c, l), Math.min(s, c, l)) > a)
                return !1
        }
        return !0
    }
    const ue = new Z
      , he = new q
      , de = new q
      , pe = new q;
    class fe {
        constructor(e=new q, t=-1) {
            this.center = e,
            this.radius = t
        }
        set(e, t) {
            return this.center.copy(e),
            this.radius = t,
            this
        }
        setFromPoints(e, t) {
            const n = this.center;
            void 0 !== t ? n.copy(t) : ue.setFromPoints(e).getCenter(n);
            let r = 0;
            for (let t = 0, i = e.length; t < i; t++)
                r = Math.max(r, n.distanceToSquared(e[t]));
            return this.radius = Math.sqrt(r),
            this
        }
        copy(e) {
            return this.center.copy(e.center),
            this.radius = e.radius,
            this
        }
        isEmpty() {
            return this.radius < 0
        }
        makeEmpty() {
            return this.center.set(0, 0, 0),
            this.radius = -1,
            this
        }
        containsPoint(e) {
            return e.distanceToSquared(this.center) <= this.radius * this.radius
        }
        distanceToPoint(e) {
            return e.distanceTo(this.center) - this.radius
        }
        intersectsSphere(e) {
            const t = this.radius + e.radius;
            return e.center.distanceToSquared(this.center) <= t * t
        }
        intersectsBox(e) {
            return e.intersectsSphere(this)
        }
        intersectsPlane(e) {
            return Math.abs(e.distanceToPoint(this.center)) <= this.radius
        }
        clampPoint(e, t) {
            const n = this.center.distanceToSquared(e);
            return void 0 === t && (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            t = new q),
            t.copy(e),
            n > this.radius * this.radius && (t.sub(this.center).normalize(),
            t.multiplyScalar(this.radius).add(this.center)),
            t
        }
        getBoundingBox(e) {
            return void 0 === e && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"),
            e = new Z),
            this.isEmpty() ? (e.makeEmpty(),
            e) : (e.set(this.center, this.center),
            e.expandByScalar(this.radius),
            e)
        }
        applyMatrix4(e) {
            return this.center.applyMatrix4(e),
            this.radius = this.radius * e.getMaxScaleOnAxis(),
            this
        }
        translate(e) {
            return this.center.add(e),
            this
        }
        expandByPoint(e) {
            pe.subVectors(e, this.center);
            const t = pe.lengthSq();
            if (t > this.radius * this.radius) {
                const e = Math.sqrt(t)
                  , n = .5 * (e - this.radius);
                this.center.add(pe.multiplyScalar(n / e)),
                this.radius += n
            }
            return this
        }
        union(e) {
            return de.subVectors(e.center, this.center).normalize().multiplyScalar(e.radius),
            this.expandByPoint(he.copy(e.center).add(de)),
            this.expandByPoint(he.copy(e.center).sub(de)),
            this
        }
        equals(e) {
            return e.center.equals(this.center) && e.radius === this.radius
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    const me = new q
      , ge = new q
      , ve = new q
      , ye = new q
      , be = new q
      , xe = new q
      , _e = new q;
    class we {
        constructor(e=new q, t=new q(0,0,-1)) {
            this.origin = e,
            this.direction = t
        }
        set(e, t) {
            return this.origin.copy(e),
            this.direction.copy(t),
            this
        }
        copy(e) {
            return this.origin.copy(e.origin),
            this.direction.copy(e.direction),
            this
        }
        at(e, t) {
            return void 0 === t && (console.warn("THREE.Ray: .at() target is now required"),
            t = new q),
            t.copy(this.direction).multiplyScalar(e).add(this.origin)
        }
        lookAt(e) {
            return this.direction.copy(e).sub(this.origin).normalize(),
            this
        }
        recast(e) {
            return this.origin.copy(this.at(e, me)),
            this
        }
        closestPointToPoint(e, t) {
            void 0 === t && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"),
            t = new q),
            t.subVectors(e, this.origin);
            const n = t.dot(this.direction);
            return n < 0 ? t.copy(this.origin) : t.copy(this.direction).multiplyScalar(n).add(this.origin)
        }
        distanceToPoint(e) {
            return Math.sqrt(this.distanceSqToPoint(e))
        }
        distanceSqToPoint(e) {
            const t = me.subVectors(e, this.origin).dot(this.direction);
            return t < 0 ? this.origin.distanceToSquared(e) : (me.copy(this.direction).multiplyScalar(t).add(this.origin),
            me.distanceToSquared(e))
        }
        distanceSqToSegment(e, t, n, r) {
            ge.copy(e).add(t).multiplyScalar(.5),
            ve.copy(t).sub(e).normalize(),
            ye.copy(this.origin).sub(ge);
            const i = .5 * e.distanceTo(t)
              , o = -this.direction.dot(ve)
              , a = ye.dot(this.direction)
              , s = -ye.dot(ve)
              , c = ye.lengthSq()
              , l = Math.abs(1 - o * o);
            let u, h, d, p;
            if (l > 0)
                if (u = o * s - a,
                h = o * a - s,
                p = i * l,
                u >= 0)
                    if (h >= -p)
                        if (h <= p) {
                            const e = 1 / l;
                            u *= e,
                            h *= e,
                            d = u * (u + o * h + 2 * a) + h * (o * u + h + 2 * s) + c
                        } else
                            h = i,
                            u = Math.max(0, -(o * h + a)),
                            d = -u * u + h * (h + 2 * s) + c;
                    else
                        h = -i,
                        u = Math.max(0, -(o * h + a)),
                        d = -u * u + h * (h + 2 * s) + c;
                else
                    h <= -p ? (u = Math.max(0, -(-o * i + a)),
                    h = u > 0 ? -i : Math.min(Math.max(-i, -s), i),
                    d = -u * u + h * (h + 2 * s) + c) : h <= p ? (u = 0,
                    h = Math.min(Math.max(-i, -s), i),
                    d = h * (h + 2 * s) + c) : (u = Math.max(0, -(o * i + a)),
                    h = u > 0 ? i : Math.min(Math.max(-i, -s), i),
                    d = -u * u + h * (h + 2 * s) + c);
            else
                h = o > 0 ? -i : i,
                u = Math.max(0, -(o * h + a)),
                d = -u * u + h * (h + 2 * s) + c;
            return n && n.copy(this.direction).multiplyScalar(u).add(this.origin),
            r && r.copy(ve).multiplyScalar(h).add(ge),
            d
        }
        intersectSphere(e, t) {
            me.subVectors(e.center, this.origin);
            const n = me.dot(this.direction)
              , r = me.dot(me) - n * n
              , i = e.radius * e.radius;
            if (r > i)
                return null;
            const o = Math.sqrt(i - r)
              , a = n - o
              , s = n + o;
            return a < 0 && s < 0 ? null : a < 0 ? this.at(s, t) : this.at(a, t)
        }
        intersectsSphere(e) {
            return this.distanceSqToPoint(e.center) <= e.radius * e.radius
        }
        distanceToPlane(e) {
            const t = e.normal.dot(this.direction);
            if (0 === t)
                return 0 === e.distanceToPoint(this.origin) ? 0 : null;
            const n = -(this.origin.dot(e.normal) + e.constant) / t;
            return n >= 0 ? n : null
        }
        intersectPlane(e, t) {
            const n = this.distanceToPlane(e);
            return null === n ? null : this.at(n, t)
        }
        intersectsPlane(e) {
            const t = e.distanceToPoint(this.origin);
            if (0 === t)
                return !0;
            return e.normal.dot(this.direction) * t < 0
        }
        intersectBox(e, t) {
            let n, r, i, o, a, s;
            const c = 1 / this.direction.x
              , l = 1 / this.direction.y
              , u = 1 / this.direction.z
              , h = this.origin;
            return c >= 0 ? (n = (e.min.x - h.x) * c,
            r = (e.max.x - h.x) * c) : (n = (e.max.x - h.x) * c,
            r = (e.min.x - h.x) * c),
            l >= 0 ? (i = (e.min.y - h.y) * l,
            o = (e.max.y - h.y) * l) : (i = (e.max.y - h.y) * l,
            o = (e.min.y - h.y) * l),
            n > o || i > r ? null : ((i > n || n != n) && (n = i),
            (o < r || r != r) && (r = o),
            u >= 0 ? (a = (e.min.z - h.z) * u,
            s = (e.max.z - h.z) * u) : (a = (e.max.z - h.z) * u,
            s = (e.min.z - h.z) * u),
            n > s || a > r ? null : ((a > n || n != n) && (n = a),
            (s < r || r != r) && (r = s),
            r < 0 ? null : this.at(n >= 0 ? n : r, t)))
        }
        intersectsBox(e) {
            return null !== this.intersectBox(e, me)
        }
        intersectTriangle(e, t, n, r, i) {
            be.subVectors(t, e),
            xe.subVectors(n, e),
            _e.crossVectors(be, xe);
            let o, a = this.direction.dot(_e);
            if (a > 0) {
                if (r)
                    return null;
                o = 1
            } else {
                if (!(a < 0))
                    return null;
                o = -1,
                a = -a
            }
            ye.subVectors(this.origin, e);
            const s = o * this.direction.dot(xe.crossVectors(ye, xe));
            if (s < 0)
                return null;
            const c = o * this.direction.dot(be.cross(ye));
            if (c < 0)
                return null;
            if (s + c > a)
                return null;
            const l = -o * ye.dot(_e);
            return l < 0 ? null : this.at(l / a, i)
        }
        applyMatrix4(e) {
            return this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
        }
        equals(e) {
            return e.origin.equals(this.origin) && e.direction.equals(this.direction)
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    class Me {
        constructor() {
            this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
            arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
        }
        set(e, t, n, r, i, o, a, s, c, l, u, h, d, p, f, m) {
            const g = this.elements;
            return g[0] = e,
            g[4] = t,
            g[8] = n,
            g[12] = r,
            g[1] = i,
            g[5] = o,
            g[9] = a,
            g[13] = s,
            g[2] = c,
            g[6] = l,
            g[10] = u,
            g[14] = h,
            g[3] = d,
            g[7] = p,
            g[11] = f,
            g[15] = m,
            this
        }
        identity() {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        }
        clone() {
            return (new Me).fromArray(this.elements)
        }
        copy(e) {
            const t = this.elements
              , n = e.elements;
            return t[0] = n[0],
            t[1] = n[1],
            t[2] = n[2],
            t[3] = n[3],
            t[4] = n[4],
            t[5] = n[5],
            t[6] = n[6],
            t[7] = n[7],
            t[8] = n[8],
            t[9] = n[9],
            t[10] = n[10],
            t[11] = n[11],
            t[12] = n[12],
            t[13] = n[13],
            t[14] = n[14],
            t[15] = n[15],
            this
        }
        copyPosition(e) {
            const t = this.elements
              , n = e.elements;
            return t[12] = n[12],
            t[13] = n[13],
            t[14] = n[14],
            this
        }
        setFromMatrix3(e) {
            const t = e.elements;
            return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
            this
        }
        extractBasis(e, t, n) {
            return e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
        }
        makeBasis(e, t, n) {
            return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
            this
        }
        extractRotation(e) {
            const t = this.elements
              , n = e.elements
              , r = 1 / Ee.setFromMatrixColumn(e, 0).length()
              , i = 1 / Ee.setFromMatrixColumn(e, 1).length()
              , o = 1 / Ee.setFromMatrixColumn(e, 2).length();
            return t[0] = n[0] * r,
            t[1] = n[1] * r,
            t[2] = n[2] * r,
            t[3] = 0,
            t[4] = n[4] * i,
            t[5] = n[5] * i,
            t[6] = n[6] * i,
            t[7] = 0,
            t[8] = n[8] * o,
            t[9] = n[9] * o,
            t[10] = n[10] * o,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            this
        }
        makeRotationFromEuler(e) {
            e && e.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            const t = this.elements
              , n = e.x
              , r = e.y
              , i = e.z
              , o = Math.cos(n)
              , a = Math.sin(n)
              , s = Math.cos(r)
              , c = Math.sin(r)
              , l = Math.cos(i)
              , u = Math.sin(i);
            if ("XYZ" === e.order) {
                const e = o * l
                  , n = o * u
                  , r = a * l
                  , i = a * u;
                t[0] = s * l,
                t[4] = -s * u,
                t[8] = c,
                t[1] = n + r * c,
                t[5] = e - i * c,
                t[9] = -a * s,
                t[2] = i - e * c,
                t[6] = r + n * c,
                t[10] = o * s
            } else if ("YXZ" === e.order) {
                const e = s * l
                  , n = s * u
                  , r = c * l
                  , i = c * u;
                t[0] = e + i * a,
                t[4] = r * a - n,
                t[8] = o * c,
                t[1] = o * u,
                t[5] = o * l,
                t[9] = -a,
                t[2] = n * a - r,
                t[6] = i + e * a,
                t[10] = o * s
            } else if ("ZXY" === e.order) {
                const e = s * l
                  , n = s * u
                  , r = c * l
                  , i = c * u;
                t[0] = e - i * a,
                t[4] = -o * u,
                t[8] = r + n * a,
                t[1] = n + r * a,
                t[5] = o * l,
                t[9] = i - e * a,
                t[2] = -o * c,
                t[6] = a,
                t[10] = o * s
            } else if ("ZYX" === e.order) {
                const e = o * l
                  , n = o * u
                  , r = a * l
                  , i = a * u;
                t[0] = s * l,
                t[4] = r * c - n,
                t[8] = e * c + i,
                t[1] = s * u,
                t[5] = i * c + e,
                t[9] = n * c - r,
                t[2] = -c,
                t[6] = a * s,
                t[10] = o * s
            } else if ("YZX" === e.order) {
                const e = o * s
                  , n = o * c
                  , r = a * s
                  , i = a * c;
                t[0] = s * l,
                t[4] = i - e * u,
                t[8] = r * u + n,
                t[1] = u,
                t[5] = o * l,
                t[9] = -a * l,
                t[2] = -c * l,
                t[6] = n * u + r,
                t[10] = e - i * u
            } else if ("XZY" === e.order) {
                const e = o * s
                  , n = o * c
                  , r = a * s
                  , i = a * c;
                t[0] = s * l,
                t[4] = -u,
                t[8] = c * l,
                t[1] = e * u + i,
                t[5] = o * l,
                t[9] = n * u - r,
                t[2] = r * u - n,
                t[6] = a * l,
                t[10] = i * u + e
            }
            return t[3] = 0,
            t[7] = 0,
            t[11] = 0,
            t[12] = 0,
            t[13] = 0,
            t[14] = 0,
            t[15] = 1,
            this
        }
        makeRotationFromQuaternion(e) {
            return this.compose(Te, e, Le)
        }
        lookAt(e, t, n) {
            const r = this.elements;
            return Ce.subVectors(e, t),
            0 === Ce.lengthSq() && (Ce.z = 1),
            Ce.normalize(),
            Ae.crossVectors(n, Ce),
            0 === Ae.lengthSq() && (1 === Math.abs(n.z) ? Ce.x += 1e-4 : Ce.z += 1e-4,
            Ce.normalize(),
            Ae.crossVectors(n, Ce)),
            Ae.normalize(),
            Pe.crossVectors(Ce, Ae),
            r[0] = Ae.x,
            r[4] = Pe.x,
            r[8] = Ce.x,
            r[1] = Ae.y,
            r[5] = Pe.y,
            r[9] = Ce.y,
            r[2] = Ae.z,
            r[6] = Pe.z,
            r[10] = Ce.z,
            this
        }
        multiply(e, t) {
            return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
            this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
        }
        premultiply(e) {
            return this.multiplyMatrices(e, this)
        }
        multiplyMatrices(e, t) {
            const n = e.elements
              , r = t.elements
              , i = this.elements
              , o = n[0]
              , a = n[4]
              , s = n[8]
              , c = n[12]
              , l = n[1]
              , u = n[5]
              , h = n[9]
              , d = n[13]
              , p = n[2]
              , f = n[6]
              , m = n[10]
              , g = n[14]
              , v = n[3]
              , y = n[7]
              , b = n[11]
              , x = n[15]
              , _ = r[0]
              , w = r[4]
              , M = r[8]
              , E = r[12]
              , S = r[1]
              , T = r[5]
              , L = r[9]
              , A = r[13]
              , P = r[2]
              , C = r[6]
              , R = r[10]
              , D = r[14]
              , O = r[3]
              , N = r[7]
              , I = r[11]
              , k = r[15];
            return i[0] = o * _ + a * S + s * P + c * O,
            i[4] = o * w + a * T + s * C + c * N,
            i[8] = o * M + a * L + s * R + c * I,
            i[12] = o * E + a * A + s * D + c * k,
            i[1] = l * _ + u * S + h * P + d * O,
            i[5] = l * w + u * T + h * C + d * N,
            i[9] = l * M + u * L + h * R + d * I,
            i[13] = l * E + u * A + h * D + d * k,
            i[2] = p * _ + f * S + m * P + g * O,
            i[6] = p * w + f * T + m * C + g * N,
            i[10] = p * M + f * L + m * R + g * I,
            i[14] = p * E + f * A + m * D + g * k,
            i[3] = v * _ + y * S + b * P + x * O,
            i[7] = v * w + y * T + b * C + x * N,
            i[11] = v * M + y * L + b * R + x * I,
            i[15] = v * E + y * A + b * D + x * k,
            this
        }
        multiplyScalar(e) {
            const t = this.elements;
            return t[0] *= e,
            t[4] *= e,
            t[8] *= e,
            t[12] *= e,
            t[1] *= e,
            t[5] *= e,
            t[9] *= e,
            t[13] *= e,
            t[2] *= e,
            t[6] *= e,
            t[10] *= e,
            t[14] *= e,
            t[3] *= e,
            t[7] *= e,
            t[11] *= e,
            t[15] *= e,
            this
        }
        determinant() {
            const e = this.elements
              , t = e[0]
              , n = e[4]
              , r = e[8]
              , i = e[12]
              , o = e[1]
              , a = e[5]
              , s = e[9]
              , c = e[13]
              , l = e[2]
              , u = e[6]
              , h = e[10]
              , d = e[14];
            return e[3] * (+i * s * u - r * c * u - i * a * h + n * c * h + r * a * d - n * s * d) + e[7] * (+t * s * d - t * c * h + i * o * h - r * o * d + r * c * l - i * s * l) + e[11] * (+t * c * u - t * a * d - i * o * u + n * o * d + i * a * l - n * c * l) + e[15] * (-r * a * l - t * s * u + t * a * h + r * o * u - n * o * h + n * s * l)
        }
        transpose() {
            const e = this.elements;
            let t;
            return t = e[1],
            e[1] = e[4],
            e[4] = t,
            t = e[2],
            e[2] = e[8],
            e[8] = t,
            t = e[6],
            e[6] = e[9],
            e[9] = t,
            t = e[3],
            e[3] = e[12],
            e[12] = t,
            t = e[7],
            e[7] = e[13],
            e[13] = t,
            t = e[11],
            e[11] = e[14],
            e[14] = t,
            this
        }
        setPosition(e, t, n) {
            const r = this.elements;
            return e.isVector3 ? (r[12] = e.x,
            r[13] = e.y,
            r[14] = e.z) : (r[12] = e,
            r[13] = t,
            r[14] = n),
            this
        }
        invert() {
            const e = this.elements
              , t = e[0]
              , n = e[1]
              , r = e[2]
              , i = e[3]
              , o = e[4]
              , a = e[5]
              , s = e[6]
              , c = e[7]
              , l = e[8]
              , u = e[9]
              , h = e[10]
              , d = e[11]
              , p = e[12]
              , f = e[13]
              , m = e[14]
              , g = e[15]
              , v = u * m * c - f * h * c + f * s * d - a * m * d - u * s * g + a * h * g
              , y = p * h * c - l * m * c - p * s * d + o * m * d + l * s * g - o * h * g
              , b = l * f * c - p * u * c + p * a * d - o * f * d - l * a * g + o * u * g
              , x = p * u * s - l * f * s - p * a * h + o * f * h + l * a * m - o * u * m
              , _ = t * v + n * y + r * b + i * x;
            if (0 === _)
                return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            const w = 1 / _;
            return e[0] = v * w,
            e[1] = (f * h * i - u * m * i - f * r * d + n * m * d + u * r * g - n * h * g) * w,
            e[2] = (a * m * i - f * s * i + f * r * c - n * m * c - a * r * g + n * s * g) * w,
            e[3] = (u * s * i - a * h * i - u * r * c + n * h * c + a * r * d - n * s * d) * w,
            e[4] = y * w,
            e[5] = (l * m * i - p * h * i + p * r * d - t * m * d - l * r * g + t * h * g) * w,
            e[6] = (p * s * i - o * m * i - p * r * c + t * m * c + o * r * g - t * s * g) * w,
            e[7] = (o * h * i - l * s * i + l * r * c - t * h * c - o * r * d + t * s * d) * w,
            e[8] = b * w,
            e[9] = (p * u * i - l * f * i - p * n * d + t * f * d + l * n * g - t * u * g) * w,
            e[10] = (o * f * i - p * a * i + p * n * c - t * f * c - o * n * g + t * a * g) * w,
            e[11] = (l * a * i - o * u * i - l * n * c + t * u * c + o * n * d - t * a * d) * w,
            e[12] = x * w,
            e[13] = (l * f * r - p * u * r + p * n * h - t * f * h - l * n * m + t * u * m) * w,
            e[14] = (p * a * r - o * f * r - p * n * s + t * f * s + o * n * m - t * a * m) * w,
            e[15] = (o * u * r - l * a * r + l * n * s - t * u * s - o * n * h + t * a * h) * w,
            this
        }
        scale(e) {
            const t = this.elements
              , n = e.x
              , r = e.y
              , i = e.z;
            return t[0] *= n,
            t[4] *= r,
            t[8] *= i,
            t[1] *= n,
            t[5] *= r,
            t[9] *= i,
            t[2] *= n,
            t[6] *= r,
            t[10] *= i,
            t[3] *= n,
            t[7] *= r,
            t[11] *= i,
            this
        }
        getMaxScaleOnAxis() {
            const e = this.elements
              , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
              , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
              , r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
            return Math.sqrt(Math.max(t, n, r))
        }
        makeTranslation(e, t, n) {
            return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
            this
        }
        makeRotationX(e) {
            const t = Math.cos(e)
              , n = Math.sin(e);
            return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
            this
        }
        makeRotationY(e) {
            const t = Math.cos(e)
              , n = Math.sin(e);
            return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
            this
        }
        makeRotationZ(e) {
            const t = Math.cos(e)
              , n = Math.sin(e);
            return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
            this
        }
        makeRotationAxis(e, t) {
            const n = Math.cos(t)
              , r = Math.sin(t)
              , i = 1 - n
              , o = e.x
              , a = e.y
              , s = e.z
              , c = i * o
              , l = i * a;
            return this.set(c * o + n, c * a - r * s, c * s + r * a, 0, c * a + r * s, l * a + n, l * s - r * o, 0, c * s - r * a, l * s + r * o, i * s * s + n, 0, 0, 0, 0, 1),
            this
        }
        makeScale(e, t, n) {
            return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
            this
        }
        makeShear(e, t, n) {
            return this.set(1, t, n, 0, e, 1, n, 0, e, t, 1, 0, 0, 0, 0, 1),
            this
        }
        compose(e, t, n) {
            const r = this.elements
              , i = t._x
              , o = t._y
              , a = t._z
              , s = t._w
              , c = i + i
              , l = o + o
              , u = a + a
              , h = i * c
              , d = i * l
              , p = i * u
              , f = o * l
              , m = o * u
              , g = a * u
              , v = s * c
              , y = s * l
              , b = s * u
              , x = n.x
              , _ = n.y
              , w = n.z;
            return r[0] = (1 - (f + g)) * x,
            r[1] = (d + b) * x,
            r[2] = (p - y) * x,
            r[3] = 0,
            r[4] = (d - b) * _,
            r[5] = (1 - (h + g)) * _,
            r[6] = (m + v) * _,
            r[7] = 0,
            r[8] = (p + y) * w,
            r[9] = (m - v) * w,
            r[10] = (1 - (h + f)) * w,
            r[11] = 0,
            r[12] = e.x,
            r[13] = e.y,
            r[14] = e.z,
            r[15] = 1,
            this
        }
        decompose(e, t, n) {
            const r = this.elements;
            let i = Ee.set(r[0], r[1], r[2]).length();
            const o = Ee.set(r[4], r[5], r[6]).length()
              , a = Ee.set(r[8], r[9], r[10]).length();
            this.determinant() < 0 && (i = -i),
            e.x = r[12],
            e.y = r[13],
            e.z = r[14],
            Se.copy(this);
            const s = 1 / i
              , c = 1 / o
              , l = 1 / a;
            return Se.elements[0] *= s,
            Se.elements[1] *= s,
            Se.elements[2] *= s,
            Se.elements[4] *= c,
            Se.elements[5] *= c,
            Se.elements[6] *= c,
            Se.elements[8] *= l,
            Se.elements[9] *= l,
            Se.elements[10] *= l,
            t.setFromRotationMatrix(Se),
            n.x = i,
            n.y = o,
            n.z = a,
            this
        }
        makePerspective(e, t, n, r, i, o) {
            void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            const a = this.elements
              , s = 2 * i / (t - e)
              , c = 2 * i / (n - r)
              , l = (t + e) / (t - e)
              , u = (n + r) / (n - r)
              , h = -(o + i) / (o - i)
              , d = -2 * o * i / (o - i);
            return a[0] = s,
            a[4] = 0,
            a[8] = l,
            a[12] = 0,
            a[1] = 0,
            a[5] = c,
            a[9] = u,
            a[13] = 0,
            a[2] = 0,
            a[6] = 0,
            a[10] = h,
            a[14] = d,
            a[3] = 0,
            a[7] = 0,
            a[11] = -1,
            a[15] = 0,
            this
        }
        makeOrthographic(e, t, n, r, i, o) {
            const a = this.elements
              , s = 1 / (t - e)
              , c = 1 / (n - r)
              , l = 1 / (o - i)
              , u = (t + e) * s
              , h = (n + r) * c
              , d = (o + i) * l;
            return a[0] = 2 * s,
            a[4] = 0,
            a[8] = 0,
            a[12] = -u,
            a[1] = 0,
            a[5] = 2 * c,
            a[9] = 0,
            a[13] = -h,
            a[2] = 0,
            a[6] = 0,
            a[10] = -2 * l,
            a[14] = -d,
            a[3] = 0,
            a[7] = 0,
            a[11] = 0,
            a[15] = 1,
            this
        }
        equals(e) {
            const t = this.elements
              , n = e.elements;
            for (let e = 0; e < 16; e++)
                if (t[e] !== n[e])
                    return !1;
            return !0
        }
        fromArray(e, t=0) {
            for (let n = 0; n < 16; n++)
                this.elements[n] = e[n + t];
            return this
        }
        toArray(e=[], t=0) {
            const n = this.elements;
            return e[t] = n[0],
            e[t + 1] = n[1],
            e[t + 2] = n[2],
            e[t + 3] = n[3],
            e[t + 4] = n[4],
            e[t + 5] = n[5],
            e[t + 6] = n[6],
            e[t + 7] = n[7],
            e[t + 8] = n[8],
            e[t + 9] = n[9],
            e[t + 10] = n[10],
            e[t + 11] = n[11],
            e[t + 12] = n[12],
            e[t + 13] = n[13],
            e[t + 14] = n[14],
            e[t + 15] = n[15],
            e
        }
    }
    Me.prototype.isMatrix4 = !0;
    const Ee = new q
      , Se = new Me
      , Te = new q(0,0,0)
      , Le = new q(1,1,1)
      , Ae = new q
      , Pe = new q
      , Ce = new q
      , Re = new Me
      , De = new W;
    class Oe {
        constructor(e=0, t=0, n=0, r=Oe.DefaultOrder) {
            this._x = e,
            this._y = t,
            this._z = n,
            this._order = r
        }
        get x() {
            return this._x
        }
        set x(e) {
            this._x = e,
            this._onChangeCallback()
        }
        get y() {
            return this._y
        }
        set y(e) {
            this._y = e,
            this._onChangeCallback()
        }
        get z() {
            return this._z
        }
        set z(e) {
            this._z = e,
            this._onChangeCallback()
        }
        get order() {
            return this._order
        }
        set order(e) {
            this._order = e,
            this._onChangeCallback()
        }
        set(e, t, n, r) {
            return this._x = e,
            this._y = t,
            this._z = n,
            this._order = r || this._order,
            this._onChangeCallback(),
            this
        }
        clone() {
            return new this.constructor(this._x,this._y,this._z,this._order)
        }
        copy(e) {
            return this._x = e._x,
            this._y = e._y,
            this._z = e._z,
            this._order = e._order,
            this._onChangeCallback(),
            this
        }
        setFromRotationMatrix(e, t, n) {
            const r = I.clamp
              , i = e.elements
              , o = i[0]
              , a = i[4]
              , s = i[8]
              , c = i[1]
              , l = i[5]
              , u = i[9]
              , h = i[2]
              , d = i[6]
              , p = i[10];
            switch (t = t || this._order) {
            case "XYZ":
                this._y = Math.asin(r(s, -1, 1)),
                Math.abs(s) < .9999999 ? (this._x = Math.atan2(-u, p),
                this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(d, l),
                this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-r(u, -1, 1)),
                Math.abs(u) < .9999999 ? (this._y = Math.atan2(s, p),
                this._z = Math.atan2(c, l)) : (this._y = Math.atan2(-h, o),
                this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(r(d, -1, 1)),
                Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, p),
                this._z = Math.atan2(-a, l)) : (this._y = 0,
                this._z = Math.atan2(c, o));
                break;
            case "ZYX":
                this._y = Math.asin(-r(h, -1, 1)),
                Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, p),
                this._z = Math.atan2(c, o)) : (this._x = 0,
                this._z = Math.atan2(-a, l));
                break;
            case "YZX":
                this._z = Math.asin(r(c, -1, 1)),
                Math.abs(c) < .9999999 ? (this._x = Math.atan2(-u, l),
                this._y = Math.atan2(-h, o)) : (this._x = 0,
                this._y = Math.atan2(s, p));
                break;
            case "XZY":
                this._z = Math.asin(-r(a, -1, 1)),
                Math.abs(a) < .9999999 ? (this._x = Math.atan2(d, l),
                this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-u, p),
                this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
            }
            return this._order = t,
            !1 !== n && this._onChangeCallback(),
            this
        }
        setFromQuaternion(e, t, n) {
            return Re.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(Re, t, n)
        }
        setFromVector3(e, t) {
            return this.set(e.x, e.y, e.z, t || this._order)
        }
        reorder(e) {
            return De.setFromEuler(this),
            this.setFromQuaternion(De, e)
        }
        equals(e) {
            return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
        }
        fromArray(e) {
            return this._x = e[0],
            this._y = e[1],
            this._z = e[2],
            void 0 !== e[3] && (this._order = e[3]),
            this._onChangeCallback(),
            this
        }
        toArray(e=[], t=0) {
            return e[t] = this._x,
            e[t + 1] = this._y,
            e[t + 2] = this._z,
            e[t + 3] = this._order,
            e
        }
        toVector3(e) {
            return e ? e.set(this._x, this._y, this._z) : new q(this._x,this._y,this._z)
        }
        _onChange(e) {
            return this._onChangeCallback = e,
            this
        }
        _onChangeCallback() {}
    }
    Oe.prototype.isEuler = !0,
    Oe.DefaultOrder = "XYZ",
    Oe.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
    class Ne {
        constructor() {
            this.mask = 1
        }
        set(e) {
            this.mask = 1 << e | 0
        }
        enable(e) {
            this.mask |= 1 << e | 0
        }
        enableAll() {
            this.mask = -1
        }
        toggle(e) {
            this.mask ^= 1 << e | 0
        }
        disable(e) {
            this.mask &= ~(1 << e | 0)
        }
        disableAll() {
            this.mask = 0
        }
        test(e) {
            return 0 != (this.mask & e.mask)
        }
    }
    let Ie = 0;
    const ke = new q
      , ze = new W
      , Fe = new Me
      , Be = new q
      , Ue = new q
      , He = new q
      , je = new W
      , Ge = new q(1,0,0)
      , Ve = new q(0,1,0)
      , We = new q(0,0,1)
      , qe = {
        type: "added"
    }
      , Xe = {
        type: "removed"
    };
    function Ye() {
        Object.defineProperty(this, "id", {
            value: Ie++
        }),
        this.uuid = I.generateUUID(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = Ye.DefaultUp.clone();
        const e = new q
          , t = new Oe
          , n = new W
          , r = new q(1,1,1);
        t._onChange((function() {
            n.setFromEuler(t, !1)
        }
        )),
        n._onChange((function() {
            t.setFromQuaternion(n, void 0, !1)
        }
        )),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: r
            },
            modelViewMatrix: {
                value: new Me
            },
            normalMatrix: {
                value: new z
            }
        }),
        this.matrix = new Me,
        this.matrixWorld = new Me,
        this.matrixAutoUpdate = Ye.DefaultMatrixAutoUpdate,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new Ne,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    Ye.DefaultUp = new q(0,1,0),
    Ye.DefaultMatrixAutoUpdate = !0,
    Ye.prototype = Object.assign(Object.create(D.prototype), {
        constructor: Ye,
        isObject3D: !0,
        onBeforeRender: function() {},
        onAfterRender: function() {},
        applyMatrix4: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale)
        },
        applyQuaternion: function(e) {
            return this.quaternion.premultiply(e),
            this
        },
        setRotationFromAxisAngle: function(e, t) {
            this.quaternion.setFromAxisAngle(e, t)
        },
        setRotationFromEuler: function(e) {
            this.quaternion.setFromEuler(e, !0)
        },
        setRotationFromMatrix: function(e) {
            this.quaternion.setFromRotationMatrix(e)
        },
        setRotationFromQuaternion: function(e) {
            this.quaternion.copy(e)
        },
        rotateOnAxis: function(e, t) {
            return ze.setFromAxisAngle(e, t),
            this.quaternion.multiply(ze),
            this
        },
        rotateOnWorldAxis: function(e, t) {
            return ze.setFromAxisAngle(e, t),
            this.quaternion.premultiply(ze),
            this
        },
        rotateX: function(e) {
            return this.rotateOnAxis(Ge, e)
        },
        rotateY: function(e) {
            return this.rotateOnAxis(Ve, e)
        },
        rotateZ: function(e) {
            return this.rotateOnAxis(We, e)
        },
        translateOnAxis: function(e, t) {
            return ke.copy(e).applyQuaternion(this.quaternion),
            this.position.add(ke.multiplyScalar(t)),
            this
        },
        translateX: function(e) {
            return this.translateOnAxis(Ge, e)
        },
        translateY: function(e) {
            return this.translateOnAxis(Ve, e)
        },
        translateZ: function(e) {
            return this.translateOnAxis(We, e)
        },
        localToWorld: function(e) {
            return e.applyMatrix4(this.matrixWorld)
        },
        worldToLocal: function(e) {
            return e.applyMatrix4(Fe.copy(this.matrixWorld).invert())
        },
        lookAt: function(e, t, n) {
            e.isVector3 ? Be.copy(e) : Be.set(e, t, n);
            const r = this.parent;
            this.updateWorldMatrix(!0, !1),
            Ue.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight ? Fe.lookAt(Ue, Be, this.up) : Fe.lookAt(Be, Ue, this.up),
            this.quaternion.setFromRotationMatrix(Fe),
            r && (Fe.extractRotation(r.matrixWorld),
            ze.setFromRotationMatrix(Fe),
            this.quaternion.premultiply(ze.invert()))
        },
        add: function(e) {
            if (arguments.length > 1) {
                for (let e = 0; e < arguments.length; e++)
                    this.add(arguments[e]);
                return this
            }
            return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
            this) : (e && e.isObject3D ? (null !== e.parent && e.parent.remove(e),
            e.parent = this,
            this.children.push(e),
            e.dispatchEvent(qe)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
            this)
        },
        remove: function(e) {
            if (arguments.length > 1) {
                for (let e = 0; e < arguments.length; e++)
                    this.remove(arguments[e]);
                return this
            }
            const t = this.children.indexOf(e);
            return -1 !== t && (e.parent = null,
            this.children.splice(t, 1),
            e.dispatchEvent(Xe)),
            this
        },
        clear: function() {
            for (let e = 0; e < this.children.length; e++) {
                const t = this.children[e];
                t.parent = null,
                t.dispatchEvent(Xe)
            }
            return this.children.length = 0,
            this
        },
        attach: function(e) {
            return this.updateWorldMatrix(!0, !1),
            Fe.copy(this.matrixWorld).invert(),
            null !== e.parent && (e.parent.updateWorldMatrix(!0, !1),
            Fe.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(Fe),
            this.add(e),
            e.updateWorldMatrix(!1, !0),
            this
        },
        getObjectById: function(e) {
            return this.getObjectByProperty("id", e)
        },
        getObjectByName: function(e) {
            return this.getObjectByProperty("name", e)
        },
        getObjectByProperty: function(e, t) {
            if (this[e] === t)
                return this;
            for (let n = 0, r = this.children.length; n < r; n++) {
                const r = this.children[n].getObjectByProperty(e, t);
                if (void 0 !== r)
                    return r
            }
        },
        getWorldPosition: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"),
            e = new q),
            this.updateWorldMatrix(!0, !1),
            e.setFromMatrixPosition(this.matrixWorld)
        },
        getWorldQuaternion: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),
            e = new W),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Ue, e, He),
            e
        },
        getWorldScale: function(e) {
            return void 0 === e && (console.warn("THREE.Object3D: .getWorldScale() target is now required"),
            e = new q),
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(Ue, je, e),
            e
        },
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"),
            e = new q),
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(t[8], t[9], t[10]).normalize()
        },
        raycast: function() {},
        traverse: function(e) {
            e(this);
            const t = this.children;
            for (let n = 0, r = t.length; n < r; n++)
                t[n].traverse(e)
        },
        traverseVisible: function(e) {
            if (!1 === this.visible)
                return;
            e(this);
            const t = this.children;
            for (let n = 0, r = t.length; n < r; n++)
                t[n].traverseVisible(e)
        },
        traverseAncestors: function(e) {
            const t = this.parent;
            null !== t && (e(t),
            t.traverseAncestors(e))
        },
        updateMatrix: function() {
            this.matrix.compose(this.position, this.quaternion, this.scale),
            this.matrixWorldNeedsUpdate = !0
        },
        updateMatrixWorld: function(e) {
            this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            e = !0);
            const t = this.children;
            for (let n = 0, r = t.length; n < r; n++)
                t[n].updateMatrixWorld(e)
        },
        updateWorldMatrix: function(e, t) {
            const n = this.parent;
            if (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            !0 === t) {
                const e = this.children;
                for (let t = 0, n = e.length; t < n; t++)
                    e[t].updateWorldMatrix(!1, !0)
            }
        },
        toJSON: function(e) {
            const t = void 0 === e || "string" == typeof e
              , n = {};
            t && (e = {
                geometries: {},
                materials: {},
                textures: {},
                images: {},
                shapes: {},
                skeletons: {},
                animations: {}
            },
            n.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            const r = {};
            function i(t, n) {
                return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)),
                n.uuid
            }
            if (r.uuid = this.uuid,
            r.type = this.type,
            "" !== this.name && (r.name = this.name),
            !0 === this.castShadow && (r.castShadow = !0),
            !0 === this.receiveShadow && (r.receiveShadow = !0),
            !1 === this.visible && (r.visible = !1),
            !1 === this.frustumCulled && (r.frustumCulled = !1),
            0 !== this.renderOrder && (r.renderOrder = this.renderOrder),
            "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData),
            r.layers = this.layers.mask,
            r.matrix = this.matrix.toArray(),
            !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1),
            this.isInstancedMesh && (r.type = "InstancedMesh",
            r.count = this.count,
            r.instanceMatrix = this.instanceMatrix.toJSON(),
            null !== this.instanceColor && (r.instanceColor = this.instanceColor.toJSON())),
            this.isMesh || this.isLine || this.isPoints) {
                r.geometry = i(e.geometries, this.geometry);
                const t = this.geometry.parameters;
                if (void 0 !== t && void 0 !== t.shapes) {
                    const n = t.shapes;
                    if (Array.isArray(n))
                        for (let t = 0, r = n.length; t < r; t++) {
                            const r = n[t];
                            i(e.shapes, r)
                        }
                    else
                        i(e.shapes, n)
                }
            }
            if (this.isSkinnedMesh && (r.bindMode = this.bindMode,
            r.bindMatrix = this.bindMatrix.toArray(),
            void 0 !== this.skeleton && (i(e.skeletons, this.skeleton),
            r.skeleton = this.skeleton.uuid)),
            void 0 !== this.material)
                if (Array.isArray(this.material)) {
                    const t = [];
                    for (let n = 0, r = this.material.length; n < r; n++)
                        t.push(i(e.materials, this.material[n]));
                    r.material = t
                } else
                    r.material = i(e.materials, this.material);
            if (this.children.length > 0) {
                r.children = [];
                for (let t = 0; t < this.children.length; t++)
                    r.children.push(this.children[t].toJSON(e).object)
            }
            if (this.animations.length > 0) {
                r.animations = [];
                for (let t = 0; t < this.animations.length; t++) {
                    const n = this.animations[t];
                    r.animations.push(i(e.animations, n))
                }
            }
            if (t) {
                const t = o(e.geometries)
                  , r = o(e.materials)
                  , i = o(e.textures)
                  , a = o(e.images)
                  , s = o(e.shapes)
                  , c = o(e.skeletons)
                  , l = o(e.animations);
                t.length > 0 && (n.geometries = t),
                r.length > 0 && (n.materials = r),
                i.length > 0 && (n.textures = i),
                a.length > 0 && (n.images = a),
                s.length > 0 && (n.shapes = s),
                c.length > 0 && (n.skeletons = c),
                l.length > 0 && (n.animations = l)
            }
            return n.object = r,
            n;
            function o(e) {
                const t = [];
                for (const n in e) {
                    const r = e[n];
                    delete r.metadata,
                    t.push(r)
                }
                return t
            }
        },
        clone: function(e) {
            return (new this.constructor).copy(this, e)
        },
        copy: function(e, t=!0) {
            if (this.name = e.name,
            this.up.copy(e.up),
            this.position.copy(e.position),
            this.rotation.order = e.rotation.order,
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
            this.layers.mask = e.layers.mask,
            this.visible = e.visible,
            this.castShadow = e.castShadow,
            this.receiveShadow = e.receiveShadow,
            this.frustumCulled = e.frustumCulled,
            this.renderOrder = e.renderOrder,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            !0 === t)
                for (let t = 0; t < e.children.length; t++) {
                    const n = e.children[t];
                    this.add(n.clone())
                }
            return this
        }
    });
    const Ze = new q
      , $e = new q
      , Je = new z;
    class Qe {
        constructor(e=new q(1,0,0), t=0) {
            this.normal = e,
            this.constant = t
        }
        set(e, t) {
            return this.normal.copy(e),
            this.constant = t,
            this
        }
        setComponents(e, t, n, r) {
            return this.normal.set(e, t, n),
            this.constant = r,
            this
        }
        setFromNormalAndCoplanarPoint(e, t) {
            return this.normal.copy(e),
            this.constant = -t.dot(this.normal),
            this
        }
        setFromCoplanarPoints(e, t, n) {
            const r = Ze.subVectors(n, t).cross($e.subVectors(e, t)).normalize();
            return this.setFromNormalAndCoplanarPoint(r, e),
            this
        }
        copy(e) {
            return this.normal.copy(e.normal),
            this.constant = e.constant,
            this
        }
        normalize() {
            const e = 1 / this.normal.length();
            return this.normal.multiplyScalar(e),
            this.constant *= e,
            this
        }
        negate() {
            return this.constant *= -1,
            this.normal.negate(),
            this
        }
        distanceToPoint(e) {
            return this.normal.dot(e) + this.constant
        }
        distanceToSphere(e) {
            return this.distanceToPoint(e.center) - e.radius
        }
        projectPoint(e, t) {
            return void 0 === t && (console.warn("THREE.Plane: .projectPoint() target is now required"),
            t = new q),
            t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)
        }
        intersectLine(e, t) {
            void 0 === t && (console.warn("THREE.Plane: .intersectLine() target is now required"),
            t = new q);
            const n = e.delta(Ze)
              , r = this.normal.dot(n);
            if (0 === r)
                return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
            const i = -(e.start.dot(this.normal) + this.constant) / r;
            return i < 0 || i > 1 ? null : t.copy(n).multiplyScalar(i).add(e.start)
        }
        intersectsLine(e) {
            const t = this.distanceToPoint(e.start)
              , n = this.distanceToPoint(e.end);
            return t < 0 && n > 0 || n < 0 && t > 0
        }
        intersectsBox(e) {
            return e.intersectsPlane(this)
        }
        intersectsSphere(e) {
            return e.intersectsPlane(this)
        }
        coplanarPoint(e) {
            return void 0 === e && (console.warn("THREE.Plane: .coplanarPoint() target is now required"),
            e = new q),
            e.copy(this.normal).multiplyScalar(-this.constant)
        }
        applyMatrix4(e, t) {
            const n = t || Je.getNormalMatrix(e)
              , r = this.coplanarPoint(Ze).applyMatrix4(e)
              , i = this.normal.applyMatrix3(n).normalize();
            return this.constant = -r.dot(i),
            this
        }
        translate(e) {
            return this.constant -= e.dot(this.normal),
            this
        }
        equals(e) {
            return e.normal.equals(this.normal) && e.constant === this.constant
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    Qe.prototype.isPlane = !0;
    const Ke = new q
      , et = new q
      , tt = new q
      , nt = new q
      , rt = new q
      , it = new q
      , ot = new q
      , at = new q
      , st = new q
      , ct = new q;
    class lt {
        constructor(e=new q, t=new q, n=new q) {
            this.a = e,
            this.b = t,
            this.c = n
        }
        static getNormal(e, t, n, r) {
            void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"),
            r = new q),
            r.subVectors(n, t),
            Ke.subVectors(e, t),
            r.cross(Ke);
            const i = r.lengthSq();
            return i > 0 ? r.multiplyScalar(1 / Math.sqrt(i)) : r.set(0, 0, 0)
        }
        static getBarycoord(e, t, n, r, i) {
            Ke.subVectors(r, t),
            et.subVectors(n, t),
            tt.subVectors(e, t);
            const o = Ke.dot(Ke)
              , a = Ke.dot(et)
              , s = Ke.dot(tt)
              , c = et.dot(et)
              , l = et.dot(tt)
              , u = o * c - a * a;
            if (void 0 === i && (console.warn("THREE.Triangle: .getBarycoord() target is now required"),
            i = new q),
            0 === u)
                return i.set(-2, -1, -1);
            const h = 1 / u
              , d = (c * s - a * l) * h
              , p = (o * l - a * s) * h;
            return i.set(1 - d - p, p, d)
        }
        static containsPoint(e, t, n, r) {
            return this.getBarycoord(e, t, n, r, nt),
            nt.x >= 0 && nt.y >= 0 && nt.x + nt.y <= 1
        }
        static getUV(e, t, n, r, i, o, a, s) {
            return this.getBarycoord(e, t, n, r, nt),
            s.set(0, 0),
            s.addScaledVector(i, nt.x),
            s.addScaledVector(o, nt.y),
            s.addScaledVector(a, nt.z),
            s
        }
        static isFrontFacing(e, t, n, r) {
            return Ke.subVectors(n, t),
            et.subVectors(e, t),
            Ke.cross(et).dot(r) < 0
        }
        set(e, t, n) {
            return this.a.copy(e),
            this.b.copy(t),
            this.c.copy(n),
            this
        }
        setFromPointsAndIndices(e, t, n, r) {
            return this.a.copy(e[t]),
            this.b.copy(e[n]),
            this.c.copy(e[r]),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        copy(e) {
            return this.a.copy(e.a),
            this.b.copy(e.b),
            this.c.copy(e.c),
            this
        }
        getArea() {
            return Ke.subVectors(this.c, this.b),
            et.subVectors(this.a, this.b),
            .5 * Ke.cross(et).length()
        }
        getMidpoint(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getMidpoint() target is now required"),
            e = new q),
            e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }
        getNormal(e) {
            return lt.getNormal(this.a, this.b, this.c, e)
        }
        getPlane(e) {
            return void 0 === e && (console.warn("THREE.Triangle: .getPlane() target is now required"),
            e = new Qe),
            e.setFromCoplanarPoints(this.a, this.b, this.c)
        }
        getBarycoord(e, t) {
            return lt.getBarycoord(e, this.a, this.b, this.c, t)
        }
        getUV(e, t, n, r, i) {
            return lt.getUV(e, this.a, this.b, this.c, t, n, r, i)
        }
        containsPoint(e) {
            return lt.containsPoint(e, this.a, this.b, this.c)
        }
        isFrontFacing(e) {
            return lt.isFrontFacing(this.a, this.b, this.c, e)
        }
        intersectsBox(e) {
            return e.intersectsTriangle(this)
        }
        closestPointToPoint(e, t) {
            void 0 === t && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
            t = new q);
            const n = this.a
              , r = this.b
              , i = this.c;
            let o, a;
            rt.subVectors(r, n),
            it.subVectors(i, n),
            at.subVectors(e, n);
            const s = rt.dot(at)
              , c = it.dot(at);
            if (s <= 0 && c <= 0)
                return t.copy(n);
            st.subVectors(e, r);
            const l = rt.dot(st)
              , u = it.dot(st);
            if (l >= 0 && u <= l)
                return t.copy(r);
            const h = s * u - l * c;
            if (h <= 0 && s >= 0 && l <= 0)
                return o = s / (s - l),
                t.copy(n).addScaledVector(rt, o);
            ct.subVectors(e, i);
            const d = rt.dot(ct)
              , p = it.dot(ct);
            if (p >= 0 && d <= p)
                return t.copy(i);
            const f = d * c - s * p;
            if (f <= 0 && c >= 0 && p <= 0)
                return a = c / (c - p),
                t.copy(n).addScaledVector(it, a);
            const m = l * p - d * u;
            if (m <= 0 && u - l >= 0 && d - p >= 0)
                return ot.subVectors(i, r),
                a = (u - l) / (u - l + (d - p)),
                t.copy(r).addScaledVector(ot, a);
            const g = 1 / (m + f + h);
            return o = f * g,
            a = h * g,
            t.copy(n).addScaledVector(rt, o).addScaledVector(it, a)
        }
        equals(e) {
            return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
        }
    }
    let ut = 0;
    function ht() {
        Object.defineProperty(this, "id", {
            value: ut++
        }),
        this.uuid = I.generateUUID(),
        this.name = "",
        this.type = "Material",
        this.fog = !0,
        this.blending = 1,
        this.side = 0,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.blendSrc = 204,
        this.blendDst = 205,
        this.blendEquation = u,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.depthFunc = 3,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = 519,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = A,
        this.stencilZFail = A,
        this.stencilZPass = A,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaTest = 0,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0
    }
    ht.prototype = Object.assign(Object.create(D.prototype), {
        constructor: ht,
        isMaterial: !0,
        onBeforeCompile: function() {},
        customProgramCacheKey: function() {
            return this.onBeforeCompile.toString()
        },
        setValues: function(e) {
            if (void 0 !== e)
                for (const t in e) {
                    const n = e[t];
                    if (void 0 === n) {
                        console.warn("THREE.Material: '" + t + "' parameter is undefined.");
                        continue
                    }
                    if ("shading" === t) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                        this.flatShading = 1 === n;
                        continue
                    }
                    const r = this[t];
                    void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[t] = n : console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.")
                }
        },
        toJSON: function(e) {
            const t = void 0 === e || "string" == typeof e;
            t && (e = {
                textures: {},
                images: {}
            });
            const n = {
                metadata: {
                    version: 4.5,
                    type: "Material",
                    generator: "Material.toJSON"
                }
            };
            function r(e) {
                const t = [];
                for (const n in e) {
                    const r = e[n];
                    delete r.metadata,
                    t.push(r)
                }
                return t
            }
            if (n.uuid = this.uuid,
            n.type = this.type,
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            this.sheen && this.sheen.isColor && (n.sheen = this.sheen.getHex()),
            this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
            this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity),
            this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness && (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
            n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
            n.lightMapIntensity = this.lightMapIntensity),
            this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
            n.aoMapIntensity = this.aoMapIntensity),
            this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
            n.bumpScale = this.bumpScale),
            this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
            n.normalMapType = this.normalMapType,
            n.normalScale = this.normalScale.toArray()),
            this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
            n.displacementScale = this.displacementScale,
            n.displacementBias = this.displacementBias),
            this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
            n.reflectivity = this.reflectivity,
            n.refractionRatio = this.refractionRatio,
            void 0 !== this.combine && (n.combine = this.combine),
            void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)),
            this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.size && (n.size = this.size),
            null !== this.shadowSide && (n.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (n.blending = this.blending),
            0 !== this.side && (n.side = this.side),
            this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = this.transparent),
            n.depthFunc = this.depthFunc,
            n.depthTest = this.depthTest,
            n.depthWrite = this.depthWrite,
            n.colorWrite = this.colorWrite,
            n.stencilWrite = this.stencilWrite,
            n.stencilWriteMask = this.stencilWriteMask,
            n.stencilFunc = this.stencilFunc,
            n.stencilRef = this.stencilRef,
            n.stencilFuncMask = this.stencilFuncMask,
            n.stencilFail = this.stencilFail,
            n.stencilZFail = this.stencilZFail,
            n.stencilZPass = this.stencilZPass,
            this.rotation && 0 !== this.rotation && (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits),
            this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.alphaToCoverage && (n.alphaToCoverage = this.alphaToCoverage),
            !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha),
            !0 === this.wireframe && (n.wireframe = this.wireframe),
            this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.morphTargets && (n.morphTargets = !0),
            !0 === this.morphNormals && (n.morphNormals = !0),
            !0 === this.skinning && (n.skinning = !0),
            !0 === this.flatShading && (n.flatShading = this.flatShading),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData),
            t) {
                const t = r(e.textures)
                  , i = r(e.images);
                t.length > 0 && (n.textures = t),
                i.length > 0 && (n.images = i)
            }
            return n
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            this.name = e.name,
            this.fog = e.fog,
            this.blending = e.blending,
            this.side = e.side,
            this.vertexColors = e.vertexColors,
            this.opacity = e.opacity,
            this.transparent = e.transparent,
            this.blendSrc = e.blendSrc,
            this.blendDst = e.blendDst,
            this.blendEquation = e.blendEquation,
            this.blendSrcAlpha = e.blendSrcAlpha,
            this.blendDstAlpha = e.blendDstAlpha,
            this.blendEquationAlpha = e.blendEquationAlpha,
            this.depthFunc = e.depthFunc,
            this.depthTest = e.depthTest,
            this.depthWrite = e.depthWrite,
            this.stencilWriteMask = e.stencilWriteMask,
            this.stencilFunc = e.stencilFunc,
            this.stencilRef = e.stencilRef,
            this.stencilFuncMask = e.stencilFuncMask,
            this.stencilFail = e.stencilFail,
            this.stencilZFail = e.stencilZFail,
            this.stencilZPass = e.stencilZPass,
            this.stencilWrite = e.stencilWrite;
            const t = e.clippingPlanes;
            let n = null;
            if (null !== t) {
                const e = t.length;
                n = new Array(e);
                for (let r = 0; r !== e; ++r)
                    n[r] = t[r].clone()
            }
            return this.clippingPlanes = n,
            this.clipIntersection = e.clipIntersection,
            this.clipShadows = e.clipShadows,
            this.shadowSide = e.shadowSide,
            this.colorWrite = e.colorWrite,
            this.precision = e.precision,
            this.polygonOffset = e.polygonOffset,
            this.polygonOffsetFactor = e.polygonOffsetFactor,
            this.polygonOffsetUnits = e.polygonOffsetUnits,
            this.dithering = e.dithering,
            this.alphaTest = e.alphaTest,
            this.alphaToCoverage = e.alphaToCoverage,
            this.premultipliedAlpha = e.premultipliedAlpha,
            this.visible = e.visible,
            this.toneMapped = e.toneMapped,
            this.userData = JSON.parse(JSON.stringify(e.userData)),
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    }),
    Object.defineProperty(ht.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    });
    const dt = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    }
      , pt = {
        h: 0,
        s: 0,
        l: 0
    }
      , ft = {
        h: 0,
        s: 0,
        l: 0
    };
    function mt(e, t, n) {
        return n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
    }
    function gt(e) {
        return e < .04045 ? .0773993808 * e : Math.pow(.9478672986 * e + .0521327014, 2.4)
    }
    function vt(e) {
        return e < .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
    }
    class yt {
        constructor(e, t, n) {
            return void 0 === t && void 0 === n ? this.set(e) : this.setRGB(e, t, n)
        }
        set(e) {
            return e && e.isColor ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e),
            this
        }
        setScalar(e) {
            return this.r = e,
            this.g = e,
            this.b = e,
            this
        }
        setHex(e) {
            return e = Math.floor(e),
            this.r = (e >> 16 & 255) / 255,
            this.g = (e >> 8 & 255) / 255,
            this.b = (255 & e) / 255,
            this
        }
        setRGB(e, t, n) {
            return this.r = e,
            this.g = t,
            this.b = n,
            this
        }
        setHSL(e, t, n) {
            if (e = I.euclideanModulo(e, 1),
            t = I.clamp(t, 0, 1),
            n = I.clamp(n, 0, 1),
            0 === t)
                this.r = this.g = this.b = n;
            else {
                const r = n <= .5 ? n * (1 + t) : n + t - n * t
                  , i = 2 * n - r;
                this.r = mt(i, r, e + 1 / 3),
                this.g = mt(i, r, e),
                this.b = mt(i, r, e - 1 / 3)
            }
            return this
        }
        setStyle(e) {
            function t(t) {
                void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
            }
            let n;
            if (n = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)) {
                let e;
                const r = n[1]
                  , i = n[2];
                switch (r) {
                case "rgb":
                case "rgba":
                    if (e = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))
                        return this.r = Math.min(255, parseInt(e[1], 10)) / 255,
                        this.g = Math.min(255, parseInt(e[2], 10)) / 255,
                        this.b = Math.min(255, parseInt(e[3], 10)) / 255,
                        t(e[4]),
                        this;
                    if (e = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i))
                        return this.r = Math.min(100, parseInt(e[1], 10)) / 100,
                        this.g = Math.min(100, parseInt(e[2], 10)) / 100,
                        this.b = Math.min(100, parseInt(e[3], 10)) / 100,
                        t(e[4]),
                        this;
                    break;
                case "hsl":
                case "hsla":
                    if (e = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(i)) {
                        const n = parseFloat(e[1]) / 360
                          , r = parseInt(e[2], 10) / 100
                          , i = parseInt(e[3], 10) / 100;
                        return t(e[4]),
                        this.setHSL(n, r, i)
                    }
                }
            } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
                const e = n[1]
                  , t = e.length;
                if (3 === t)
                    return this.r = parseInt(e.charAt(0) + e.charAt(0), 16) / 255,
                    this.g = parseInt(e.charAt(1) + e.charAt(1), 16) / 255,
                    this.b = parseInt(e.charAt(2) + e.charAt(2), 16) / 255,
                    this;
                if (6 === t)
                    return this.r = parseInt(e.charAt(0) + e.charAt(1), 16) / 255,
                    this.g = parseInt(e.charAt(2) + e.charAt(3), 16) / 255,
                    this.b = parseInt(e.charAt(4) + e.charAt(5), 16) / 255,
                    this
            }
            return e && e.length > 0 ? this.setColorName(e) : this
        }
        setColorName(e) {
            const t = dt[e];
            return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + e),
            this
        }
        clone() {
            return new this.constructor(this.r,this.g,this.b)
        }
        copy(e) {
            return this.r = e.r,
            this.g = e.g,
            this.b = e.b,
            this
        }
        copyGammaToLinear(e, t=2) {
            return this.r = Math.pow(e.r, t),
            this.g = Math.pow(e.g, t),
            this.b = Math.pow(e.b, t),
            this
        }
        copyLinearToGamma(e, t=2) {
            const n = t > 0 ? 1 / t : 1;
            return this.r = Math.pow(e.r, n),
            this.g = Math.pow(e.g, n),
            this.b = Math.pow(e.b, n),
            this
        }
        convertGammaToLinear(e) {
            return this.copyGammaToLinear(this, e),
            this
        }
        convertLinearToGamma(e) {
            return this.copyLinearToGamma(this, e),
            this
        }
        copySRGBToLinear(e) {
            return this.r = gt(e.r),
            this.g = gt(e.g),
            this.b = gt(e.b),
            this
        }
        copyLinearToSRGB(e) {
            return this.r = vt(e.r),
            this.g = vt(e.g),
            this.b = vt(e.b),
            this
        }
        convertSRGBToLinear() {
            return this.copySRGBToLinear(this),
            this
        }
        convertLinearToSRGB() {
            return this.copyLinearToSRGB(this),
            this
        }
        getHex() {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        }
        getHexString() {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        }
        getHSL(e) {
            void 0 === e && (console.warn("THREE.Color: .getHSL() target is now required"),
            e = {
                h: 0,
                s: 0,
                l: 0
            });
            const t = this.r
              , n = this.g
              , r = this.b
              , i = Math.max(t, n, r)
              , o = Math.min(t, n, r);
            let a, s;
            const c = (o + i) / 2;
            if (o === i)
                a = 0,
                s = 0;
            else {
                const e = i - o;
                switch (s = c <= .5 ? e / (i + o) : e / (2 - i - o),
                i) {
                case t:
                    a = (n - r) / e + (n < r ? 6 : 0);
                    break;
                case n:
                    a = (r - t) / e + 2;
                    break;
                case r:
                    a = (t - n) / e + 4
                }
                a /= 6
            }
            return e.h = a,
            e.s = s,
            e.l = c,
            e
        }
        getStyle() {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        }
        offsetHSL(e, t, n) {
            return this.getHSL(pt),
            pt.h += e,
            pt.s += t,
            pt.l += n,
            this.setHSL(pt.h, pt.s, pt.l),
            this
        }
        add(e) {
            return this.r += e.r,
            this.g += e.g,
            this.b += e.b,
            this
        }
        addColors(e, t) {
            return this.r = e.r + t.r,
            this.g = e.g + t.g,
            this.b = e.b + t.b,
            this
        }
        addScalar(e) {
            return this.r += e,
            this.g += e,
            this.b += e,
            this
        }
        sub(e) {
            return this.r = Math.max(0, this.r - e.r),
            this.g = Math.max(0, this.g - e.g),
            this.b = Math.max(0, this.b - e.b),
            this
        }
        multiply(e) {
            return this.r *= e.r,
            this.g *= e.g,
            this.b *= e.b,
            this
        }
        multiplyScalar(e) {
            return this.r *= e,
            this.g *= e,
            this.b *= e,
            this
        }
        lerp(e, t) {
            return this.r += (e.r - this.r) * t,
            this.g += (e.g - this.g) * t,
            this.b += (e.b - this.b) * t,
            this
        }
        lerpColors(e, t, n) {
            return this.r = e.r + (t.r - e.r) * n,
            this.g = e.g + (t.g - e.g) * n,
            this.b = e.b + (t.b - e.b) * n,
            this
        }
        lerpHSL(e, t) {
            this.getHSL(pt),
            e.getHSL(ft);
            const n = I.lerp(pt.h, ft.h, t)
              , r = I.lerp(pt.s, ft.s, t)
              , i = I.lerp(pt.l, ft.l, t);
            return this.setHSL(n, r, i),
            this
        }
        equals(e) {
            return e.r === this.r && e.g === this.g && e.b === this.b
        }
        fromArray(e, t=0) {
            return this.r = e[t],
            this.g = e[t + 1],
            this.b = e[t + 2],
            this
        }
        toArray(e=[], t=0) {
            return e[t] = this.r,
            e[t + 1] = this.g,
            e[t + 2] = this.b,
            e
        }
        fromBufferAttribute(e, t) {
            return this.r = e.getX(t),
            this.g = e.getY(t),
            this.b = e.getZ(t),
            !0 === e.normalized && (this.r /= 255,
            this.g /= 255,
            this.b /= 255),
            this
        }
        toJSON() {
            return this.getHex()
        }
    }
    yt.NAMES = dt,
    yt.prototype.isColor = !0,
    yt.prototype.r = 1,
    yt.prototype.g = 1,
    yt.prototype.b = 1;
    class bt extends ht {
        constructor(e) {
            super(),
            this.type = "MeshBasicMaterial",
            this.color = new yt(16777215),
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = 0,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.skinning = !1,
            this.morphTargets = !1,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.color.copy(e.color),
            this.map = e.map,
            this.lightMap = e.lightMap,
            this.lightMapIntensity = e.lightMapIntensity,
            this.aoMap = e.aoMap,
            this.aoMapIntensity = e.aoMapIntensity,
            this.specularMap = e.specularMap,
            this.alphaMap = e.alphaMap,
            this.envMap = e.envMap,
            this.combine = e.combine,
            this.reflectivity = e.reflectivity,
            this.refractionRatio = e.refractionRatio,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.wireframeLinecap = e.wireframeLinecap,
            this.wireframeLinejoin = e.wireframeLinejoin,
            this.skinning = e.skinning,
            this.morphTargets = e.morphTargets,
            this
        }
    }
    bt.prototype.isMeshBasicMaterial = !0;
    const xt = new q
      , _t = new k;
    function wt(e, t, n) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.normalized = !0 === n,
        this.usage = P,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0
    }
    function Mt(e, t, n) {
        wt.call(this, new Int8Array(e), t, n)
    }
    function Et(e, t, n) {
        wt.call(this, new Uint8Array(e), t, n)
    }
    function St(e, t, n) {
        wt.call(this, new Uint8ClampedArray(e), t, n)
    }
    function Tt(e, t, n) {
        wt.call(this, new Int16Array(e), t, n)
    }
    function Lt(e, t, n) {
        wt.call(this, new Uint16Array(e), t, n)
    }
    function At(e, t, n) {
        wt.call(this, new Int32Array(e), t, n)
    }
    function Pt(e, t, n) {
        wt.call(this, new Uint32Array(e), t, n)
    }
    function Ct(e, t, n) {
        wt.call(this, new Uint16Array(e), t, n)
    }
    function Rt(e, t, n) {
        wt.call(this, new Float32Array(e), t, n)
    }
    function Dt(e, t, n) {
        wt.call(this, new Float64Array(e), t, n)
    }
    function Ot(e) {
        if (0 === e.length)
            return -1 / 0;
        let t = e[0];
        for (let n = 1, r = e.length; n < r; ++n)
            e[n] > t && (t = e[n]);
        return t
    }
    Object.defineProperty(wt.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(wt.prototype, {
        isBufferAttribute: !0,
        onUploadCallback: function() {},
        setUsage: function(e) {
            return this.usage = e,
            this
        },
        copy: function(e) {
            return this.name = e.name,
            this.array = new e.array.constructor(e.array),
            this.itemSize = e.itemSize,
            this.count = e.count,
            this.normalized = e.normalized,
            this.usage = e.usage,
            this
        },
        copyAt: function(e, t, n) {
            e *= this.itemSize,
            n *= t.itemSize;
            for (let r = 0, i = this.itemSize; r < i; r++)
                this.array[e + r] = t.array[n + r];
            return this
        },
        copyArray: function(e) {
            return this.array.set(e),
            this
        },
        copyColorsArray: function(e) {
            const t = this.array;
            let n = 0;
            for (let r = 0, i = e.length; r < i; r++) {
                let i = e[r];
                void 0 === i && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r),
                i = new yt),
                t[n++] = i.r,
                t[n++] = i.g,
                t[n++] = i.b
            }
            return this
        },
        copyVector2sArray: function(e) {
            const t = this.array;
            let n = 0;
            for (let r = 0, i = e.length; r < i; r++) {
                let i = e[r];
                void 0 === i && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r),
                i = new k),
                t[n++] = i.x,
                t[n++] = i.y
            }
            return this
        },
        copyVector3sArray: function(e) {
            const t = this.array;
            let n = 0;
            for (let r = 0, i = e.length; r < i; r++) {
                let i = e[r];
                void 0 === i && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r),
                i = new q),
                t[n++] = i.x,
                t[n++] = i.y,
                t[n++] = i.z
            }
            return this
        },
        copyVector4sArray: function(e) {
            const t = this.array;
            let n = 0;
            for (let r = 0, i = e.length; r < i; r++) {
                let i = e[r];
                void 0 === i && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r),
                i = new G),
                t[n++] = i.x,
                t[n++] = i.y,
                t[n++] = i.z,
                t[n++] = i.w
            }
            return this
        },
        applyMatrix3: function(e) {
            if (2 === this.itemSize)
                for (let t = 0, n = this.count; t < n; t++)
                    _t.fromBufferAttribute(this, t),
                    _t.applyMatrix3(e),
                    this.setXY(t, _t.x, _t.y);
            else if (3 === this.itemSize)
                for (let t = 0, n = this.count; t < n; t++)
                    xt.fromBufferAttribute(this, t),
                    xt.applyMatrix3(e),
                    this.setXYZ(t, xt.x, xt.y, xt.z);
            return this
        },
        applyMatrix4: function(e) {
            for (let t = 0, n = this.count; t < n; t++)
                xt.x = this.getX(t),
                xt.y = this.getY(t),
                xt.z = this.getZ(t),
                xt.applyMatrix4(e),
                this.setXYZ(t, xt.x, xt.y, xt.z);
            return this
        },
        applyNormalMatrix: function(e) {
            for (let t = 0, n = this.count; t < n; t++)
                xt.x = this.getX(t),
                xt.y = this.getY(t),
                xt.z = this.getZ(t),
                xt.applyNormalMatrix(e),
                this.setXYZ(t, xt.x, xt.y, xt.z);
            return this
        },
        transformDirection: function(e) {
            for (let t = 0, n = this.count; t < n; t++)
                xt.x = this.getX(t),
                xt.y = this.getY(t),
                xt.z = this.getZ(t),
                xt.transformDirection(e),
                this.setXYZ(t, xt.x, xt.y, xt.z);
            return this
        },
        set: function(e, t=0) {
            return this.array.set(e, t),
            this
        },
        getX: function(e) {
            return this.array[e * this.itemSize]
        },
        setX: function(e, t) {
            return this.array[e * this.itemSize] = t,
            this
        },
        getY: function(e) {
            return this.array[e * this.itemSize + 1]
        },
        setY: function(e, t) {
            return this.array[e * this.itemSize + 1] = t,
            this
        },
        getZ: function(e) {
            return this.array[e * this.itemSize + 2]
        },
        setZ: function(e, t) {
            return this.array[e * this.itemSize + 2] = t,
            this
        },
        getW: function(e) {
            return this.array[e * this.itemSize + 3]
        },
        setW: function(e, t) {
            return this.array[e * this.itemSize + 3] = t,
            this
        },
        setXY: function(e, t, n) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = n,
            this
        },
        setXYZ: function(e, t, n, r) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = n,
            this.array[e + 2] = r,
            this
        },
        setXYZW: function(e, t, n, r, i) {
            return e *= this.itemSize,
            this.array[e + 0] = t,
            this.array[e + 1] = n,
            this.array[e + 2] = r,
            this.array[e + 3] = i,
            this
        },
        onUpload: function(e) {
            return this.onUploadCallback = e,
            this
        },
        clone: function() {
            return new this.constructor(this.array,this.itemSize).copy(this)
        },
        toJSON: function() {
            const e = {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: Array.prototype.slice.call(this.array),
                normalized: this.normalized
            };
            return "" !== this.name && (e.name = this.name),
            this.usage !== P && (e.usage = this.usage),
            0 === this.updateRange.offset && -1 === this.updateRange.count || (e.updateRange = this.updateRange),
            e
        }
    }),
    Mt.prototype = Object.create(wt.prototype),
    Mt.prototype.constructor = Mt,
    Et.prototype = Object.create(wt.prototype),
    Et.prototype.constructor = Et,
    St.prototype = Object.create(wt.prototype),
    St.prototype.constructor = St,
    Tt.prototype = Object.create(wt.prototype),
    Tt.prototype.constructor = Tt,
    Lt.prototype = Object.create(wt.prototype),
    Lt.prototype.constructor = Lt,
    At.prototype = Object.create(wt.prototype),
    At.prototype.constructor = At,
    Pt.prototype = Object.create(wt.prototype),
    Pt.prototype.constructor = Pt,
    Ct.prototype = Object.create(wt.prototype),
    Ct.prototype.constructor = Ct,
    Ct.prototype.isFloat16BufferAttribute = !0,
    Rt.prototype = Object.create(wt.prototype),
    Rt.prototype.constructor = Rt,
    Dt.prototype = Object.create(wt.prototype),
    Dt.prototype.constructor = Dt;
    let Nt = 0;
    const It = new Me
      , kt = new Ye
      , zt = new q
      , Ft = new Z
      , Bt = new Z
      , Ut = new q;
    function Ht() {
        Object.defineProperty(this, "id", {
            value: Nt++
        }),
        this.uuid = I.generateUUID(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    Ht.prototype = Object.assign(Object.create(D.prototype), {
        constructor: Ht,
        isBufferGeometry: !0,
        getIndex: function() {
            return this.index
        },
        setIndex: function(e) {
            return Array.isArray(e) ? this.index = new (Ot(e) > 65535 ? Pt : Lt)(e,1) : this.index = e,
            this
        },
        getAttribute: function(e) {
            return this.attributes[e]
        },
        setAttribute: function(e, t) {
            return this.attributes[e] = t,
            this
        },
        deleteAttribute: function(e) {
            return delete this.attributes[e],
            this
        },
        hasAttribute: function(e) {
            return void 0 !== this.attributes[e]
        },
        addGroup: function(e, t, n=0) {
            this.groups.push({
                start: e,
                count: t,
                materialIndex: n
            })
        },
        clearGroups: function() {
            this.groups = []
        },
        setDrawRange: function(e, t) {
            this.drawRange.start = e,
            this.drawRange.count = t
        },
        applyMatrix4: function(e) {
            const t = this.attributes.position;
            void 0 !== t && (t.applyMatrix4(e),
            t.needsUpdate = !0);
            const n = this.attributes.normal;
            if (void 0 !== n) {
                const t = (new z).getNormalMatrix(e);
                n.applyNormalMatrix(t),
                n.needsUpdate = !0
            }
            const r = this.attributes.tangent;
            return void 0 !== r && (r.transformDirection(e),
            r.needsUpdate = !0),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
        },
        rotateX: function(e) {
            return It.makeRotationX(e),
            this.applyMatrix4(It),
            this
        },
        rotateY: function(e) {
            return It.makeRotationY(e),
            this.applyMatrix4(It),
            this
        },
        rotateZ: function(e) {
            return It.makeRotationZ(e),
            this.applyMatrix4(It),
            this
        },
        translate: function(e, t, n) {
            return It.makeTranslation(e, t, n),
            this.applyMatrix4(It),
            this
        },
        scale: function(e, t, n) {
            return It.makeScale(e, t, n),
            this.applyMatrix4(It),
            this
        },
        lookAt: function(e) {
            return kt.lookAt(e),
            kt.updateMatrix(),
            this.applyMatrix4(kt.matrix),
            this
        },
        center: function() {
            return this.computeBoundingBox(),
            this.boundingBox.getCenter(zt).negate(),
            this.translate(zt.x, zt.y, zt.z),
            this
        },
        setFromPoints: function(e) {
            const t = [];
            for (let n = 0, r = e.length; n < r; n++) {
                const r = e[n];
                t.push(r.x, r.y, r.z || 0)
            }
            return this.setAttribute("position", new Rt(t,3)),
            this
        },
        computeBoundingBox: function() {
            null === this.boundingBox && (this.boundingBox = new Z);
            const e = this.attributes.position
              , t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute)
                return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this),
                void this.boundingBox.set(new q(-1 / 0,-1 / 0,-1 / 0), new q(1 / 0,1 / 0,1 / 0));
            if (void 0 !== e) {
                if (this.boundingBox.setFromBufferAttribute(e),
                t)
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        Ft.setFromBufferAttribute(n),
                        this.morphTargetsRelative ? (Ut.addVectors(this.boundingBox.min, Ft.min),
                        this.boundingBox.expandByPoint(Ut),
                        Ut.addVectors(this.boundingBox.max, Ft.max),
                        this.boundingBox.expandByPoint(Ut)) : (this.boundingBox.expandByPoint(Ft.min),
                        this.boundingBox.expandByPoint(Ft.max))
                    }
            } else
                this.boundingBox.makeEmpty();
            (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        },
        computeBoundingSphere: function() {
            null === this.boundingSphere && (this.boundingSphere = new fe);
            const e = this.attributes.position
              , t = this.morphAttributes.position;
            if (e && e.isGLBufferAttribute)
                return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this),
                void this.boundingSphere.set(new q, 1 / 0);
            if (e) {
                const n = this.boundingSphere.center;
                if (Ft.setFromBufferAttribute(e),
                t)
                    for (let e = 0, n = t.length; e < n; e++) {
                        const n = t[e];
                        Bt.setFromBufferAttribute(n),
                        this.morphTargetsRelative ? (Ut.addVectors(Ft.min, Bt.min),
                        Ft.expandByPoint(Ut),
                        Ut.addVectors(Ft.max, Bt.max),
                        Ft.expandByPoint(Ut)) : (Ft.expandByPoint(Bt.min),
                        Ft.expandByPoint(Bt.max))
                    }
                Ft.getCenter(n);
                let r = 0;
                for (let t = 0, i = e.count; t < i; t++)
                    Ut.fromBufferAttribute(e, t),
                    r = Math.max(r, n.distanceToSquared(Ut));
                if (t)
                    for (let i = 0, o = t.length; i < o; i++) {
                        const o = t[i]
                          , a = this.morphTargetsRelative;
                        for (let t = 0, i = o.count; t < i; t++)
                            Ut.fromBufferAttribute(o, t),
                            a && (zt.fromBufferAttribute(e, t),
                            Ut.add(zt)),
                            r = Math.max(r, n.distanceToSquared(Ut))
                    }
                this.boundingSphere.radius = Math.sqrt(r),
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        },
        computeFaceNormals: function() {},
        computeTangents: function() {
            const e = this.index
              , t = this.attributes;
            if (null === e || void 0 === t.position || void 0 === t.normal || void 0 === t.uv)
                return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            const n = e.array
              , r = t.position.array
              , i = t.normal.array
              , o = t.uv.array
              , a = r.length / 3;
            void 0 === t.tangent && this.setAttribute("tangent", new wt(new Float32Array(4 * a),4));
            const s = t.tangent.array
              , c = []
              , l = [];
            for (let e = 0; e < a; e++)
                c[e] = new q,
                l[e] = new q;
            const u = new q
              , h = new q
              , d = new q
              , p = new k
              , f = new k
              , m = new k
              , g = new q
              , v = new q;
            function y(e, t, n) {
                u.fromArray(r, 3 * e),
                h.fromArray(r, 3 * t),
                d.fromArray(r, 3 * n),
                p.fromArray(o, 2 * e),
                f.fromArray(o, 2 * t),
                m.fromArray(o, 2 * n),
                h.sub(u),
                d.sub(u),
                f.sub(p),
                m.sub(p);
                const i = 1 / (f.x * m.y - m.x * f.y);
                isFinite(i) && (g.copy(h).multiplyScalar(m.y).addScaledVector(d, -f.y).multiplyScalar(i),
                v.copy(d).multiplyScalar(f.x).addScaledVector(h, -m.x).multiplyScalar(i),
                c[e].add(g),
                c[t].add(g),
                c[n].add(g),
                l[e].add(v),
                l[t].add(v),
                l[n].add(v))
            }
            let b = this.groups;
            0 === b.length && (b = [{
                start: 0,
                count: n.length
            }]);
            for (let e = 0, t = b.length; e < t; ++e) {
                const t = b[e]
                  , r = t.start;
                for (let e = r, i = r + t.count; e < i; e += 3)
                    y(n[e + 0], n[e + 1], n[e + 2])
            }
            const x = new q
              , _ = new q
              , w = new q
              , M = new q;
            function E(e) {
                w.fromArray(i, 3 * e),
                M.copy(w);
                const t = c[e];
                x.copy(t),
                x.sub(w.multiplyScalar(w.dot(t))).normalize(),
                _.crossVectors(M, t);
                const n = _.dot(l[e]) < 0 ? -1 : 1;
                s[4 * e] = x.x,
                s[4 * e + 1] = x.y,
                s[4 * e + 2] = x.z,
                s[4 * e + 3] = n
            }
            for (let e = 0, t = b.length; e < t; ++e) {
                const t = b[e]
                  , r = t.start;
                for (let e = r, i = r + t.count; e < i; e += 3)
                    E(n[e + 0]),
                    E(n[e + 1]),
                    E(n[e + 2])
            }
        },
        computeVertexNormals: function() {
            const e = this.index
              , t = this.getAttribute("position");
            if (void 0 !== t) {
                let n = this.getAttribute("normal");
                if (void 0 === n)
                    n = new wt(new Float32Array(3 * t.count),3),
                    this.setAttribute("normal", n);
                else
                    for (let e = 0, t = n.count; e < t; e++)
                        n.setXYZ(e, 0, 0, 0);
                const r = new q
                  , i = new q
                  , o = new q
                  , a = new q
                  , s = new q
                  , c = new q
                  , l = new q
                  , u = new q;
                if (e)
                    for (let h = 0, d = e.count; h < d; h += 3) {
                        const d = e.getX(h + 0)
                          , p = e.getX(h + 1)
                          , f = e.getX(h + 2);
                        r.fromBufferAttribute(t, d),
                        i.fromBufferAttribute(t, p),
                        o.fromBufferAttribute(t, f),
                        l.subVectors(o, i),
                        u.subVectors(r, i),
                        l.cross(u),
                        a.fromBufferAttribute(n, d),
                        s.fromBufferAttribute(n, p),
                        c.fromBufferAttribute(n, f),
                        a.add(l),
                        s.add(l),
                        c.add(l),
                        n.setXYZ(d, a.x, a.y, a.z),
                        n.setXYZ(p, s.x, s.y, s.z),
                        n.setXYZ(f, c.x, c.y, c.z)
                    }
                else
                    for (let e = 0, a = t.count; e < a; e += 3)
                        r.fromBufferAttribute(t, e + 0),
                        i.fromBufferAttribute(t, e + 1),
                        o.fromBufferAttribute(t, e + 2),
                        l.subVectors(o, i),
                        u.subVectors(r, i),
                        l.cross(u),
                        n.setXYZ(e + 0, l.x, l.y, l.z),
                        n.setXYZ(e + 1, l.x, l.y, l.z),
                        n.setXYZ(e + 2, l.x, l.y, l.z);
                this.normalizeNormals(),
                n.needsUpdate = !0
            }
        },
        merge: function(e, t) {
            if (!e || !e.isBufferGeometry)
                return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e);
            void 0 === t && (t = 0,
            console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
            const n = this.attributes;
            for (const r in n) {
                if (void 0 === e.attributes[r])
                    continue;
                const i = n[r].array
                  , o = e.attributes[r]
                  , a = o.array
                  , s = o.itemSize * t
                  , c = Math.min(a.length, i.length - s);
                for (let e = 0, t = s; e < c; e++,
                t++)
                    i[t] = a[e]
            }
            return this
        },
        normalizeNormals: function() {
            const e = this.attributes.normal;
            for (let t = 0, n = e.count; t < n; t++)
                Ut.fromBufferAttribute(e, t),
                Ut.normalize(),
                e.setXYZ(t, Ut.x, Ut.y, Ut.z)
        },
        toNonIndexed: function() {
            function e(e, t) {
                const n = e.array
                  , r = e.itemSize
                  , i = e.normalized
                  , o = new n.constructor(t.length * r);
                let a = 0
                  , s = 0;
                for (let e = 0, i = t.length; e < i; e++) {
                    a = t[e] * r;
                    for (let e = 0; e < r; e++)
                        o[s++] = n[a++]
                }
                return new wt(o,r,i)
            }
            if (null === this.index)
                return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
                this;
            const t = new Ht
              , n = this.index.array
              , r = this.attributes;
            for (const i in r) {
                const o = e(r[i], n);
                t.setAttribute(i, o)
            }
            const i = this.morphAttributes;
            for (const r in i) {
                const o = []
                  , a = i[r];
                for (let t = 0, r = a.length; t < r; t++) {
                    const r = e(a[t], n);
                    o.push(r)
                }
                t.morphAttributes[r] = o
            }
            t.morphTargetsRelative = this.morphTargetsRelative;
            const o = this.groups;
            for (let e = 0, n = o.length; e < n; e++) {
                const n = o[e];
                t.addGroup(n.start, n.count, n.materialIndex)
            }
            return t
        },
        toJSON: function() {
            const e = {
                metadata: {
                    version: 4.5,
                    type: "BufferGeometry",
                    generator: "BufferGeometry.toJSON"
                }
            };
            if (e.uuid = this.uuid,
            e.type = this.type,
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 && (e.userData = this.userData),
            void 0 !== this.parameters) {
                const t = this.parameters;
                for (const n in t)
                    void 0 !== t[n] && (e[n] = t[n]);
                return e
            }
            e.data = {
                attributes: {}
            };
            const t = this.index;
            null !== t && (e.data.index = {
                type: t.array.constructor.name,
                array: Array.prototype.slice.call(t.array)
            });
            const n = this.attributes;
            for (const t in n) {
                const r = n[t];
                e.data.attributes[t] = r.toJSON(e.data)
            }
            const r = {};
            let i = !1;
            for (const t in this.morphAttributes) {
                const n = this.morphAttributes[t]
                  , o = [];
                for (let t = 0, r = n.length; t < r; t++) {
                    const r = n[t];
                    o.push(r.toJSON(e.data))
                }
                o.length > 0 && (r[t] = o,
                i = !0)
            }
            i && (e.data.morphAttributes = r,
            e.data.morphTargetsRelative = this.morphTargetsRelative);
            const o = this.groups;
            o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
            const a = this.boundingSphere;
            return null !== a && (e.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius
            }),
            e
        },
        clone: function() {
            return (new Ht).copy(this)
        },
        copy: function(e) {
            this.index = null,
            this.attributes = {},
            this.morphAttributes = {},
            this.groups = [],
            this.boundingBox = null,
            this.boundingSphere = null;
            const t = {};
            this.name = e.name;
            const n = e.index;
            null !== n && this.setIndex(n.clone(t));
            const r = e.attributes;
            for (const e in r) {
                const n = r[e];
                this.setAttribute(e, n.clone(t))
            }
            const i = e.morphAttributes;
            for (const e in i) {
                const n = []
                  , r = i[e];
                for (let e = 0, i = r.length; e < i; e++)
                    n.push(r[e].clone(t));
                this.morphAttributes[e] = n
            }
            this.morphTargetsRelative = e.morphTargetsRelative;
            const o = e.groups;
            for (let e = 0, t = o.length; e < t; e++) {
                const t = o[e];
                this.addGroup(t.start, t.count, t.materialIndex)
            }
            const a = e.boundingBox;
            null !== a && (this.boundingBox = a.clone());
            const s = e.boundingSphere;
            return null !== s && (this.boundingSphere = s.clone()),
            this.drawRange.start = e.drawRange.start,
            this.drawRange.count = e.drawRange.count,
            this.userData = e.userData,
            this
        },
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    const jt = new Me
      , Gt = new we
      , Vt = new fe
      , Wt = new q
      , qt = new q
      , Xt = new q
      , Yt = new q
      , Zt = new q
      , $t = new q
      , Jt = new q
      , Qt = new q
      , Kt = new q
      , en = new k
      , tn = new k
      , nn = new k
      , rn = new q
      , on = new q;
    function an(e=new Ht, t=new bt) {
        Ye.call(this),
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    function sn(e, t, n, r, i, o, a, s, c, l, u, h) {
        Wt.fromBufferAttribute(i, l),
        qt.fromBufferAttribute(i, u),
        Xt.fromBufferAttribute(i, h);
        const d = e.morphTargetInfluences;
        if (t.morphTargets && o && d) {
            Jt.set(0, 0, 0),
            Qt.set(0, 0, 0),
            Kt.set(0, 0, 0);
            for (let e = 0, t = o.length; e < t; e++) {
                const t = d[e]
                  , n = o[e];
                0 !== t && (Yt.fromBufferAttribute(n, l),
                Zt.fromBufferAttribute(n, u),
                $t.fromBufferAttribute(n, h),
                a ? (Jt.addScaledVector(Yt, t),
                Qt.addScaledVector(Zt, t),
                Kt.addScaledVector($t, t)) : (Jt.addScaledVector(Yt.sub(Wt), t),
                Qt.addScaledVector(Zt.sub(qt), t),
                Kt.addScaledVector($t.sub(Xt), t)))
            }
            Wt.add(Jt),
            qt.add(Qt),
            Xt.add(Kt)
        }
        e.isSkinnedMesh && t.skinning && (e.boneTransform(l, Wt),
        e.boneTransform(u, qt),
        e.boneTransform(h, Xt));
        const p = function(e, t, n, r, i, o, a, s) {
            let c;
            if (c = 1 === t.side ? r.intersectTriangle(a, o, i, !0, s) : r.intersectTriangle(i, o, a, 2 !== t.side, s),
            null === c)
                return null;
            on.copy(s),
            on.applyMatrix4(e.matrixWorld);
            const l = n.ray.origin.distanceTo(on);
            return l < n.near || l > n.far ? null : {
                distance: l,
                point: on.clone(),
                object: e
            }
        }(e, t, n, r, Wt, qt, Xt, rn);
        if (p) {
            s && (en.fromBufferAttribute(s, l),
            tn.fromBufferAttribute(s, u),
            nn.fromBufferAttribute(s, h),
            p.uv = lt.getUV(rn, Wt, qt, Xt, en, tn, nn, new k)),
            c && (en.fromBufferAttribute(c, l),
            tn.fromBufferAttribute(c, u),
            nn.fromBufferAttribute(c, h),
            p.uv2 = lt.getUV(rn, Wt, qt, Xt, en, tn, nn, new k));
            const e = {
                a: l,
                b: u,
                c: h,
                normal: new q,
                materialIndex: 0
            };
            lt.getNormal(Wt, qt, Xt, e.normal),
            p.face = e
        }
        return p
    }
    an.prototype = Object.assign(Object.create(Ye.prototype), {
        constructor: an,
        isMesh: !0,
        copy: function(e) {
            return Ye.prototype.copy.call(this, e),
            void 0 !== e.morphTargetInfluences && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
            this.material = e.material,
            this.geometry = e.geometry,
            this
        },
        updateMorphTargets: function() {
            const e = this.geometry;
            if (e.isBufferGeometry) {
                const t = e.morphAttributes
                  , n = Object.keys(t);
                if (n.length > 0) {
                    const e = t[n[0]];
                    if (void 0 !== e) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t].name || String(t);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = t
                        }
                    }
                }
            } else {
                const t = e.morphTargets;
                void 0 !== t && t.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        },
        raycast: function(e, t) {
            const n = this.geometry
              , r = this.material
              , i = this.matrixWorld;
            if (void 0 === r)
                return;
            if (null === n.boundingSphere && n.computeBoundingSphere(),
            Vt.copy(n.boundingSphere),
            Vt.applyMatrix4(i),
            !1 === e.ray.intersectsSphere(Vt))
                return;
            if (jt.copy(i).invert(),
            Gt.copy(e.ray).applyMatrix4(jt),
            null !== n.boundingBox && !1 === Gt.intersectsBox(n.boundingBox))
                return;
            let o;
            if (n.isBufferGeometry) {
                const i = n.index
                  , a = n.attributes.position
                  , s = n.morphAttributes.position
                  , c = n.morphTargetsRelative
                  , l = n.attributes.uv
                  , u = n.attributes.uv2
                  , h = n.groups
                  , d = n.drawRange;
                if (null !== i)
                    if (Array.isArray(r))
                        for (let n = 0, p = h.length; n < p; n++) {
                            const p = h[n]
                              , f = r[p.materialIndex];
                            for (let n = Math.max(p.start, d.start), r = Math.min(p.start + p.count, d.start + d.count); n < r; n += 3) {
                                const r = i.getX(n)
                                  , h = i.getX(n + 1)
                                  , d = i.getX(n + 2);
                                o = sn(this, f, e, Gt, a, s, c, l, u, r, h, d),
                                o && (o.faceIndex = Math.floor(n / 3),
                                o.face.materialIndex = p.materialIndex,
                                t.push(o))
                            }
                        }
                    else {
                        for (let n = Math.max(0, d.start), h = Math.min(i.count, d.start + d.count); n < h; n += 3) {
                            const h = i.getX(n)
                              , d = i.getX(n + 1)
                              , p = i.getX(n + 2);
                            o = sn(this, r, e, Gt, a, s, c, l, u, h, d, p),
                            o && (o.faceIndex = Math.floor(n / 3),
                            t.push(o))
                        }
                    }
                else if (void 0 !== a)
                    if (Array.isArray(r))
                        for (let n = 0, i = h.length; n < i; n++) {
                            const i = h[n]
                              , p = r[i.materialIndex];
                            for (let n = Math.max(i.start, d.start), r = Math.min(i.start + i.count, d.start + d.count); n < r; n += 3) {
                                o = sn(this, p, e, Gt, a, s, c, l, u, n, n + 1, n + 2),
                                o && (o.faceIndex = Math.floor(n / 3),
                                o.face.materialIndex = i.materialIndex,
                                t.push(o))
                            }
                        }
                    else {
                        for (let n = Math.max(0, d.start), i = Math.min(a.count, d.start + d.count); n < i; n += 3) {
                            o = sn(this, r, e, Gt, a, s, c, l, u, n, n + 1, n + 2),
                            o && (o.faceIndex = Math.floor(n / 3),
                            t.push(o))
                        }
                    }
            } else
                n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }
    });
    class cn extends Ht {
        constructor(e=1, t=1, n=1, r=1, i=1, o=1) {
            super(),
            this.type = "BoxGeometry",
            this.parameters = {
                width: e,
                height: t,
                depth: n,
                widthSegments: r,
                heightSegments: i,
                depthSegments: o
            };
            const a = this;
            r = Math.floor(r),
            i = Math.floor(i),
            o = Math.floor(o);
            const s = []
              , c = []
              , l = []
              , u = [];
            let h = 0
              , d = 0;
            function p(e, t, n, r, i, o, p, f, m, g, v) {
                const y = o / m
                  , b = p / g
                  , x = o / 2
                  , _ = p / 2
                  , w = f / 2
                  , M = m + 1
                  , E = g + 1;
                let S = 0
                  , T = 0;
                const L = new q;
                for (let o = 0; o < E; o++) {
                    const a = o * b - _;
                    for (let s = 0; s < M; s++) {
                        const h = s * y - x;
                        L[e] = h * r,
                        L[t] = a * i,
                        L[n] = w,
                        c.push(L.x, L.y, L.z),
                        L[e] = 0,
                        L[t] = 0,
                        L[n] = f > 0 ? 1 : -1,
                        l.push(L.x, L.y, L.z),
                        u.push(s / m),
                        u.push(1 - o / g),
                        S += 1
                    }
                }
                for (let e = 0; e < g; e++)
                    for (let t = 0; t < m; t++) {
                        const n = h + t + M * e
                          , r = h + t + M * (e + 1)
                          , i = h + (t + 1) + M * (e + 1)
                          , o = h + (t + 1) + M * e;
                        s.push(n, r, o),
                        s.push(r, i, o),
                        T += 6
                    }
                a.addGroup(d, T, v),
                d += T,
                h += S
            }
            p("z", "y", "x", -1, -1, n, t, e, o, i, 0),
            p("z", "y", "x", 1, -1, n, t, -e, o, i, 1),
            p("x", "z", "y", 1, 1, e, n, t, r, o, 2),
            p("x", "z", "y", 1, -1, e, n, -t, r, o, 3),
            p("x", "y", "z", 1, -1, e, t, n, r, i, 4),
            p("x", "y", "z", -1, -1, e, t, -n, r, i, 5),
            this.setIndex(s),
            this.setAttribute("position", new Rt(c,3)),
            this.setAttribute("normal", new Rt(l,3)),
            this.setAttribute("uv", new Rt(u,2))
        }
    }
    function ln(e) {
        const t = {};
        for (const n in e) {
            t[n] = {};
            for (const r in e[n]) {
                const i = e[n][r];
                i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
            }
        }
        return t
    }
    function un(e) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
            const r = ln(e[n]);
            for (const e in r)
                t[e] = r[e]
        }
        return t
    }
    const hn = {
        clone: ln,
        merge: un
    };
    function dn(e) {
        ht.call(this),
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),
        this.setValues(e))
    }
    function pn() {
        Ye.call(this),
        this.type = "Camera",
        this.matrixWorldInverse = new Me,
        this.projectionMatrix = new Me,
        this.projectionMatrixInverse = new Me
    }
    function fn(e=50, t=1, n=.1, r=2e3) {
        pn.call(this),
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = n,
        this.far = r,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    dn.prototype = Object.create(ht.prototype),
    dn.prototype.constructor = dn,
    dn.prototype.isShaderMaterial = !0,
    dn.prototype.copy = function(e) {
        return ht.prototype.copy.call(this, e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = ln(e.uniforms),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    ,
    dn.prototype.toJSON = function(e) {
        const t = ht.prototype.toJSON.call(this, e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const n in this.uniforms) {
            const r = this.uniforms[n].value;
            r && r.isTexture ? t.uniforms[n] = {
                type: "t",
                value: r.toJSON(e).uuid
            } : r && r.isColor ? t.uniforms[n] = {
                type: "c",
                value: r.getHex()
            } : r && r.isVector2 ? t.uniforms[n] = {
                type: "v2",
                value: r.toArray()
            } : r && r.isVector3 ? t.uniforms[n] = {
                type: "v3",
                value: r.toArray()
            } : r && r.isVector4 ? t.uniforms[n] = {
                type: "v4",
                value: r.toArray()
            } : r && r.isMatrix3 ? t.uniforms[n] = {
                type: "m3",
                value: r.toArray()
            } : r && r.isMatrix4 ? t.uniforms[n] = {
                type: "m4",
                value: r.toArray()
            } : t.uniforms[n] = {
                value: r
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader;
        const n = {};
        for (const e in this.extensions)
            !0 === this.extensions[e] && (n[e] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n),
        t
    }
    ,
    pn.prototype = Object.assign(Object.create(Ye.prototype), {
        constructor: pn,
        isCamera: !0,
        copy: function(e, t) {
            return Ye.prototype.copy.call(this, e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            this
        },
        getWorldDirection: function(e) {
            void 0 === e && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
            e = new q),
            this.updateWorldMatrix(!0, !1);
            const t = this.matrixWorld.elements;
            return e.set(-t[8], -t[9], -t[10]).normalize()
        },
        updateMatrixWorld: function(e) {
            Ye.prototype.updateMatrixWorld.call(this, e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        },
        updateWorldMatrix: function(e, t) {
            Ye.prototype.updateWorldMatrix.call(this, e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert()
        },
        clone: function() {
            return (new this.constructor).copy(this)
        }
    }),
    fn.prototype = Object.assign(Object.create(pn.prototype), {
        constructor: fn,
        isPerspectiveCamera: !0,
        copy: function(e, t) {
            return pn.prototype.copy.call(this, e, t),
            this.fov = e.fov,
            this.zoom = e.zoom,
            this.near = e.near,
            this.far = e.far,
            this.focus = e.focus,
            this.aspect = e.aspect,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this.filmGauge = e.filmGauge,
            this.filmOffset = e.filmOffset,
            this
        },
        setFocalLength: function(e) {
            const t = .5 * this.getFilmHeight() / e;
            this.fov = 2 * I.RAD2DEG * Math.atan(t),
            this.updateProjectionMatrix()
        },
        getFocalLength: function() {
            const e = Math.tan(.5 * I.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / e
        },
        getEffectiveFOV: function() {
            return 2 * I.RAD2DEG * Math.atan(Math.tan(.5 * I.DEG2RAD * this.fov) / this.zoom)
        },
        getFilmWidth: function() {
            return this.filmGauge * Math.min(this.aspect, 1)
        },
        getFilmHeight: function() {
            return this.filmGauge / Math.max(this.aspect, 1)
        },
        setViewOffset: function(e, t, n, r, i, o) {
            this.aspect = e / t,
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = n,
            this.view.offsetY = r,
            this.view.width = i,
            this.view.height = o,
            this.updateProjectionMatrix()
        },
        clearViewOffset: function() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        },
        updateProjectionMatrix: function() {
            const e = this.near;
            let t = e * Math.tan(.5 * I.DEG2RAD * this.fov) / this.zoom
              , n = 2 * t
              , r = this.aspect * n
              , i = -.5 * r;
            const o = this.view;
            if (null !== this.view && this.view.enabled) {
                const e = o.fullWidth
                  , a = o.fullHeight;
                i += o.offsetX * r / e,
                t -= o.offsetY * n / a,
                r *= o.width / e,
                n *= o.height / a
            }
            const a = this.filmOffset;
            0 !== a && (i += e * a / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(i, i + r, t, t - n, e, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        },
        toJSON: function(e) {
            const t = Ye.prototype.toJSON.call(this, e);
            return t.object.fov = this.fov,
            t.object.zoom = this.zoom,
            t.object.near = this.near,
            t.object.far = this.far,
            t.object.focus = this.focus,
            t.object.aspect = this.aspect,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t.object.filmGauge = this.filmGauge,
            t.object.filmOffset = this.filmOffset,
            t
        }
    });
    const mn = 90;
    class gn extends Ye {
        constructor(e, t, n) {
            if (super(),
            this.type = "CubeCamera",
            !0 !== n.isWebGLCubeRenderTarget)
                return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
            this.renderTarget = n;
            const r = new fn(mn,1,e,t);
            r.layers = this.layers,
            r.up.set(0, -1, 0),
            r.lookAt(new q(1,0,0)),
            this.add(r);
            const i = new fn(mn,1,e,t);
            i.layers = this.layers,
            i.up.set(0, -1, 0),
            i.lookAt(new q(-1,0,0)),
            this.add(i);
            const o = new fn(mn,1,e,t);
            o.layers = this.layers,
            o.up.set(0, 0, 1),
            o.lookAt(new q(0,1,0)),
            this.add(o);
            const a = new fn(mn,1,e,t);
            a.layers = this.layers,
            a.up.set(0, 0, -1),
            a.lookAt(new q(0,-1,0)),
            this.add(a);
            const s = new fn(mn,1,e,t);
            s.layers = this.layers,
            s.up.set(0, -1, 0),
            s.lookAt(new q(0,0,1)),
            this.add(s);
            const c = new fn(mn,1,e,t);
            c.layers = this.layers,
            c.up.set(0, -1, 0),
            c.lookAt(new q(0,0,-1)),
            this.add(c)
        }
        update(e, t) {
            null === this.parent && this.updateMatrixWorld();
            const n = this.renderTarget
              , [r,i,o,a,s,c] = this.children
              , l = e.xr.enabled
              , u = e.getRenderTarget();
            e.xr.enabled = !1;
            const h = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1,
            e.setRenderTarget(n, 0),
            e.render(t, r),
            e.setRenderTarget(n, 1),
            e.render(t, i),
            e.setRenderTarget(n, 2),
            e.render(t, o),
            e.setRenderTarget(n, 3),
            e.render(t, a),
            e.setRenderTarget(n, 4),
            e.render(t, s),
            n.texture.generateMipmaps = h,
            e.setRenderTarget(n, 5),
            e.render(t, c),
            e.setRenderTarget(u),
            e.xr.enabled = l
        }
    }
    class vn extends H {
        constructor(e, t, n, r, i, o, a, s, c, l) {
            super(e = void 0 !== e ? e : [], t = void 0 !== t ? t : 301, n, r, i, o, a = void 0 !== a ? a : M, s, c, l),
            this._needsFlipEnvMap = !0,
            this.flipY = !1
        }
        get images() {
            return this.image
        }
        set images(e) {
            this.image = e
        }
    }
    vn.prototype.isCubeTexture = !0;
    class yn extends V {
        constructor(e, t, n) {
            Number.isInteger(t) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),
            t = n),
            super(e, e, t),
            t = t || {},
            this.texture = new vn(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),
            this.texture.generateMipmaps = void 0 !== t.generateMipmaps && t.generateMipmaps,
            this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : m,
            this.texture._needsFlipEnvMap = !1
        }
        fromEquirectangularTexture(e, t) {
            this.texture.type = t.type,
            this.texture.format = E,
            this.texture.encoding = t.encoding,
            this.texture.generateMipmaps = t.generateMipmaps,
            this.texture.minFilter = t.minFilter,
            this.texture.magFilter = t.magFilter;
            const n = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
                fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
            }
              , r = new cn(5,5,5)
              , i = new dn({
                name: "CubemapFromEquirect",
                uniforms: ln(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: 1,
                blending: 0
            });
            i.uniforms.tEquirect.value = t;
            const o = new an(r,i)
              , a = t.minFilter;
            t.minFilter === g && (t.minFilter = m);
            return new gn(1,10,this).update(e, o),
            t.minFilter = a,
            o.geometry.dispose(),
            o.material.dispose(),
            this
        }
        clear(e, t, n, r) {
            const i = e.getRenderTarget();
            for (let i = 0; i < 6; i++)
                e.setRenderTarget(this, i),
                e.clear(t, n, r);
            e.setRenderTarget(i)
        }
    }
    yn.prototype.isWebGLCubeRenderTarget = !0;
    class bn extends H {
        constructor(e, t, n, r, i, o, a, s, c, l, u, h) {
            super(null, o, a, s, c, l, r, i, u, h),
            this.image = {
                data: e || null,
                width: t || 1,
                height: n || 1
            },
            this.magFilter = void 0 !== c ? c : f,
            this.minFilter = void 0 !== l ? l : f,
            this.generateMipmaps = !1,
            this.flipY = !1,
            this.unpackAlignment = 1,
            this.needsUpdate = !0
        }
    }
    bn.prototype.isDataTexture = !0;
    const xn = new fe
      , _n = new q;
    class wn {
        constructor(e=new Qe, t=new Qe, n=new Qe, r=new Qe, i=new Qe, o=new Qe) {
            this.planes = [e, t, n, r, i, o]
        }
        set(e, t, n, r, i, o) {
            const a = this.planes;
            return a[0].copy(e),
            a[1].copy(t),
            a[2].copy(n),
            a[3].copy(r),
            a[4].copy(i),
            a[5].copy(o),
            this
        }
        copy(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++)
                t[n].copy(e.planes[n]);
            return this
        }
        setFromProjectionMatrix(e) {
            const t = this.planes
              , n = e.elements
              , r = n[0]
              , i = n[1]
              , o = n[2]
              , a = n[3]
              , s = n[4]
              , c = n[5]
              , l = n[6]
              , u = n[7]
              , h = n[8]
              , d = n[9]
              , p = n[10]
              , f = n[11]
              , m = n[12]
              , g = n[13]
              , v = n[14]
              , y = n[15];
            return t[0].setComponents(a - r, u - s, f - h, y - m).normalize(),
            t[1].setComponents(a + r, u + s, f + h, y + m).normalize(),
            t[2].setComponents(a + i, u + c, f + d, y + g).normalize(),
            t[3].setComponents(a - i, u - c, f - d, y - g).normalize(),
            t[4].setComponents(a - o, u - l, f - p, y - v).normalize(),
            t[5].setComponents(a + o, u + l, f + p, y + v).normalize(),
            this
        }
        intersectsObject(e) {
            const t = e.geometry;
            return null === t.boundingSphere && t.computeBoundingSphere(),
            xn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),
            this.intersectsSphere(xn)
        }
        intersectsSprite(e) {
            return xn.center.set(0, 0, 0),
            xn.radius = .7071067811865476,
            xn.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(xn)
        }
        intersectsSphere(e) {
            const t = this.planes
              , n = e.center
              , r = -e.radius;
            for (let e = 0; e < 6; e++) {
                if (t[e].distanceToPoint(n) < r)
                    return !1
            }
            return !0
        }
        intersectsBox(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++) {
                const r = t[n];
                if (_n.x = r.normal.x > 0 ? e.max.x : e.min.x,
                _n.y = r.normal.y > 0 ? e.max.y : e.min.y,
                _n.z = r.normal.z > 0 ? e.max.z : e.min.z,
                r.distanceToPoint(_n) < 0)
                    return !1
            }
            return !0
        }
        containsPoint(e) {
            const t = this.planes;
            for (let n = 0; n < 6; n++)
                if (t[n].distanceToPoint(e) < 0)
                    return !1;
            return !0
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    function Mn() {
        let e = null
          , t = !1
          , n = null
          , r = null;
        function i(t, o) {
            n(t, o),
            r = e.requestAnimationFrame(i)
        }
        return {
            start: function() {
                !0 !== t && null !== n && (r = e.requestAnimationFrame(i),
                t = !0)
            },
            stop: function() {
                e.cancelAnimationFrame(r),
                t = !1
            },
            setAnimationLoop: function(e) {
                n = e
            },
            setContext: function(t) {
                e = t
            }
        }
    }
    function En(e, t) {
        const n = t.isWebGL2
          , r = new WeakMap;
        return {
            get: function(e) {
                return e.isInterleavedBufferAttribute && (e = e.data),
                r.get(e)
            },
            remove: function(t) {
                t.isInterleavedBufferAttribute && (t = t.data);
                const n = r.get(t);
                n && (e.deleteBuffer(n.buffer),
                r.delete(t))
            },
            update: function(t, i) {
                if (t.isGLBufferAttribute) {
                    const e = r.get(t);
                    return void ((!e || e.version < t.version) && r.set(t, {
                        buffer: t.buffer,
                        type: t.type,
                        bytesPerElement: t.elementSize,
                        version: t.version
                    }))
                }
                t.isInterleavedBufferAttribute && (t = t.data);
                const o = r.get(t);
                void 0 === o ? r.set(t, function(t, r) {
                    const i = t.array
                      , o = t.usage
                      , a = e.createBuffer();
                    e.bindBuffer(r, a),
                    e.bufferData(r, i, o),
                    t.onUploadCallback();
                    let s = 5126;
                    return i instanceof Float32Array ? s = 5126 : i instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : i instanceof Uint16Array ? t.isFloat16BufferAttribute ? n ? s = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : s = 5123 : i instanceof Int16Array ? s = 5122 : i instanceof Uint32Array ? s = 5125 : i instanceof Int32Array ? s = 5124 : i instanceof Int8Array ? s = 5120 : i instanceof Uint8Array && (s = 5121),
                    {
                        buffer: a,
                        type: s,
                        bytesPerElement: i.BYTES_PER_ELEMENT,
                        version: t.version
                    }
                }(t, i)) : o.version < t.version && (!function(t, r, i) {
                    const o = r.array
                      , a = r.updateRange;
                    e.bindBuffer(i, t),
                    -1 === a.count ? e.bufferSubData(i, 0, o) : (n ? e.bufferSubData(i, a.offset * o.BYTES_PER_ELEMENT, o, a.offset, a.count) : e.bufferSubData(i, a.offset * o.BYTES_PER_ELEMENT, o.subarray(a.offset, a.offset + a.count)),
                    a.count = -1)
                }(o.buffer, t, i),
                o.version = t.version)
            }
        }
    }
    class Sn extends Ht {
        constructor(e=1, t=1, n=1, r=1) {
            super(),
            this.type = "PlaneGeometry",
            this.parameters = {
                width: e,
                height: t,
                widthSegments: n,
                heightSegments: r
            };
            const i = e / 2
              , o = t / 2
              , a = Math.floor(n)
              , s = Math.floor(r)
              , c = a + 1
              , l = s + 1
              , u = e / a
              , h = t / s
              , d = []
              , p = []
              , f = []
              , m = [];
            for (let e = 0; e < l; e++) {
                const t = e * h - o;
                for (let n = 0; n < c; n++) {
                    const r = n * u - i;
                    p.push(r, -t, 0),
                    f.push(0, 0, 1),
                    m.push(n / a),
                    m.push(1 - e / s)
                }
            }
            for (let e = 0; e < s; e++)
                for (let t = 0; t < a; t++) {
                    const n = t + c * e
                      , r = t + c * (e + 1)
                      , i = t + 1 + c * (e + 1)
                      , o = t + 1 + c * e;
                    d.push(n, r, o),
                    d.push(r, i, o)
                }
            this.setIndex(d),
            this.setAttribute("position", new Rt(p,3)),
            this.setAttribute("normal", new Rt(f,3)),
            this.setAttribute("uv", new Rt(m,2))
        }
    }
    const Tn = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
        lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
        clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
        clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmissionmap_fragment: "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif",
        transmissionmap_pars_fragment: "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif",
        uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
    }
      , Ln = {
        common: {
            diffuse: {
                value: new yt(15658734)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            uvTransform: {
                value: new z
            },
            uv2Transform: {
                value: new z
            },
            alphaMap: {
                value: null
            }
        },
        specularmap: {
            specularMap: {
                value: null
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            refractionRatio: {
                value: .98
            },
            maxMipLevel: {
                value: 0
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalScale: {
                value: new k(1,1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new yt(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {
                value: []
            },
            spotShadowMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new yt(15658734)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new z
            }
        },
        sprite: {
            diffuse: {
                value: new yt(15658734)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new k(.5,.5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            uvTransform: {
                value: new z
            }
        }
    }
      , An = {
        basic: {
            uniforms: un([Ln.common, Ln.specularmap, Ln.envmap, Ln.aomap, Ln.lightmap, Ln.fog]),
            vertexShader: Tn.meshbasic_vert,
            fragmentShader: Tn.meshbasic_frag
        },
        lambert: {
            uniforms: un([Ln.common, Ln.specularmap, Ln.envmap, Ln.aomap, Ln.lightmap, Ln.emissivemap, Ln.fog, Ln.lights, {
                emissive: {
                    value: new yt(0)
                }
            }]),
            vertexShader: Tn.meshlambert_vert,
            fragmentShader: Tn.meshlambert_frag
        },
        phong: {
            uniforms: un([Ln.common, Ln.specularmap, Ln.envmap, Ln.aomap, Ln.lightmap, Ln.emissivemap, Ln.bumpmap, Ln.normalmap, Ln.displacementmap, Ln.fog, Ln.lights, {
                emissive: {
                    value: new yt(0)
                },
                specular: {
                    value: new yt(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: Tn.meshphong_vert,
            fragmentShader: Tn.meshphong_frag
        },
        standard: {
            uniforms: un([Ln.common, Ln.envmap, Ln.aomap, Ln.lightmap, Ln.emissivemap, Ln.bumpmap, Ln.normalmap, Ln.displacementmap, Ln.roughnessmap, Ln.metalnessmap, Ln.fog, Ln.lights, {
                emissive: {
                    value: new yt(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: Tn.meshphysical_vert,
            fragmentShader: Tn.meshphysical_frag
        },
        toon: {
            uniforms: un([Ln.common, Ln.aomap, Ln.lightmap, Ln.emissivemap, Ln.bumpmap, Ln.normalmap, Ln.displacementmap, Ln.gradientmap, Ln.fog, Ln.lights, {
                emissive: {
                    value: new yt(0)
                }
            }]),
            vertexShader: Tn.meshtoon_vert,
            fragmentShader: Tn.meshtoon_frag
        },
        matcap: {
            uniforms: un([Ln.common, Ln.bumpmap, Ln.normalmap, Ln.displacementmap, Ln.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: Tn.meshmatcap_vert,
            fragmentShader: Tn.meshmatcap_frag
        },
        points: {
            uniforms: un([Ln.points, Ln.fog]),
            vertexShader: Tn.points_vert,
            fragmentShader: Tn.points_frag
        },
        dashed: {
            uniforms: un([Ln.common, Ln.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: Tn.linedashed_vert,
            fragmentShader: Tn.linedashed_frag
        },
        depth: {
            uniforms: un([Ln.common, Ln.displacementmap]),
            vertexShader: Tn.depth_vert,
            fragmentShader: Tn.depth_frag
        },
        normal: {
            uniforms: un([Ln.common, Ln.bumpmap, Ln.normalmap, Ln.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Tn.normal_vert,
            fragmentShader: Tn.normal_frag
        },
        sprite: {
            uniforms: un([Ln.sprite, Ln.fog]),
            vertexShader: Tn.sprite_vert,
            fragmentShader: Tn.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new z
                },
                t2D: {
                    value: null
                }
            },
            vertexShader: Tn.background_vert,
            fragmentShader: Tn.background_frag
        },
        cube: {
            uniforms: un([Ln.envmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Tn.cube_vert,
            fragmentShader: Tn.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Tn.equirect_vert,
            fragmentShader: Tn.equirect_frag
        },
        distanceRGBA: {
            uniforms: un([Ln.common, Ln.displacementmap, {
                referencePosition: {
                    value: new q
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: Tn.distanceRGBA_vert,
            fragmentShader: Tn.distanceRGBA_frag
        },
        shadow: {
            uniforms: un([Ln.lights, Ln.fog, {
                color: {
                    value: new yt(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Tn.shadow_vert,
            fragmentShader: Tn.shadow_frag
        }
    };
    function Pn(e, t, n, r, i) {
        const o = new yt(0);
        let a, s, c = 0, l = null, u = 0, h = null;
        function d(e, t) {
            n.buffers.color.setClear(e.r, e.g, e.b, t, i)
        }
        return {
            getClearColor: function() {
                return o
            },
            setClearColor: function(e, t=1) {
                o.set(e),
                c = t,
                d(o, c)
            },
            getClearAlpha: function() {
                return c
            },
            setClearAlpha: function(e) {
                c = e,
                d(o, c)
            },
            render: function(n, i, p, f) {
                let m = !0 === i.isScene ? i.background : null;
                m && m.isTexture && (m = t.get(m));
                const g = e.xr
                  , v = g.getSession && g.getSession();
                v && "additive" === v.environmentBlendMode && (m = null),
                null === m ? d(o, c) : m && m.isColor && (d(m, 1),
                f = !0),
                (e.autoClear || f) && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
                m && (m.isCubeTexture || 306 === m.mapping) ? (void 0 === s && (s = new an(new cn(1,1,1),new dn({
                    name: "BackgroundCubeMaterial",
                    uniforms: ln(An.cube.uniforms),
                    vertexShader: An.cube.vertexShader,
                    fragmentShader: An.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                s.geometry.deleteAttribute("normal"),
                s.geometry.deleteAttribute("uv"),
                s.onBeforeRender = function(e, t, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld)
                }
                ,
                Object.defineProperty(s.material, "envMap", {
                    get: function() {
                        return this.uniforms.envMap.value
                    }
                }),
                r.update(s)),
                s.material.uniforms.envMap.value = m,
                s.material.uniforms.flipEnvMap.value = m.isCubeTexture && m._needsFlipEnvMap ? -1 : 1,
                l === m && u === m.version && h === e.toneMapping || (s.material.needsUpdate = !0,
                l = m,
                u = m.version,
                h = e.toneMapping),
                n.unshift(s, s.geometry, s.material, 0, 0, null)) : m && m.isTexture && (void 0 === a && (a = new an(new Sn(2,2),new dn({
                    name: "BackgroundMaterial",
                    uniforms: ln(An.background.uniforms),
                    vertexShader: An.background.vertexShader,
                    fragmentShader: An.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })),
                a.geometry.deleteAttribute("normal"),
                Object.defineProperty(a.material, "map", {
                    get: function() {
                        return this.uniforms.t2D.value
                    }
                }),
                r.update(a)),
                a.material.uniforms.t2D.value = m,
                !0 === m.matrixAutoUpdate && m.updateMatrix(),
                a.material.uniforms.uvTransform.value.copy(m.matrix),
                l === m && u === m.version && h === e.toneMapping || (a.material.needsUpdate = !0,
                l = m,
                u = m.version,
                h = e.toneMapping),
                n.unshift(a, a.geometry, a.material, 0, 0, null))
            }
        }
    }
    function Cn(e, t, n, r) {
        const i = e.getParameter(34921)
          , o = r.isWebGL2 ? null : t.get("OES_vertex_array_object")
          , a = r.isWebGL2 || null !== o
          , s = {}
          , c = d(null);
        let l = c;
        function u(t) {
            return r.isWebGL2 ? e.bindVertexArray(t) : o.bindVertexArrayOES(t)
        }
        function h(t) {
            return r.isWebGL2 ? e.deleteVertexArray(t) : o.deleteVertexArrayOES(t)
        }
        function d(e) {
            const t = []
              , n = []
              , r = [];
            for (let e = 0; e < i; e++)
                t[e] = 0,
                n[e] = 0,
                r[e] = 0;
            return {
                geometry: null,
                program: null,
                wireframe: !1,
                newAttributes: t,
                enabledAttributes: n,
                attributeDivisors: r,
                object: e,
                attributes: {},
                index: null
            }
        }
        function p() {
            const e = l.newAttributes;
            for (let t = 0, n = e.length; t < n; t++)
                e[t] = 0
        }
        function f(e) {
            m(e, 0)
        }
        function m(n, i) {
            const o = l.newAttributes
              , a = l.enabledAttributes
              , s = l.attributeDivisors;
            if (o[n] = 1,
            0 === a[n] && (e.enableVertexAttribArray(n),
            a[n] = 1),
            s[n] !== i) {
                (r.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i),
                s[n] = i
            }
        }
        function g() {
            const t = l.newAttributes
              , n = l.enabledAttributes;
            for (let r = 0, i = n.length; r < i; r++)
                n[r] !== t[r] && (e.disableVertexAttribArray(r),
                n[r] = 0)
        }
        function v(t, n, i, o, a, s) {
            !0 !== r.isWebGL2 || 5124 !== i && 5125 !== i ? e.vertexAttribPointer(t, n, i, o, a, s) : e.vertexAttribIPointer(t, n, i, a, s)
        }
        function y() {
            b(),
            l !== c && (l = c,
            u(l.object))
        }
        function b() {
            c.geometry = null,
            c.program = null,
            c.wireframe = !1
        }
        return {
            setup: function(i, c, h, y, b) {
                let x = !1;
                if (a) {
                    const t = function(t, n, i) {
                        const a = !0 === i.wireframe;
                        let c = s[t.id];
                        void 0 === c && (c = {},
                        s[t.id] = c);
                        let l = c[n.id];
                        void 0 === l && (l = {},
                        c[n.id] = l);
                        let u = l[a];
                        void 0 === u && (u = d(r.isWebGL2 ? e.createVertexArray() : o.createVertexArrayOES()),
                        l[a] = u);
                        return u
                    }(y, h, c);
                    l !== t && (l = t,
                    u(l.object)),
                    x = function(e, t) {
                        const n = l.attributes
                          , r = e.attributes;
                        let i = 0;
                        for (const e in r) {
                            const t = n[e]
                              , o = r[e];
                            if (void 0 === t)
                                return !0;
                            if (t.attribute !== o)
                                return !0;
                            if (t.data !== o.data)
                                return !0;
                            i++
                        }
                        return l.attributesNum !== i || l.index !== t
                    }(y, b),
                    x && function(e, t) {
                        const n = {}
                          , r = e.attributes;
                        let i = 0;
                        for (const e in r) {
                            const t = r[e]
                              , o = {};
                            o.attribute = t,
                            t.data && (o.data = t.data),
                            n[e] = o,
                            i++
                        }
                        l.attributes = n,
                        l.attributesNum = i,
                        l.index = t
                    }(y, b)
                } else {
                    const e = !0 === c.wireframe;
                    l.geometry === y.id && l.program === h.id && l.wireframe === e || (l.geometry = y.id,
                    l.program = h.id,
                    l.wireframe = e,
                    x = !0)
                }
                !0 === i.isInstancedMesh && (x = !0),
                null !== b && n.update(b, 34963),
                x && (!function(i, o, a, s) {
                    if (!1 === r.isWebGL2 && (i.isInstancedMesh || s.isInstancedBufferGeometry) && null === t.get("ANGLE_instanced_arrays"))
                        return;
                    p();
                    const c = s.attributes
                      , l = a.getAttributes()
                      , u = o.defaultAttributeValues;
                    for (const t in l) {
                        const r = l[t];
                        if (r >= 0) {
                            const o = c[t];
                            if (void 0 !== o) {
                                const t = o.normalized
                                  , i = o.itemSize
                                  , a = n.get(o);
                                if (void 0 === a)
                                    continue;
                                const c = a.buffer
                                  , l = a.type
                                  , u = a.bytesPerElement;
                                if (o.isInterleavedBufferAttribute) {
                                    const n = o.data
                                      , a = n.stride
                                      , h = o.offset;
                                    n && n.isInstancedInterleavedBuffer ? (m(r, n.meshPerAttribute),
                                    void 0 === s._maxInstanceCount && (s._maxInstanceCount = n.meshPerAttribute * n.count)) : f(r),
                                    e.bindBuffer(34962, c),
                                    v(r, i, l, t, a * u, h * u)
                                } else
                                    o.isInstancedBufferAttribute ? (m(r, o.meshPerAttribute),
                                    void 0 === s._maxInstanceCount && (s._maxInstanceCount = o.meshPerAttribute * o.count)) : f(r),
                                    e.bindBuffer(34962, c),
                                    v(r, i, l, t, 0, 0)
                            } else if ("instanceMatrix" === t) {
                                const t = n.get(i.instanceMatrix);
                                if (void 0 === t)
                                    continue;
                                const o = t.buffer
                                  , a = t.type;
                                m(r + 0, 1),
                                m(r + 1, 1),
                                m(r + 2, 1),
                                m(r + 3, 1),
                                e.bindBuffer(34962, o),
                                e.vertexAttribPointer(r + 0, 4, a, !1, 64, 0),
                                e.vertexAttribPointer(r + 1, 4, a, !1, 64, 16),
                                e.vertexAttribPointer(r + 2, 4, a, !1, 64, 32),
                                e.vertexAttribPointer(r + 3, 4, a, !1, 64, 48)
                            } else if ("instanceColor" === t) {
                                const t = n.get(i.instanceColor);
                                if (void 0 === t)
                                    continue;
                                const o = t.buffer
                                  , a = t.type;
                                m(r, 1),
                                e.bindBuffer(34962, o),
                                e.vertexAttribPointer(r, 3, a, !1, 12, 0)
                            } else if (void 0 !== u) {
                                const n = u[t];
                                if (void 0 !== n)
                                    switch (n.length) {
                                    case 2:
                                        e.vertexAttrib2fv(r, n);
                                        break;
                                    case 3:
                                        e.vertexAttrib3fv(r, n);
                                        break;
                                    case 4:
                                        e.vertexAttrib4fv(r, n);
                                        break;
                                    default:
                                        e.vertexAttrib1fv(r, n)
                                    }
                            }
                        }
                    }
                    g()
                }(i, c, h, y),
                null !== b && e.bindBuffer(34963, n.get(b).buffer))
            },
            reset: y,
            resetDefaultState: b,
            dispose: function() {
                y();
                for (const e in s) {
                    const t = s[e];
                    for (const e in t) {
                        const n = t[e];
                        for (const e in n)
                            h(n[e].object),
                            delete n[e];
                        delete t[e]
                    }
                    delete s[e]
                }
            },
            releaseStatesOfGeometry: function(e) {
                if (void 0 === s[e.id])
                    return;
                const t = s[e.id];
                for (const e in t) {
                    const n = t[e];
                    for (const e in n)
                        h(n[e].object),
                        delete n[e];
                    delete t[e]
                }
                delete s[e.id]
            },
            releaseStatesOfProgram: function(e) {
                for (const t in s) {
                    const n = s[t];
                    if (void 0 === n[e.id])
                        continue;
                    const r = n[e.id];
                    for (const e in r)
                        h(r[e].object),
                        delete r[e];
                    delete n[e.id]
                }
            },
            initAttributes: p,
            enableAttribute: f,
            disableUnusedAttributes: g
        }
    }
    function Rn(e, t, n, r) {
        const i = r.isWebGL2;
        let o;
        this.setMode = function(e) {
            o = e
        }
        ,
        this.render = function(t, r) {
            e.drawArrays(o, t, r),
            n.update(r, o, 1)
        }
        ,
        this.renderInstances = function(r, a, s) {
            if (0 === s)
                return;
            let c, l;
            if (i)
                c = e,
                l = "drawArraysInstanced";
            else if (c = t.get("ANGLE_instanced_arrays"),
            l = "drawArraysInstancedANGLE",
            null === c)
                return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            c[l](o, r, a, s),
            n.update(a, o, s)
        }
    }
    function Dn(e, t, n) {
        let r;
        function i(t) {
            if ("highp" === t) {
                if (e.getShaderPrecisionFormat(35633, 36338).precision > 0 && e.getShaderPrecisionFormat(35632, 36338).precision > 0)
                    return "highp";
                t = "mediump"
            }
            return "mediump" === t && e.getShaderPrecisionFormat(35633, 36337).precision > 0 && e.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
        }
        const o = "undefined" != typeof WebGL2RenderingContext && e instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && e instanceof WebGL2ComputeRenderingContext;
        let a = void 0 !== n.precision ? n.precision : "highp";
        const s = i(a);
        s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."),
        a = s);
        const c = !0 === n.logarithmicDepthBuffer
          , l = e.getParameter(34930)
          , u = e.getParameter(35660)
          , h = e.getParameter(3379)
          , d = e.getParameter(34076)
          , p = e.getParameter(34921)
          , f = e.getParameter(36347)
          , m = e.getParameter(36348)
          , g = e.getParameter(36349)
          , v = u > 0
          , y = o || t.has("OES_texture_float");
        return {
            isWebGL2: o,
            getMaxAnisotropy: function() {
                if (void 0 !== r)
                    return r;
                if (!0 === t.has("EXT_texture_filter_anisotropic")) {
                    const n = t.get("EXT_texture_filter_anisotropic");
                    r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                } else
                    r = 0;
                return r
            },
            getMaxPrecision: i,
            precision: a,
            logarithmicDepthBuffer: c,
            maxTextures: l,
            maxVertexTextures: u,
            maxTextureSize: h,
            maxCubemapSize: d,
            maxAttributes: p,
            maxVertexUniforms: f,
            maxVaryings: m,
            maxFragmentUniforms: g,
            vertexTextures: v,
            floatFragmentTextures: y,
            floatVertexTextures: v && y,
            maxSamples: o ? e.getParameter(36183) : 0
        }
    }
    function On(e) {
        const t = this;
        let n = null
          , r = 0
          , i = !1
          , o = !1;
        const a = new Qe
          , s = new z
          , c = {
            value: null,
            needsUpdate: !1
        };
        function l() {
            c.value !== n && (c.value = n,
            c.needsUpdate = r > 0),
            t.numPlanes = r,
            t.numIntersection = 0
        }
        function u(e, n, r, i) {
            const o = null !== e ? e.length : 0;
            let l = null;
            if (0 !== o) {
                if (l = c.value,
                !0 !== i || null === l) {
                    const t = r + 4 * o
                      , i = n.matrixWorldInverse;
                    s.getNormalMatrix(i),
                    (null === l || l.length < t) && (l = new Float32Array(t));
                    for (let t = 0, n = r; t !== o; ++t,
                    n += 4)
                        a.copy(e[t]).applyMatrix4(i, s),
                        a.normal.toArray(l, n),
                        l[n + 3] = a.constant
                }
                c.value = l,
                c.needsUpdate = !0
            }
            return t.numPlanes = o,
            t.numIntersection = 0,
            l
        }
        this.uniform = c,
        this.numPlanes = 0,
        this.numIntersection = 0,
        this.init = function(e, t, o) {
            const a = 0 !== e.length || t || 0 !== r || i;
            return i = t,
            n = u(e, o, 0),
            r = e.length,
            a
        }
        ,
        this.beginShadows = function() {
            o = !0,
            u(null)
        }
        ,
        this.endShadows = function() {
            o = !1,
            l()
        }
        ,
        this.setState = function(t, a, s) {
            const h = t.clippingPlanes
              , d = t.clipIntersection
              , p = t.clipShadows
              , f = e.get(t);
            if (!i || null === h || 0 === h.length || o && !p)
                o ? u(null) : l();
            else {
                const e = o ? 0 : r
                  , t = 4 * e;
                let i = f.clippingState || null;
                c.value = i,
                i = u(h, a, t, s);
                for (let e = 0; e !== t; ++e)
                    i[e] = n[e];
                f.clippingState = i,
                this.numIntersection = d ? this.numPlanes : 0,
                this.numPlanes += e
            }
        }
    }
    function Nn(e) {
        let t = new WeakMap;
        function n(e, t) {
            return 303 === t ? e.mapping = 301 : 304 === t && (e.mapping = 302),
            e
        }
        function r(e) {
            const n = e.target;
            n.removeEventListener("dispose", r);
            const i = t.get(n);
            void 0 !== i && (t.delete(n),
            i.dispose())
        }
        return {
            get: function(i) {
                if (i && i.isTexture) {
                    const o = i.mapping;
                    if (303 === o || 304 === o) {
                        if (t.has(i)) {
                            return n(t.get(i).texture, i.mapping)
                        }
                        {
                            const o = i.image;
                            if (o && o.height > 0) {
                                const a = e.getRenderTarget()
                                  , s = new yn(o.height / 2);
                                return s.fromEquirectangularTexture(e, i),
                                t.set(i, s),
                                e.setRenderTarget(a),
                                i.addEventListener("dispose", r),
                                n(s.texture, i.mapping)
                            }
                            return null
                        }
                    }
                }
                return i
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }
    function In(e) {
        const t = {};
        function n(n) {
            if (void 0 !== t[n])
                return t[n];
            let r;
            switch (n) {
            case "WEBGL_depth_texture":
                r = e.getExtension("WEBGL_depth_texture") || e.getExtension("MOZ_WEBGL_depth_texture") || e.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                r = e.getExtension(n)
            }
            return t[n] = r,
            r
        }
        return {
            has: function(e) {
                return null !== n(e)
            },
            init: function(e) {
                e.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"),
                n("OES_texture_float"),
                n("OES_texture_half_float"),
                n("OES_texture_half_float_linear"),
                n("OES_standard_derivatives"),
                n("OES_element_index_uint"),
                n("OES_vertex_array_object"),
                n("ANGLE_instanced_arrays")),
                n("OES_texture_float_linear"),
                n("EXT_color_buffer_half_float")
            },
            get: function(e) {
                const t = n(e);
                return null === t && console.warn("THREE.WebGLRenderer: " + e + " extension not supported."),
                t
            }
        }
    }
    function kn(e, t, n, r) {
        const i = {}
          , o = new WeakMap;
        function a(e) {
            const s = e.target;
            null !== s.index && t.remove(s.index);
            for (const e in s.attributes)
                t.remove(s.attributes[e]);
            s.removeEventListener("dispose", a),
            delete i[s.id];
            const c = o.get(s);
            c && (t.remove(c),
            o.delete(s)),
            r.releaseStatesOfGeometry(s),
            !0 === s.isInstancedBufferGeometry && delete s._maxInstanceCount,
            n.memory.geometries--
        }
        function s(e) {
            const n = []
              , r = e.index
              , i = e.attributes.position;
            let a = 0;
            if (null !== r) {
                const e = r.array;
                a = r.version;
                for (let t = 0, r = e.length; t < r; t += 3) {
                    const r = e[t + 0]
                      , i = e[t + 1]
                      , o = e[t + 2];
                    n.push(r, i, i, o, o, r)
                }
            } else {
                const e = i.array;
                a = i.version;
                for (let t = 0, r = e.length / 3 - 1; t < r; t += 3) {
                    const e = t + 0
                      , r = t + 1
                      , i = t + 2;
                    n.push(e, r, r, i, i, e)
                }
            }
            const s = new (Ot(n) > 65535 ? Pt : Lt)(n,1);
            s.version = a;
            const c = o.get(e);
            c && t.remove(c),
            o.set(e, s)
        }
        return {
            get: function(e, t) {
                return !0 === i[t.id] || (t.addEventListener("dispose", a),
                i[t.id] = !0,
                n.memory.geometries++),
                t
            },
            update: function(e) {
                const n = e.attributes;
                for (const e in n)
                    t.update(n[e], 34962);
                const r = e.morphAttributes;
                for (const e in r) {
                    const n = r[e];
                    for (let e = 0, r = n.length; e < r; e++)
                        t.update(n[e], 34962)
                }
            },
            getWireframeAttribute: function(e) {
                const t = o.get(e);
                if (t) {
                    const n = e.index;
                    null !== n && t.version < n.version && s(e)
                } else
                    s(e);
                return o.get(e)
            }
        }
    }
    function zn(e, t, n, r) {
        const i = r.isWebGL2;
        let o, a, s;
        this.setMode = function(e) {
            o = e
        }
        ,
        this.setIndex = function(e) {
            a = e.type,
            s = e.bytesPerElement
        }
        ,
        this.render = function(t, r) {
            e.drawElements(o, r, a, t * s),
            n.update(r, o, 1)
        }
        ,
        this.renderInstances = function(r, c, l) {
            if (0 === l)
                return;
            let u, h;
            if (i)
                u = e,
                h = "drawElementsInstanced";
            else if (u = t.get("ANGLE_instanced_arrays"),
            h = "drawElementsInstancedANGLE",
            null === u)
                return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            u[h](o, c, a, r * s, l),
            n.update(c, o, l)
        }
    }
    function Fn(e) {
        const t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };
        return {
            memory: {
                geometries: 0,
                textures: 0
            },
            render: t,
            programs: null,
            autoReset: !0,
            reset: function() {
                t.frame++,
                t.calls = 0,
                t.triangles = 0,
                t.points = 0,
                t.lines = 0
            },
            update: function(e, n, r) {
                switch (t.calls++,
                n) {
                case 4:
                    t.triangles += r * (e / 3);
                    break;
                case 1:
                    t.lines += r * (e / 2);
                    break;
                case 3:
                    t.lines += r * (e - 1);
                    break;
                case 2:
                    t.lines += r * e;
                    break;
                case 0:
                    t.points += r * e;
                    break;
                default:
                    console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                }
            }
        }
    }
    function Bn(e, t) {
        return e[0] - t[0]
    }
    function Un(e, t) {
        return Math.abs(t[1]) - Math.abs(e[1])
    }
    function Hn(e) {
        const t = {}
          , n = new Float32Array(8)
          , r = [];
        for (let e = 0; e < 8; e++)
            r[e] = [e, 0];
        return {
            update: function(i, o, a, s) {
                const c = i.morphTargetInfluences
                  , l = void 0 === c ? 0 : c.length;
                let u = t[o.id];
                if (void 0 === u) {
                    u = [];
                    for (let e = 0; e < l; e++)
                        u[e] = [e, 0];
                    t[o.id] = u
                }
                for (let e = 0; e < l; e++) {
                    const t = u[e];
                    t[0] = e,
                    t[1] = c[e]
                }
                u.sort(Un);
                for (let e = 0; e < 8; e++)
                    e < l && u[e][1] ? (r[e][0] = u[e][0],
                    r[e][1] = u[e][1]) : (r[e][0] = Number.MAX_SAFE_INTEGER,
                    r[e][1] = 0);
                r.sort(Bn);
                const h = a.morphTargets && o.morphAttributes.position
                  , d = a.morphNormals && o.morphAttributes.normal;
                let p = 0;
                for (let e = 0; e < 8; e++) {
                    const t = r[e]
                      , i = t[0]
                      , a = t[1];
                    i !== Number.MAX_SAFE_INTEGER && a ? (h && o.getAttribute("morphTarget" + e) !== h[i] && o.setAttribute("morphTarget" + e, h[i]),
                    d && o.getAttribute("morphNormal" + e) !== d[i] && o.setAttribute("morphNormal" + e, d[i]),
                    n[e] = a,
                    p += a) : (h && !0 === o.hasAttribute("morphTarget" + e) && o.deleteAttribute("morphTarget" + e),
                    d && !0 === o.hasAttribute("morphNormal" + e) && o.deleteAttribute("morphNormal" + e),
                    n[e] = 0)
                }
                const f = o.morphTargetsRelative ? 1 : 1 - p;
                s.getUniforms().setValue(e, "morphTargetBaseInfluence", f),
                s.getUniforms().setValue(e, "morphTargetInfluences", n)
            }
        }
    }
    function jn(e, t, n, r) {
        let i = new WeakMap;
        function o(e) {
            const t = e.target;
            t.removeEventListener("dispose", o),
            n.remove(t.instanceMatrix),
            null !== t.instanceColor && n.remove(t.instanceColor)
        }
        return {
            update: function(e) {
                const a = r.render.frame
                  , s = e.geometry
                  , c = t.get(e, s);
                return i.get(c) !== a && (t.update(c),
                i.set(c, a)),
                e.isInstancedMesh && (!1 === e.hasEventListener("dispose", o) && e.addEventListener("dispose", o),
                n.update(e.instanceMatrix, 34962),
                null !== e.instanceColor && n.update(e.instanceColor, 34962)),
                c
            },
            dispose: function() {
                i = new WeakMap
            }
        }
    }
    An.physical = {
        uniforms: un([An.standard.uniforms, {
            clearcoat: {
                value: 0
            },
            clearcoatMap: {
                value: null
            },
            clearcoatRoughness: {
                value: 0
            },
            clearcoatRoughnessMap: {
                value: null
            },
            clearcoatNormalScale: {
                value: new k(1,1)
            },
            clearcoatNormalMap: {
                value: null
            },
            sheen: {
                value: new yt(0)
            },
            transmission: {
                value: 0
            },
            transmissionMap: {
                value: null
            }
        }]),
        vertexShader: Tn.meshphysical_vert,
        fragmentShader: Tn.meshphysical_frag
    };
    class Gn extends H {
        constructor(e=null, t=1, n=1, r=1) {
            super(null),
            this.image = {
                data: e,
                width: t,
                height: n,
                depth: r
            },
            this.magFilter = f,
            this.minFilter = f,
            this.wrapR = d,
            this.generateMipmaps = !1,
            this.flipY = !1,
            this.needsUpdate = !0
        }
    }
    Gn.prototype.isDataTexture2DArray = !0;
    class Vn extends H {
        constructor(e=null, t=1, n=1, r=1) {
            super(null),
            this.image = {
                data: e,
                width: t,
                height: n,
                depth: r
            },
            this.magFilter = f,
            this.minFilter = f,
            this.wrapR = d,
            this.generateMipmaps = !1,
            this.flipY = !1,
            this.needsUpdate = !0
        }
    }
    Vn.prototype.isDataTexture3D = !0;
    const Wn = new H
      , qn = new Gn
      , Xn = new Vn
      , Yn = new vn
      , Zn = []
      , $n = []
      , Jn = new Float32Array(16)
      , Qn = new Float32Array(9)
      , Kn = new Float32Array(4);
    function er(e, t, n) {
        const r = e[0];
        if (r <= 0 || r > 0)
            return e;
        const i = t * n;
        let o = Zn[i];
        if (void 0 === o && (o = new Float32Array(i),
        Zn[i] = o),
        0 !== t) {
            r.toArray(o, 0);
            for (let r = 1, i = 0; r !== t; ++r)
                i += n,
                e[r].toArray(o, i)
        }
        return o
    }
    function tr(e, t) {
        if (e.length !== t.length)
            return !1;
        for (let n = 0, r = e.length; n < r; n++)
            if (e[n] !== t[n])
                return !1;
        return !0
    }
    function nr(e, t) {
        for (let n = 0, r = t.length; n < r; n++)
            e[n] = t[n]
    }
    function rr(e, t) {
        let n = $n[t];
        void 0 === n && (n = new Int32Array(t),
        $n[t] = n);
        for (let r = 0; r !== t; ++r)
            n[r] = e.allocateTextureUnit();
        return n
    }
    function ir(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t),
        n[0] = t)
    }
    function or(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
            n[0] === t.x && n[1] === t.y || (e.uniform2f(this.addr, t.x, t.y),
            n[0] = t.x,
            n[1] = t.y);
        else {
            if (tr(n, t))
                return;
            e.uniform2fv(this.addr, t),
            nr(n, t)
        }
    }
    function ar(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
            n[0] === t.x && n[1] === t.y && n[2] === t.z || (e.uniform3f(this.addr, t.x, t.y, t.z),
            n[0] = t.x,
            n[1] = t.y,
            n[2] = t.z);
        else if (void 0 !== t.r)
            n[0] === t.r && n[1] === t.g && n[2] === t.b || (e.uniform3f(this.addr, t.r, t.g, t.b),
            n[0] = t.r,
            n[1] = t.g,
            n[2] = t.b);
        else {
            if (tr(n, t))
                return;
            e.uniform3fv(this.addr, t),
            nr(n, t)
        }
    }
    function sr(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
            n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w || (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
            n[0] = t.x,
            n[1] = t.y,
            n[2] = t.z,
            n[3] = t.w);
        else {
            if (tr(n, t))
                return;
            e.uniform4fv(this.addr, t),
            nr(n, t)
        }
    }
    function cr(e, t) {
        const n = this.cache
          , r = t.elements;
        if (void 0 === r) {
            if (tr(n, t))
                return;
            e.uniformMatrix2fv(this.addr, !1, t),
            nr(n, t)
        } else {
            if (tr(n, r))
                return;
            Kn.set(r),
            e.uniformMatrix2fv(this.addr, !1, Kn),
            nr(n, r)
        }
    }
    function lr(e, t) {
        const n = this.cache
          , r = t.elements;
        if (void 0 === r) {
            if (tr(n, t))
                return;
            e.uniformMatrix3fv(this.addr, !1, t),
            nr(n, t)
        } else {
            if (tr(n, r))
                return;
            Qn.set(r),
            e.uniformMatrix3fv(this.addr, !1, Qn),
            nr(n, r)
        }
    }
    function ur(e, t) {
        const n = this.cache
          , r = t.elements;
        if (void 0 === r) {
            if (tr(n, t))
                return;
            e.uniformMatrix4fv(this.addr, !1, t),
            nr(n, t)
        } else {
            if (tr(n, r))
                return;
            Jn.set(r),
            e.uniformMatrix4fv(this.addr, !1, Jn),
            nr(n, r)
        }
    }
    function hr(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t),
        n[0] = t)
    }
    function dr(e, t) {
        const n = this.cache;
        tr(n, t) || (e.uniform2iv(this.addr, t),
        nr(n, t))
    }
    function pr(e, t) {
        const n = this.cache;
        tr(n, t) || (e.uniform3iv(this.addr, t),
        nr(n, t))
    }
    function fr(e, t) {
        const n = this.cache;
        tr(n, t) || (e.uniform4iv(this.addr, t),
        nr(n, t))
    }
    function mr(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t),
        n[0] = t)
    }
    function gr(e, t) {
        const n = this.cache;
        tr(n, t) || (e.uniform2uiv(this.addr, t),
        nr(n, t))
    }
    function vr(e, t) {
        const n = this.cache;
        tr(n, t) || (e.uniform3uiv(this.addr, t),
        nr(n, t))
    }
    function yr(e, t) {
        const n = this.cache;
        tr(n, t) || (e.uniform4uiv(this.addr, t),
        nr(n, t))
    }
    function br(e, t, n) {
        const r = this.cache
          , i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i),
        r[0] = i),
        n.safeSetTexture2D(t || Wn, i)
    }
    function xr(e, t, n) {
        const r = this.cache
          , i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i),
        r[0] = i),
        n.setTexture3D(t || Xn, i)
    }
    function _r(e, t, n) {
        const r = this.cache
          , i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i),
        r[0] = i),
        n.safeSetTextureCube(t || Yn, i)
    }
    function wr(e, t, n) {
        const r = this.cache
          , i = n.allocateTextureUnit();
        r[0] !== i && (e.uniform1i(this.addr, i),
        r[0] = i),
        n.setTexture2DArray(t || qn, i)
    }
    function Mr(e, t) {
        e.uniform1fv(this.addr, t)
    }
    function Er(e, t) {
        const n = er(t, this.size, 2);
        e.uniform2fv(this.addr, n)
    }
    function Sr(e, t) {
        const n = er(t, this.size, 3);
        e.uniform3fv(this.addr, n)
    }
    function Tr(e, t) {
        const n = er(t, this.size, 4);
        e.uniform4fv(this.addr, n)
    }
    function Lr(e, t) {
        const n = er(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, n)
    }
    function Ar(e, t) {
        const n = er(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, n)
    }
    function Pr(e, t) {
        const n = er(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, n)
    }
    function Cr(e, t) {
        e.uniform1iv(this.addr, t)
    }
    function Rr(e, t) {
        e.uniform2iv(this.addr, t)
    }
    function Dr(e, t) {
        e.uniform3iv(this.addr, t)
    }
    function Or(e, t) {
        e.uniform4iv(this.addr, t)
    }
    function Nr(e, t) {
        e.uniform1uiv(this.addr, t)
    }
    function Ir(e, t) {
        e.uniform2uiv(this.addr, t)
    }
    function kr(e, t) {
        e.uniform3uiv(this.addr, t)
    }
    function zr(e, t) {
        e.uniform4uiv(this.addr, t)
    }
    function Fr(e, t, n) {
        const r = t.length
          , i = rr(n, r);
        e.uniform1iv(this.addr, i);
        for (let e = 0; e !== r; ++e)
            n.safeSetTexture2D(t[e] || Wn, i[e])
    }
    function Br(e, t, n) {
        const r = t.length
          , i = rr(n, r);
        e.uniform1iv(this.addr, i);
        for (let e = 0; e !== r; ++e)
            n.safeSetTextureCube(t[e] || Yn, i[e])
    }
    function Ur(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return ir;
            case 35664:
                return or;
            case 35665:
                return ar;
            case 35666:
                return sr;
            case 35674:
                return cr;
            case 35675:
                return lr;
            case 35676:
                return ur;
            case 5124:
            case 35670:
                return hr;
            case 35667:
            case 35671:
                return dr;
            case 35668:
            case 35672:
                return pr;
            case 35669:
            case 35673:
                return fr;
            case 5125:
                return mr;
            case 36294:
                return gr;
            case 36295:
                return vr;
            case 36296:
                return yr;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return br;
            case 35679:
            case 36299:
            case 36307:
                return xr;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return _r;
            case 36289:
            case 36303:
            case 36311:
            case 36292:
                return wr
            }
        }(t.type)
    }
    function Hr(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.size = t.size,
        this.setValue = function(e) {
            switch (e) {
            case 5126:
                return Mr;
            case 35664:
                return Er;
            case 35665:
                return Sr;
            case 35666:
                return Tr;
            case 35674:
                return Lr;
            case 35675:
                return Ar;
            case 35676:
                return Pr;
            case 5124:
            case 35670:
                return Cr;
            case 35667:
            case 35671:
                return Rr;
            case 35668:
            case 35672:
                return Dr;
            case 35669:
            case 35673:
                return Or;
            case 5125:
                return Nr;
            case 36294:
                return Ir;
            case 36295:
                return kr;
            case 36296:
                return zr;
            case 35678:
            case 36198:
            case 36298:
            case 36306:
            case 35682:
                return Fr;
            case 35680:
            case 36300:
            case 36308:
            case 36293:
                return Br
            }
        }(t.type)
    }
    function jr(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    Hr.prototype.updateCache = function(e) {
        const t = this.cache;
        e instanceof Float32Array && t.length !== e.length && (this.cache = new Float32Array(e.length)),
        nr(t, e)
    }
    ,
    jr.prototype.setValue = function(e, t, n) {
        const r = this.seq;
        for (let i = 0, o = r.length; i !== o; ++i) {
            const o = r[i];
            o.setValue(e, t[o.id], n)
        }
    }
    ;
    const Gr = /(\w+)(\])?(\[|\.)?/g;
    function Vr(e, t) {
        e.seq.push(t),
        e.map[t.id] = t
    }
    function Wr(e, t, n) {
        const r = e.name
          , i = r.length;
        for (Gr.lastIndex = 0; ; ) {
            const o = Gr.exec(r)
              , a = Gr.lastIndex;
            let s = o[1];
            const c = "]" === o[2]
              , l = o[3];
            if (c && (s |= 0),
            void 0 === l || "[" === l && a + 2 === i) {
                Vr(n, void 0 === l ? new Ur(s,e,t) : new Hr(s,e,t));
                break
            }
            {
                let e = n.map[s];
                void 0 === e && (e = new jr(s),
                Vr(n, e)),
                n = e
            }
        }
    }
    function qr(e, t) {
        this.seq = [],
        this.map = {};
        const n = e.getProgramParameter(t, 35718);
        for (let r = 0; r < n; ++r) {
            const n = e.getActiveUniform(t, r);
            Wr(n, e.getUniformLocation(t, n.name), this)
        }
    }
    function Xr(e, t, n) {
        const r = e.createShader(t);
        return e.shaderSource(r, n),
        e.compileShader(r),
        r
    }
    qr.prototype.setValue = function(e, t, n, r) {
        const i = this.map[t];
        void 0 !== i && i.setValue(e, n, r)
    }
    ,
    qr.prototype.setOptional = function(e, t, n) {
        const r = t[n];
        void 0 !== r && this.setValue(e, n, r)
    }
    ,
    qr.upload = function(e, t, n, r) {
        for (let i = 0, o = t.length; i !== o; ++i) {
            const o = t[i]
              , a = n[o.id];
            !1 !== a.needsUpdate && o.setValue(e, a.value, r)
        }
    }
    ,
    qr.seqWithValue = function(e, t) {
        const n = [];
        for (let r = 0, i = e.length; r !== i; ++r) {
            const i = e[r];
            i.id in t && n.push(i)
        }
        return n
    }
    ;
    let Yr = 0;
    function Zr(e) {
        switch (e) {
        case L:
            return ["Linear", "( value )"];
        case 3001:
            return ["sRGB", "( value )"];
        case 3002:
            return ["RGBE", "( value )"];
        case 3004:
            return ["RGBM", "( value, 7.0 )"];
        case 3005:
            return ["RGBM", "( value, 16.0 )"];
        case 3006:
            return ["RGBD", "( value, 256.0 )"];
        case 3007:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        case 3003:
            return ["LogLuv", "( value )"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported encoding:", e),
            ["Linear", "( value )"]
        }
    }
    function $r(e, t, n) {
        const r = e.getShaderParameter(t, 35713)
          , i = e.getShaderInfoLog(t).trim();
        if (r && "" === i)
            return "";
        return "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + function(e) {
            const t = e.split("\n");
            for (let e = 0; e < t.length; e++)
                t[e] = e + 1 + ": " + t[e];
            return t.join("\n")
        }(e.getShaderSource(t))
    }
    function Jr(e, t) {
        const n = Zr(t);
        return "vec4 " + e + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
    }
    function Qr(e, t) {
        const n = Zr(t);
        return "vec4 " + e + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
    }
    function Kr(e, t) {
        let n;
        switch (t) {
        case 1:
            n = "Linear";
            break;
        case 2:
            n = "Reinhard";
            break;
        case 3:
            n = "OptimizedCineon";
            break;
        case 4:
            n = "ACESFilmic";
            break;
        case 5:
            n = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
            n = "Linear"
        }
        return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }
    function ei(e) {
        return "" !== e
    }
    function ti(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows)
    }
    function ni(e, t) {
        return e.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection)
    }
    const ri = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function ii(e) {
        return e.replace(ri, oi)
    }
    function oi(e, t) {
        const n = Tn[t];
        if (void 0 === n)
            throw new Error("Can not resolve #include <" + t + ">");
        return ii(n)
    }
    const ai = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
      , si = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function ci(e) {
        return e.replace(si, ui).replace(ai, li)
    }
    function li(e, t, n, r) {
        return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),
        ui(e, t, n, r)
    }
    function ui(e, t, n, r) {
        let i = "";
        for (let e = parseInt(t); e < parseInt(n); e++)
            i += r.replace(/\[\s*i\s*\]/g, "[ " + e + " ]").replace(/UNROLLED_LOOP_INDEX/g, e);
        return i
    }
    function hi(e) {
        let t = "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
        return "highp" === e.precision ? t += "\n#define HIGH_PRECISION" : "mediump" === e.precision ? t += "\n#define MEDIUM_PRECISION" : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
        t
    }
    function di(e, t, n, r) {
        const i = e.getContext()
          , o = n.defines;
        let a = n.vertexShader
          , s = n.fragmentShader;
        const c = function(e) {
            let t = "SHADOWMAP_TYPE_BASIC";
            return 1 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF" : 2 === e.shadowMapType ? t = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === e.shadowMapType && (t = "SHADOWMAP_TYPE_VSM"),
            t
        }(n)
          , l = function(e) {
            let t = "ENVMAP_TYPE_CUBE";
            if (e.envMap)
                switch (e.envMapMode) {
                case 301:
                case 302:
                    t = "ENVMAP_TYPE_CUBE";
                    break;
                case 306:
                case 307:
                    t = "ENVMAP_TYPE_CUBE_UV"
                }
            return t
        }(n)
          , u = function(e) {
            let t = "ENVMAP_MODE_REFLECTION";
            if (e.envMap)
                switch (e.envMapMode) {
                case 302:
                case 307:
                    t = "ENVMAP_MODE_REFRACTION"
                }
            return t
        }(n)
          , h = function(e) {
            let t = "ENVMAP_BLENDING_NONE";
            if (e.envMap)
                switch (e.combine) {
                case 0:
                    t = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    t = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    t = "ENVMAP_BLENDING_ADD"
                }
            return t
        }(n)
          , d = e.gammaFactor > 0 ? e.gammaFactor : 1
          , p = n.isWebGL2 ? "" : function(e) {
            return [e.extensionDerivatives || e.envMapCubeUV || e.bumpMap || e.tangentSpaceNormalMap || e.clearcoatNormalMap || e.flatShading || "physical" === e.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (e.extensionFragDepth || e.logarithmicDepthBuffer) && e.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", e.extensionDrawBuffers && e.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (e.extensionShaderTextureLOD || e.envMap) && e.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(ei).join("\n")
        }(n)
          , f = function(e) {
            const t = [];
            for (const n in e) {
                const r = e[n];
                !1 !== r && t.push("#define " + n + " " + r)
            }
            return t.join("\n")
        }(o)
          , m = i.createProgram();
        let g, v, y = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial ? (g = [f].filter(ei).join("\n"),
        g.length > 0 && (g += "\n"),
        v = [p, f].filter(ei).join("\n"),
        v.length > 0 && (v += "\n")) : (g = [hi(n), "#define SHADER_NAME " + n.shaderName, f, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + d, "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + u : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(ei).join("\n"),
        v = [p, hi(n), "#define SHADER_NAME " + n.shaderName, f, n.alphaTest ? "#define ALPHATEST " + n.alphaTest + (n.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + d, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + l : "", n.envMap ? "#define " + u : "", n.envMap ? "#define " + h : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.sheen ? "#define USE_SHEEN" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + c : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? Tn.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? Kr("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", Tn.encodings_pars_fragment, n.map ? Jr("mapTexelToLinear", n.mapEncoding) : "", n.matcap ? Jr("matcapTexelToLinear", n.matcapEncoding) : "", n.envMap ? Jr("envMapTexelToLinear", n.envMapEncoding) : "", n.emissiveMap ? Jr("emissiveMapTexelToLinear", n.emissiveMapEncoding) : "", n.lightMap ? Jr("lightMapTexelToLinear", n.lightMapEncoding) : "", Qr("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(ei).join("\n")),
        a = ii(a),
        a = ti(a, n),
        a = ni(a, n),
        s = ii(s),
        s = ti(s, n),
        s = ni(s, n),
        a = ci(a),
        s = ci(s),
        n.isWebGL2 && !0 !== n.isRawShaderMaterial && (y = "#version 300 es\n",
        g = ["#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g,
        v = ["#define varying in", n.glslVersion === R ? "" : "out highp vec4 pc_fragColor;", n.glslVersion === R ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + v);
        const b = y + v + s
          , x = Xr(i, 35633, y + g + a)
          , _ = Xr(i, 35632, b);
        if (i.attachShader(m, x),
        i.attachShader(m, _),
        void 0 !== n.index0AttributeName ? i.bindAttribLocation(m, 0, n.index0AttributeName) : !0 === n.morphTargets && i.bindAttribLocation(m, 0, "position"),
        i.linkProgram(m),
        e.debug.checkShaderErrors) {
            const e = i.getProgramInfoLog(m).trim()
              , t = i.getShaderInfoLog(x).trim()
              , n = i.getShaderInfoLog(_).trim();
            let r = !0
              , o = !0;
            if (!1 === i.getProgramParameter(m, 35714)) {
                r = !1;
                const t = $r(i, x, "vertex")
                  , n = $r(i, _, "fragment");
                console.error("THREE.WebGLProgram: shader error: ", i.getError(), "35715", i.getProgramParameter(m, 35715), "gl.getProgramInfoLog", e, t, n)
            } else
                "" !== e ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", e) : "" !== t && "" !== n || (o = !1);
            o && (this.diagnostics = {
                runnable: r,
                programLog: e,
                vertexShader: {
                    log: t,
                    prefix: g
                },
                fragmentShader: {
                    log: n,
                    prefix: v
                }
            })
        }
        let w, M;
        return i.deleteShader(x),
        i.deleteShader(_),
        this.getUniforms = function() {
            return void 0 === w && (w = new qr(i,m)),
            w
        }
        ,
        this.getAttributes = function() {
            return void 0 === M && (M = function(e, t) {
                const n = {}
                  , r = e.getProgramParameter(t, 35721);
                for (let i = 0; i < r; i++) {
                    const r = e.getActiveAttrib(t, i).name;
                    n[r] = e.getAttribLocation(t, r)
                }
                return n
            }(i, m)),
            M
        }
        ,
        this.destroy = function() {
            r.releaseStatesOfProgram(this),
            i.deleteProgram(m),
            this.program = void 0
        }
        ,
        this.name = n.shaderName,
        this.id = Yr++,
        this.cacheKey = t,
        this.usedTimes = 1,
        this.program = m,
        this.vertexShader = x,
        this.fragmentShader = _,
        this
    }
    function pi(e, t, n, r, i, o) {
        const a = []
          , s = r.isWebGL2
          , c = r.logarithmicDepthBuffer
          , l = r.floatVertexTextures
          , u = r.maxVertexUniforms
          , h = r.vertexTextures;
        let d = r.precision;
        const p = {
            MeshDepthMaterial: "depth",
            MeshDistanceMaterial: "distanceRGBA",
            MeshNormalMaterial: "normal",
            MeshBasicMaterial: "basic",
            MeshLambertMaterial: "lambert",
            MeshPhongMaterial: "phong",
            MeshToonMaterial: "toon",
            MeshStandardMaterial: "physical",
            MeshPhysicalMaterial: "physical",
            MeshMatcapMaterial: "matcap",
            LineBasicMaterial: "basic",
            LineDashedMaterial: "dashed",
            PointsMaterial: "points",
            ShadowMaterial: "shadow",
            SpriteMaterial: "sprite"
        }
          , f = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "instancingColor", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatMap", "clearcoatRoughnessMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexAlphas", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen", "transmissionMap"];
        function m(e) {
            let t;
            return e && e.isTexture ? t = e.encoding : e && e.isWebGLRenderTarget ? (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),
            t = e.texture.encoding) : t = L,
            t
        }
        return {
            getParameters: function(i, a, f, g, v) {
                const y = g.fog
                  , b = i.isMeshStandardMaterial ? g.environment : null
                  , x = t.get(i.envMap || b)
                  , _ = p[i.type]
                  , w = v.isSkinnedMesh ? function(e) {
                    const t = e.skeleton.bones;
                    if (l)
                        return 1024;
                    {
                        const e = u
                          , n = Math.floor((e - 20) / 4)
                          , r = Math.min(n, t.length);
                        return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."),
                        0) : r
                    }
                }(v) : 0;
                let M, E;
                if (null !== i.precision && (d = r.getMaxPrecision(i.precision),
                d !== i.precision && console.warn("THREE.WebGLProgram.getParameters:", i.precision, "not supported, using", d, "instead.")),
                _) {
                    const e = An[_];
                    M = e.vertexShader,
                    E = e.fragmentShader
                } else
                    M = i.vertexShader,
                    E = i.fragmentShader;
                const S = e.getRenderTarget();
                return {
                    isWebGL2: s,
                    shaderID: _,
                    shaderName: i.type,
                    vertexShader: M,
                    fragmentShader: E,
                    defines: i.defines,
                    isRawShaderMaterial: !0 === i.isRawShaderMaterial,
                    glslVersion: i.glslVersion,
                    precision: d,
                    instancing: !0 === v.isInstancedMesh,
                    instancingColor: !0 === v.isInstancedMesh && null !== v.instanceColor,
                    supportsVertexTextures: h,
                    outputEncoding: null !== S ? m(S.texture) : e.outputEncoding,
                    map: !!i.map,
                    mapEncoding: m(i.map),
                    matcap: !!i.matcap,
                    matcapEncoding: m(i.matcap),
                    envMap: !!x,
                    envMapMode: x && x.mapping,
                    envMapEncoding: m(x),
                    envMapCubeUV: !!x && (306 === x.mapping || 307 === x.mapping),
                    lightMap: !!i.lightMap,
                    lightMapEncoding: m(i.lightMap),
                    aoMap: !!i.aoMap,
                    emissiveMap: !!i.emissiveMap,
                    emissiveMapEncoding: m(i.emissiveMap),
                    bumpMap: !!i.bumpMap,
                    normalMap: !!i.normalMap,
                    objectSpaceNormalMap: 1 === i.normalMapType,
                    tangentSpaceNormalMap: 0 === i.normalMapType,
                    clearcoatMap: !!i.clearcoatMap,
                    clearcoatRoughnessMap: !!i.clearcoatRoughnessMap,
                    clearcoatNormalMap: !!i.clearcoatNormalMap,
                    displacementMap: !!i.displacementMap,
                    roughnessMap: !!i.roughnessMap,
                    metalnessMap: !!i.metalnessMap,
                    specularMap: !!i.specularMap,
                    alphaMap: !!i.alphaMap,
                    gradientMap: !!i.gradientMap,
                    sheen: !!i.sheen,
                    transmissionMap: !!i.transmissionMap,
                    combine: i.combine,
                    vertexTangents: i.normalMap && i.vertexTangents,
                    vertexColors: i.vertexColors,
                    vertexAlphas: !0 === i.vertexColors && v.geometry.attributes.color && 4 === v.geometry.attributes.color.itemSize,
                    vertexUvs: !!(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatMap || i.clearcoatRoughnessMap || i.clearcoatNormalMap || i.displacementMap || i.transmissionMap),
                    uvsVertexOnly: !(i.map || i.bumpMap || i.normalMap || i.specularMap || i.alphaMap || i.emissiveMap || i.roughnessMap || i.metalnessMap || i.clearcoatNormalMap || i.transmissionMap || !i.displacementMap),
                    fog: !!y,
                    useFog: i.fog,
                    fogExp2: y && y.isFogExp2,
                    flatShading: !!i.flatShading,
                    sizeAttenuation: i.sizeAttenuation,
                    logarithmicDepthBuffer: c,
                    skinning: i.skinning && w > 0,
                    maxBones: w,
                    useVertexTexture: l,
                    morphTargets: i.morphTargets,
                    morphNormals: i.morphNormals,
                    numDirLights: a.directional.length,
                    numPointLights: a.point.length,
                    numSpotLights: a.spot.length,
                    numRectAreaLights: a.rectArea.length,
                    numHemiLights: a.hemi.length,
                    numDirLightShadows: a.directionalShadowMap.length,
                    numPointLightShadows: a.pointShadowMap.length,
                    numSpotLightShadows: a.spotShadowMap.length,
                    numClippingPlanes: o.numPlanes,
                    numClipIntersection: o.numIntersection,
                    dithering: i.dithering,
                    shadowMapEnabled: e.shadowMap.enabled && f.length > 0,
                    shadowMapType: e.shadowMap.type,
                    toneMapping: i.toneMapped ? e.toneMapping : 0,
                    physicallyCorrectLights: e.physicallyCorrectLights,
                    premultipliedAlpha: i.premultipliedAlpha,
                    alphaTest: i.alphaTest,
                    doubleSided: 2 === i.side,
                    flipSided: 1 === i.side,
                    depthPacking: void 0 !== i.depthPacking && i.depthPacking,
                    index0AttributeName: i.index0AttributeName,
                    extensionDerivatives: i.extensions && i.extensions.derivatives,
                    extensionFragDepth: i.extensions && i.extensions.fragDepth,
                    extensionDrawBuffers: i.extensions && i.extensions.drawBuffers,
                    extensionShaderTextureLOD: i.extensions && i.extensions.shaderTextureLOD,
                    rendererExtensionFragDepth: s || n.has("EXT_frag_depth"),
                    rendererExtensionDrawBuffers: s || n.has("WEBGL_draw_buffers"),
                    rendererExtensionShaderTextureLod: s || n.has("EXT_shader_texture_lod"),
                    customProgramCacheKey: i.customProgramCacheKey()
                }
            },
            getProgramCacheKey: function(t) {
                const n = [];
                if (t.shaderID ? n.push(t.shaderID) : (n.push(t.fragmentShader),
                n.push(t.vertexShader)),
                void 0 !== t.defines)
                    for (const e in t.defines)
                        n.push(e),
                        n.push(t.defines[e]);
                if (!1 === t.isRawShaderMaterial) {
                    for (let e = 0; e < f.length; e++)
                        n.push(t[f[e]]);
                    n.push(e.outputEncoding),
                    n.push(e.gammaFactor)
                }
                return n.push(t.customProgramCacheKey),
                n.join()
            },
            getUniforms: function(e) {
                const t = p[e.type];
                let n;
                if (t) {
                    const e = An[t];
                    n = hn.clone(e.uniforms)
                } else
                    n = e.uniforms;
                return n
            },
            acquireProgram: function(t, n) {
                let r;
                for (let e = 0, t = a.length; e < t; e++) {
                    const t = a[e];
                    if (t.cacheKey === n) {
                        r = t,
                        ++r.usedTimes;
                        break
                    }
                }
                return void 0 === r && (r = new di(e,n,t,i),
                a.push(r)),
                r
            },
            releaseProgram: function(e) {
                if (0 == --e.usedTimes) {
                    const t = a.indexOf(e);
                    a[t] = a[a.length - 1],
                    a.pop(),
                    e.destroy()
                }
            },
            programs: a
        }
    }
    function fi() {
        let e = new WeakMap;
        return {
            get: function(t) {
                let n = e.get(t);
                return void 0 === n && (n = {},
                e.set(t, n)),
                n
            },
            remove: function(t) {
                e.delete(t)
            },
            update: function(t, n, r) {
                e.get(t)[n] = r
            },
            dispose: function() {
                e = new WeakMap
            }
        }
    }
    function mi(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.program !== t.program ? e.program.id - t.program.id : e.material.id !== t.material.id ? e.material.id - t.material.id : e.z !== t.z ? e.z - t.z : e.id - t.id
    }
    function gi(e, t) {
        return e.groupOrder !== t.groupOrder ? e.groupOrder - t.groupOrder : e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder : e.z !== t.z ? t.z - e.z : e.id - t.id
    }
    function vi(e) {
        const t = [];
        let n = 0;
        const r = []
          , i = []
          , o = {
            id: -1
        };
        function a(r, i, a, s, c, l) {
            let u = t[n];
            const h = e.get(a);
            return void 0 === u ? (u = {
                id: r.id,
                object: r,
                geometry: i,
                material: a,
                program: h.program || o,
                groupOrder: s,
                renderOrder: r.renderOrder,
                z: c,
                group: l
            },
            t[n] = u) : (u.id = r.id,
            u.object = r,
            u.geometry = i,
            u.material = a,
            u.program = h.program || o,
            u.groupOrder = s,
            u.renderOrder = r.renderOrder,
            u.z = c,
            u.group = l),
            n++,
            u
        }
        return {
            opaque: r,
            transparent: i,
            init: function() {
                n = 0,
                r.length = 0,
                i.length = 0
            },
            push: function(e, t, n, o, s, c) {
                const l = a(e, t, n, o, s, c);
                (!0 === n.transparent ? i : r).push(l)
            },
            unshift: function(e, t, n, o, s, c) {
                const l = a(e, t, n, o, s, c);
                (!0 === n.transparent ? i : r).unshift(l)
            },
            finish: function() {
                for (let e = n, r = t.length; e < r; e++) {
                    const n = t[e];
                    if (null === n.id)
                        break;
                    n.id = null,
                    n.object = null,
                    n.geometry = null,
                    n.material = null,
                    n.program = null,
                    n.group = null
                }
            },
            sort: function(e, t) {
                r.length > 1 && r.sort(e || mi),
                i.length > 1 && i.sort(t || gi)
            }
        }
    }
    function yi(e) {
        let t = new WeakMap;
        return {
            get: function(n, r) {
                let i;
                return !1 === t.has(n) ? (i = new vi(e),
                t.set(n, [i])) : r >= t.get(n).length ? (i = new vi(e),
                t.get(n).push(i)) : i = t.get(n)[r],
                i
            },
            dispose: function() {
                t = new WeakMap
            }
        }
    }
    function bi() {
        const e = {};
        return {
            get: function(t) {
                if (void 0 !== e[t.id])
                    return e[t.id];
                let n;
                switch (t.type) {
                case "DirectionalLight":
                    n = {
                        direction: new q,
                        color: new yt
                    };
                    break;
                case "SpotLight":
                    n = {
                        position: new q,
                        direction: new q,
                        color: new yt,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    n = {
                        position: new q,
                        color: new yt,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    n = {
                        direction: new q,
                        skyColor: new yt,
                        groundColor: new yt
                    };
                    break;
                case "RectAreaLight":
                    n = {
                        color: new yt,
                        position: new q,
                        halfWidth: new q,
                        halfHeight: new q
                    }
                }
                return e[t.id] = n,
                n
            }
        }
    }
    let xi = 0;
    function _i(e, t) {
        return (t.castShadow ? 1 : 0) - (e.castShadow ? 1 : 0)
    }
    function wi(e, t) {
        const n = new bi
          , r = function() {
            const e = {};
            return {
                get: function(t) {
                    if (void 0 !== e[t.id])
                        return e[t.id];
                    let n;
                    switch (t.type) {
                    case "DirectionalLight":
                    case "SpotLight":
                        n = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new k
                        };
                        break;
                    case "PointLight":
                        n = {
                            shadowBias: 0,
                            shadowNormalBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new k,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        }
                    }
                    return e[t.id] = n,
                    n
                }
            }
        }()
          , i = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadow: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        };
        for (let e = 0; e < 9; e++)
            i.probe.push(new q);
        const o = new q
          , a = new Me
          , s = new Me;
        return {
            setup: function(o) {
                let a = 0
                  , s = 0
                  , c = 0;
                for (let e = 0; e < 9; e++)
                    i.probe[e].set(0, 0, 0);
                let l = 0
                  , u = 0
                  , h = 0
                  , d = 0
                  , p = 0
                  , f = 0
                  , m = 0
                  , g = 0;
                o.sort(_i);
                for (let e = 0, t = o.length; e < t; e++) {
                    const t = o[e]
                      , v = t.color
                      , y = t.intensity
                      , b = t.distance
                      , x = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
                    if (t.isAmbientLight)
                        a += v.r * y,
                        s += v.g * y,
                        c += v.b * y;
                    else if (t.isLightProbe)
                        for (let e = 0; e < 9; e++)
                            i.probe[e].addScaledVector(t.sh.coefficients[e], y);
                    else if (t.isDirectionalLight) {
                        const e = n.get(t);
                        if (e.color.copy(t.color).multiplyScalar(t.intensity),
                        t.castShadow) {
                            const e = t.shadow
                              , n = r.get(t);
                            n.shadowBias = e.bias,
                            n.shadowNormalBias = e.normalBias,
                            n.shadowRadius = e.radius,
                            n.shadowMapSize = e.mapSize,
                            i.directionalShadow[l] = n,
                            i.directionalShadowMap[l] = x,
                            i.directionalShadowMatrix[l] = t.shadow.matrix,
                            f++
                        }
                        i.directional[l] = e,
                        l++
                    } else if (t.isSpotLight) {
                        const e = n.get(t);
                        if (e.position.setFromMatrixPosition(t.matrixWorld),
                        e.color.copy(v).multiplyScalar(y),
                        e.distance = b,
                        e.coneCos = Math.cos(t.angle),
                        e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)),
                        e.decay = t.decay,
                        t.castShadow) {
                            const e = t.shadow
                              , n = r.get(t);
                            n.shadowBias = e.bias,
                            n.shadowNormalBias = e.normalBias,
                            n.shadowRadius = e.radius,
                            n.shadowMapSize = e.mapSize,
                            i.spotShadow[h] = n,
                            i.spotShadowMap[h] = x,
                            i.spotShadowMatrix[h] = t.shadow.matrix,
                            g++
                        }
                        i.spot[h] = e,
                        h++
                    } else if (t.isRectAreaLight) {
                        const e = n.get(t);
                        e.color.copy(v).multiplyScalar(y),
                        e.halfWidth.set(.5 * t.width, 0, 0),
                        e.halfHeight.set(0, .5 * t.height, 0),
                        i.rectArea[d] = e,
                        d++
                    } else if (t.isPointLight) {
                        const e = n.get(t);
                        if (e.color.copy(t.color).multiplyScalar(t.intensity),
                        e.distance = t.distance,
                        e.decay = t.decay,
                        t.castShadow) {
                            const e = t.shadow
                              , n = r.get(t);
                            n.shadowBias = e.bias,
                            n.shadowNormalBias = e.normalBias,
                            n.shadowRadius = e.radius,
                            n.shadowMapSize = e.mapSize,
                            n.shadowCameraNear = e.camera.near,
                            n.shadowCameraFar = e.camera.far,
                            i.pointShadow[u] = n,
                            i.pointShadowMap[u] = x,
                            i.pointShadowMatrix[u] = t.shadow.matrix,
                            m++
                        }
                        i.point[u] = e,
                        u++
                    } else if (t.isHemisphereLight) {
                        const e = n.get(t);
                        e.skyColor.copy(t.color).multiplyScalar(y),
                        e.groundColor.copy(t.groundColor).multiplyScalar(y),
                        i.hemi[p] = e,
                        p++
                    }
                }
                d > 0 && (t.isWebGL2 || !0 === e.has("OES_texture_float_linear") ? (i.rectAreaLTC1 = Ln.LTC_FLOAT_1,
                i.rectAreaLTC2 = Ln.LTC_FLOAT_2) : !0 === e.has("OES_texture_half_float_linear") ? (i.rectAreaLTC1 = Ln.LTC_HALF_1,
                i.rectAreaLTC2 = Ln.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),
                i.ambient[0] = a,
                i.ambient[1] = s,
                i.ambient[2] = c;
                const v = i.hash;
                v.directionalLength === l && v.pointLength === u && v.spotLength === h && v.rectAreaLength === d && v.hemiLength === p && v.numDirectionalShadows === f && v.numPointShadows === m && v.numSpotShadows === g || (i.directional.length = l,
                i.spot.length = h,
                i.rectArea.length = d,
                i.point.length = u,
                i.hemi.length = p,
                i.directionalShadow.length = f,
                i.directionalShadowMap.length = f,
                i.pointShadow.length = m,
                i.pointShadowMap.length = m,
                i.spotShadow.length = g,
                i.spotShadowMap.length = g,
                i.directionalShadowMatrix.length = f,
                i.pointShadowMatrix.length = m,
                i.spotShadowMatrix.length = g,
                v.directionalLength = l,
                v.pointLength = u,
                v.spotLength = h,
                v.rectAreaLength = d,
                v.hemiLength = p,
                v.numDirectionalShadows = f,
                v.numPointShadows = m,
                v.numSpotShadows = g,
                i.version = xi++)
            },
            setupView: function(e, t) {
                let n = 0
                  , r = 0
                  , c = 0
                  , l = 0
                  , u = 0;
                const h = t.matrixWorldInverse;
                for (let t = 0, d = e.length; t < d; t++) {
                    const d = e[t];
                    if (d.isDirectionalLight) {
                        const e = i.directional[n];
                        e.direction.setFromMatrixPosition(d.matrixWorld),
                        o.setFromMatrixPosition(d.target.matrixWorld),
                        e.direction.sub(o),
                        e.direction.transformDirection(h),
                        n++
                    } else if (d.isSpotLight) {
                        const e = i.spot[c];
                        e.position.setFromMatrixPosition(d.matrixWorld),
                        e.position.applyMatrix4(h),
                        e.direction.setFromMatrixPosition(d.matrixWorld),
                        o.setFromMatrixPosition(d.target.matrixWorld),
                        e.direction.sub(o),
                        e.direction.transformDirection(h),
                        c++
                    } else if (d.isRectAreaLight) {
                        const e = i.rectArea[l];
                        e.position.setFromMatrixPosition(d.matrixWorld),
                        e.position.applyMatrix4(h),
                        s.identity(),
                        a.copy(d.matrixWorld),
                        a.premultiply(h),
                        s.extractRotation(a),
                        e.halfWidth.set(.5 * d.width, 0, 0),
                        e.halfHeight.set(0, .5 * d.height, 0),
                        e.halfWidth.applyMatrix4(s),
                        e.halfHeight.applyMatrix4(s),
                        l++
                    } else if (d.isPointLight) {
                        const e = i.point[r];
                        e.position.setFromMatrixPosition(d.matrixWorld),
                        e.position.applyMatrix4(h),
                        r++
                    } else if (d.isHemisphereLight) {
                        const e = i.hemi[u];
                        e.direction.setFromMatrixPosition(d.matrixWorld),
                        e.direction.transformDirection(h),
                        e.direction.normalize(),
                        u++
                    }
                }
            },
            state: i
        }
    }
    function Mi(e, t) {
        const n = new wi(e,t)
          , r = []
          , i = [];
        return {
            init: function() {
                r.length = 0,
                i.length = 0
            },
            state: {
                lightsArray: r,
                shadowsArray: i,
                lights: n
            },
            setupLights: function() {
                n.setup(r)
            },
            setupLightsView: function(e) {
                n.setupView(r, e)
            },
            pushLight: function(e) {
                r.push(e)
            },
            pushShadow: function(e) {
                i.push(e)
            }
        }
    }
    function Ei(e, t) {
        let n = new WeakMap;
        return {
            get: function(r, i=0) {
                let o;
                return !1 === n.has(r) ? (o = new Mi(e,t),
                n.set(r, [o])) : i >= n.get(r).length ? (o = new Mi(e,t),
                n.get(r).push(o)) : o = n.get(r)[i],
                o
            },
            dispose: function() {
                n = new WeakMap
            }
        }
    }
    class Si extends ht {
        constructor(e) {
            super(),
            this.type = "MeshDepthMaterial",
            this.depthPacking = 3200,
            this.skinning = !1,
            this.morphTargets = !1,
            this.map = null,
            this.alphaMap = null,
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.fog = !1,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.depthPacking = e.depthPacking,
            this.skinning = e.skinning,
            this.morphTargets = e.morphTargets,
            this.map = e.map,
            this.alphaMap = e.alphaMap,
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this
        }
    }
    Si.prototype.isMeshDepthMaterial = !0;
    class Ti extends ht {
        constructor(e) {
            super(),
            this.type = "MeshDistanceMaterial",
            this.referencePosition = new q,
            this.nearDistance = 1,
            this.farDistance = 1e3,
            this.skinning = !1,
            this.morphTargets = !1,
            this.map = null,
            this.alphaMap = null,
            this.displacementMap = null,
            this.displacementScale = 1,
            this.displacementBias = 0,
            this.fog = !1,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.referencePosition.copy(e.referencePosition),
            this.nearDistance = e.nearDistance,
            this.farDistance = e.farDistance,
            this.skinning = e.skinning,
            this.morphTargets = e.morphTargets,
            this.map = e.map,
            this.alphaMap = e.alphaMap,
            this.displacementMap = e.displacementMap,
            this.displacementScale = e.displacementScale,
            this.displacementBias = e.displacementBias,
            this
        }
    }
    Ti.prototype.isMeshDistanceMaterial = !0;
    function Li(e, t, n) {
        let r = new wn;
        const i = new k
          , o = new k
          , a = new G
          , s = []
          , c = []
          , l = {}
          , u = n.maxTextureSize
          , h = {
            0: 1,
            1: 0,
            2: 2
        }
          , d = new dn({
            defines: {
                SAMPLE_RATE: 2 / 8,
                HALF_SAMPLE_RATE: 1 / 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new k
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
        })
          , p = d.clone();
        p.defines.HORIZONTAL_PASS = 1;
        const g = new Ht;
        g.setAttribute("position", new wt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
        const v = new an(g,d)
          , y = this;
        function b(n, r) {
            const i = t.update(v);
            d.uniforms.shadow_pass.value = n.map.texture,
            d.uniforms.resolution.value = n.mapSize,
            d.uniforms.radius.value = n.radius,
            e.setRenderTarget(n.mapPass),
            e.clear(),
            e.renderBufferDirect(r, null, i, d, v, null),
            p.uniforms.shadow_pass.value = n.mapPass.texture,
            p.uniforms.resolution.value = n.mapSize,
            p.uniforms.radius.value = n.radius,
            e.setRenderTarget(n.map),
            e.clear(),
            e.renderBufferDirect(r, null, i, p, v, null)
        }
        function x(e, t, n) {
            const r = e << 0 | t << 1 | n << 2;
            let i = s[r];
            return void 0 === i && (i = new Si({
                depthPacking: 3201,
                morphTargets: e,
                skinning: t
            }),
            s[r] = i),
            i
        }
        function _(e, t, n) {
            const r = e << 0 | t << 1 | n << 2;
            let i = c[r];
            return void 0 === i && (i = new Ti({
                morphTargets: e,
                skinning: t
            }),
            c[r] = i),
            i
        }
        function w(t, n, r, i, o, a, s) {
            let c = null
              , u = x
              , d = t.customDepthMaterial;
            if (!0 === i.isPointLight && (u = _,
            d = t.customDistanceMaterial),
            void 0 === d) {
                let e = !1;
                !0 === r.morphTargets && (e = n.morphAttributes && n.morphAttributes.position && n.morphAttributes.position.length > 0);
                let i = !1;
                !0 === t.isSkinnedMesh && (!0 === r.skinning ? i = !0 : console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", t));
                c = u(e, i, !0 === t.isInstancedMesh)
            } else
                c = d;
            if (e.localClippingEnabled && !0 === r.clipShadows && 0 !== r.clippingPlanes.length) {
                const e = c.uuid
                  , t = r.uuid;
                let n = l[e];
                void 0 === n && (n = {},
                l[e] = n);
                let i = n[t];
                void 0 === i && (i = c.clone(),
                n[t] = i),
                c = i
            }
            return c.visible = r.visible,
            c.wireframe = r.wireframe,
            c.side = 3 === s ? null !== r.shadowSide ? r.shadowSide : r.side : null !== r.shadowSide ? r.shadowSide : h[r.side],
            c.clipShadows = r.clipShadows,
            c.clippingPlanes = r.clippingPlanes,
            c.clipIntersection = r.clipIntersection,
            c.wireframeLinewidth = r.wireframeLinewidth,
            c.linewidth = r.linewidth,
            !0 === i.isPointLight && !0 === c.isMeshDistanceMaterial && (c.referencePosition.setFromMatrixPosition(i.matrixWorld),
            c.nearDistance = o,
            c.farDistance = a),
            c
        }
        function M(n, i, o, a, s) {
            if (!1 === n.visible)
                return;
            if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && (n.castShadow || n.receiveShadow && 3 === s) && (!n.frustumCulled || r.intersectsObject(n))) {
                n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                const r = t.update(n)
                  , i = n.material;
                if (Array.isArray(i)) {
                    const t = r.groups;
                    for (let c = 0, l = t.length; c < l; c++) {
                        const l = t[c]
                          , u = i[l.materialIndex];
                        if (u && u.visible) {
                            const t = w(n, r, u, a, o.near, o.far, s);
                            e.renderBufferDirect(o, null, r, t, n, l)
                        }
                    }
                } else if (i.visible) {
                    const t = w(n, r, i, a, o.near, o.far, s);
                    e.renderBufferDirect(o, null, r, t, n, null)
                }
            }
            const c = n.children;
            for (let e = 0, t = c.length; e < t; e++)
                M(c[e], i, o, a, s)
        }
        this.enabled = !1,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this.type = 1,
        this.render = function(t, n, s) {
            if (!1 === y.enabled)
                return;
            if (!1 === y.autoUpdate && !1 === y.needsUpdate)
                return;
            if (0 === t.length)
                return;
            const c = e.getRenderTarget()
              , l = e.getActiveCubeFace()
              , h = e.getActiveMipmapLevel()
              , d = e.state;
            d.setBlending(0),
            d.buffers.color.setClear(1, 1, 1, 1),
            d.buffers.depth.setTest(!0),
            d.setScissorTest(!1);
            for (let c = 0, l = t.length; c < l; c++) {
                const l = t[c]
                  , h = l.shadow;
                if (void 0 === h) {
                    console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
                    continue
                }
                if (!1 === h.autoUpdate && !1 === h.needsUpdate)
                    continue;
                i.copy(h.mapSize);
                const p = h.getFrameExtents();
                if (i.multiply(p),
                o.copy(h.mapSize),
                (i.x > u || i.y > u) && (i.x > u && (o.x = Math.floor(u / p.x),
                i.x = o.x * p.x,
                h.mapSize.x = o.x),
                i.y > u && (o.y = Math.floor(u / p.y),
                i.y = o.y * p.y,
                h.mapSize.y = o.y)),
                null === h.map && !h.isPointLightShadow && 3 === this.type) {
                    const e = {
                        minFilter: m,
                        magFilter: m,
                        format: E
                    };
                    h.map = new V(i.x,i.y,e),
                    h.map.texture.name = l.name + ".shadowMap",
                    h.mapPass = new V(i.x,i.y,e),
                    h.camera.updateProjectionMatrix()
                }
                if (null === h.map) {
                    const e = {
                        minFilter: f,
                        magFilter: f,
                        format: E
                    };
                    h.map = new V(i.x,i.y,e),
                    h.map.texture.name = l.name + ".shadowMap",
                    h.camera.updateProjectionMatrix()
                }
                e.setRenderTarget(h.map),
                e.clear();
                const g = h.getViewportCount();
                for (let e = 0; e < g; e++) {
                    const t = h.getViewport(e);
                    a.set(o.x * t.x, o.y * t.y, o.x * t.z, o.y * t.w),
                    d.viewport(a),
                    h.updateMatrices(l, e),
                    r = h.getFrustum(),
                    M(n, s, h.camera, l, this.type)
                }
                h.isPointLightShadow || 3 !== this.type || b(h, s),
                h.needsUpdate = !1
            }
            y.needsUpdate = !1,
            e.setRenderTarget(c, l, h)
        }
    }
    function Ai(e, t, n) {
        const r = n.isWebGL2;
        const i = new function() {
            let t = !1;
            const n = new G;
            let r = null;
            const i = new G(0,0,0,0);
            return {
                setMask: function(n) {
                    r === n || t || (e.colorMask(n, n, n, n),
                    r = n)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t, r, o, a, s) {
                    !0 === s && (t *= a,
                    r *= a,
                    o *= a),
                    n.set(t, r, o, a),
                    !1 === i.equals(n) && (e.clearColor(t, r, o, a),
                    i.copy(n))
                },
                reset: function() {
                    t = !1,
                    r = null,
                    i.set(-1, 0, 0, 0)
                }
            }
        }
          , o = new function() {
            let t = !1
              , n = null
              , r = null
              , i = null;
            return {
                setTest: function(e) {
                    e ? k(2929) : z(2929)
                },
                setMask: function(r) {
                    n === r || t || (e.depthMask(r),
                    n = r)
                },
                setFunc: function(t) {
                    if (r !== t) {
                        if (t)
                            switch (t) {
                            case 0:
                                e.depthFunc(512);
                                break;
                            case 1:
                                e.depthFunc(519);
                                break;
                            case 2:
                                e.depthFunc(513);
                                break;
                            case 3:
                                e.depthFunc(515);
                                break;
                            case 4:
                                e.depthFunc(514);
                                break;
                            case 5:
                                e.depthFunc(518);
                                break;
                            case 6:
                                e.depthFunc(516);
                                break;
                            case 7:
                                e.depthFunc(517);
                                break;
                            default:
                                e.depthFunc(515)
                            }
                        else
                            e.depthFunc(515);
                        r = t
                    }
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t) {
                    i !== t && (e.clearDepth(t),
                    i = t)
                },
                reset: function() {
                    t = !1,
                    n = null,
                    r = null,
                    i = null
                }
            }
        }
          , a = new function() {
            let t = !1
              , n = null
              , r = null
              , i = null
              , o = null
              , a = null
              , s = null
              , c = null
              , l = null;
            return {
                setTest: function(e) {
                    t || (e ? k(2960) : z(2960))
                },
                setMask: function(r) {
                    n === r || t || (e.stencilMask(r),
                    n = r)
                },
                setFunc: function(t, n, a) {
                    r === t && i === n && o === a || (e.stencilFunc(t, n, a),
                    r = t,
                    i = n,
                    o = a)
                },
                setOp: function(t, n, r) {
                    a === t && s === n && c === r || (e.stencilOp(t, n, r),
                    a = t,
                    s = n,
                    c = r)
                },
                setLocked: function(e) {
                    t = e
                },
                setClear: function(t) {
                    l !== t && (e.clearStencil(t),
                    l = t)
                },
                reset: function() {
                    t = !1,
                    n = null,
                    r = null,
                    i = null,
                    o = null,
                    a = null,
                    s = null,
                    c = null,
                    l = null
                }
            }
        }
        ;
        let s = {}
          , c = null
          , l = {}
          , h = null
          , d = !1
          , p = null
          , f = null
          , m = null
          , g = null
          , v = null
          , y = null
          , b = null
          , x = !1
          , _ = null
          , w = null
          , M = null
          , E = null
          , S = null;
        const T = e.getParameter(35661);
        let L = !1
          , A = 0;
        const P = e.getParameter(7938);
        -1 !== P.indexOf("WebGL") ? (A = parseFloat(/^WebGL (\d)/.exec(P)[1]),
        L = A >= 1) : -1 !== P.indexOf("OpenGL ES") && (A = parseFloat(/^OpenGL ES (\d)/.exec(P)[1]),
        L = A >= 2);
        let C = null
          , R = {};
        const D = new G(0,0,e.canvas.width,e.canvas.height)
          , O = new G(0,0,e.canvas.width,e.canvas.height);
        function N(t, n, r) {
            const i = new Uint8Array(4)
              , o = e.createTexture();
            e.bindTexture(t, o),
            e.texParameteri(t, 10241, 9728),
            e.texParameteri(t, 10240, 9728);
            for (let t = 0; t < r; t++)
                e.texImage2D(n + t, 0, 6408, 1, 1, 0, 6408, 5121, i);
            return o
        }
        const I = {};
        function k(t) {
            !0 !== s[t] && (e.enable(t),
            s[t] = !0)
        }
        function z(t) {
            !1 !== s[t] && (e.disable(t),
            s[t] = !1)
        }
        I[3553] = N(3553, 3553, 1),
        I[34067] = N(34067, 34069, 6),
        i.setClear(0, 0, 0, 1),
        o.setClear(1),
        a.setClear(0),
        k(2929),
        o.setFunc(3),
        H(!1),
        j(1),
        k(2884),
        U(0);
        const F = {
            [u]: 32774,
            101: 32778,
            102: 32779
        };
        if (r)
            F[103] = 32775,
            F[104] = 32776;
        else {
            const e = t.get("EXT_blend_minmax");
            null !== e && (F[103] = e.MIN_EXT,
            F[104] = e.MAX_EXT)
        }
        const B = {
            200: 0,
            201: 1,
            202: 768,
            204: 770,
            210: 776,
            208: 774,
            206: 772,
            203: 769,
            205: 771,
            209: 775,
            207: 773
        };
        function U(t, n, r, i, o, a, s, c) {
            if (0 !== t) {
                if (!1 === d && (k(3042),
                d = !0),
                5 === t)
                    o = o || n,
                    a = a || r,
                    s = s || i,
                    n === f && o === v || (e.blendEquationSeparate(F[n], F[o]),
                    f = n,
                    v = o),
                    r === m && i === g && a === y && s === b || (e.blendFuncSeparate(B[r], B[i], B[a], B[s]),
                    m = r,
                    g = i,
                    y = a,
                    b = s),
                    p = t,
                    x = null;
                else if (t !== p || c !== x) {
                    if (f === u && v === u || (e.blendEquation(32774),
                    f = u,
                    v = u),
                    c)
                        switch (t) {
                        case 1:
                            e.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case 2:
                            e.blendFunc(1, 1);
                            break;
                        case 3:
                            e.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case 4:
                            e.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                        }
                    else
                        switch (t) {
                        case 1:
                            e.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case 2:
                            e.blendFunc(770, 1);
                            break;
                        case 3:
                            e.blendFunc(0, 769);
                            break;
                        case 4:
                            e.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", t)
                        }
                    m = null,
                    g = null,
                    y = null,
                    b = null,
                    p = t,
                    x = c
                }
            } else
                !0 === d && (z(3042),
                d = !1)
        }
        function H(t) {
            _ !== t && (t ? e.frontFace(2304) : e.frontFace(2305),
            _ = t)
        }
        function j(t) {
            0 !== t ? (k(2884),
            t !== w && (1 === t ? e.cullFace(1029) : 2 === t ? e.cullFace(1028) : e.cullFace(1032))) : z(2884),
            w = t
        }
        function V(t, n, r) {
            t ? (k(32823),
            E === n && S === r || (e.polygonOffset(n, r),
            E = n,
            S = r)) : z(32823)
        }
        function W(t) {
            void 0 === t && (t = 33984 + T - 1),
            C !== t && (e.activeTexture(t),
            C = t)
        }
        return {
            buffers: {
                color: i,
                depth: o,
                stencil: a
            },
            enable: k,
            disable: z,
            bindFramebuffer: function(t, n) {
                null === n && null !== c && (n = c),
                l[t] !== n && (e.bindFramebuffer(t, n),
                l[t] = n)
            },
            bindXRFramebuffer: function(t) {
                t !== c && (e.bindFramebuffer(36160, t),
                c = t)
            },
            useProgram: function(t) {
                return h !== t && (e.useProgram(t),
                h = t,
                !0)
            },
            setBlending: U,
            setMaterial: function(e, t) {
                2 === e.side ? z(2884) : k(2884);
                let n = 1 === e.side;
                t && (n = !n),
                H(n),
                1 === e.blending && !1 === e.transparent ? U(0) : U(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha),
                o.setFunc(e.depthFunc),
                o.setTest(e.depthTest),
                o.setMask(e.depthWrite),
                i.setMask(e.colorWrite);
                const r = e.stencilWrite;
                a.setTest(r),
                r && (a.setMask(e.stencilWriteMask),
                a.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
                a.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
                V(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
                !0 === e.alphaToCoverage ? k(32926) : z(32926)
            },
            setFlipSided: H,
            setCullFace: j,
            setLineWidth: function(t) {
                t !== M && (L && e.lineWidth(t),
                M = t)
            },
            setPolygonOffset: V,
            setScissorTest: function(e) {
                e ? k(3089) : z(3089)
            },
            activeTexture: W,
            bindTexture: function(t, n) {
                null === C && W();
                let r = R[C];
                void 0 === r && (r = {
                    type: void 0,
                    texture: void 0
                },
                R[C] = r),
                r.type === t && r.texture === n || (e.bindTexture(t, n || I[t]),
                r.type = t,
                r.texture = n)
            },
            unbindTexture: function() {
                const t = R[C];
                void 0 !== t && void 0 !== t.type && (e.bindTexture(t.type, null),
                t.type = void 0,
                t.texture = void 0)
            },
            compressedTexImage2D: function() {
                try {
                    e.compressedTexImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage2D: function() {
                try {
                    e.texImage2D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            texImage3D: function() {
                try {
                    e.texImage3D.apply(e, arguments)
                } catch (e) {
                    console.error("THREE.WebGLState:", e)
                }
            },
            scissor: function(t) {
                !1 === D.equals(t) && (e.scissor(t.x, t.y, t.z, t.w),
                D.copy(t))
            },
            viewport: function(t) {
                !1 === O.equals(t) && (e.viewport(t.x, t.y, t.z, t.w),
                O.copy(t))
            },
            reset: function() {
                e.disable(3042),
                e.disable(2884),
                e.disable(2929),
                e.disable(32823),
                e.disable(3089),
                e.disable(2960),
                e.disable(32926),
                e.blendEquation(32774),
                e.blendFunc(1, 0),
                e.blendFuncSeparate(1, 0, 1, 0),
                e.colorMask(!0, !0, !0, !0),
                e.clearColor(0, 0, 0, 0),
                e.depthMask(!0),
                e.depthFunc(513),
                e.clearDepth(1),
                e.stencilMask(4294967295),
                e.stencilFunc(519, 0, 4294967295),
                e.stencilOp(7680, 7680, 7680),
                e.clearStencil(0),
                e.cullFace(1029),
                e.frontFace(2305),
                e.polygonOffset(0, 0),
                e.activeTexture(33984),
                e.bindFramebuffer(36160, null),
                !0 === r && (e.bindFramebuffer(36009, null),
                e.bindFramebuffer(36008, null)),
                e.useProgram(null),
                e.lineWidth(1),
                e.scissor(0, 0, e.canvas.width, e.canvas.height),
                e.viewport(0, 0, e.canvas.width, e.canvas.height),
                s = {},
                C = null,
                R = {},
                c = null,
                l = {},
                h = null,
                d = !1,
                p = null,
                f = null,
                m = null,
                g = null,
                v = null,
                y = null,
                b = null,
                x = !1,
                _ = null,
                w = null,
                M = null,
                E = null,
                S = null,
                D.set(0, 0, e.canvas.width, e.canvas.height),
                O.set(0, 0, e.canvas.width, e.canvas.height),
                i.reset(),
                o.reset(),
                a.reset()
            }
        }
    }
    function Pi(e, t, n, r, i, o, a) {
        const s = i.isWebGL2
          , c = i.maxTextures
          , l = i.maxCubemapSize
          , u = i.maxTextureSize
          , v = i.maxSamples
          , L = new WeakMap;
        let A, P = !1;
        try {
            P = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1,1).getContext("2d")
        } catch (e) {}
        function C(e, t) {
            return P ? new OffscreenCanvas(e,t) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
        }
        function R(e, t, n, r) {
            let i = 1;
            if ((e.width > r || e.height > r) && (i = r / Math.max(e.width, e.height)),
            i < 1 || !0 === t) {
                if ("undefined" != typeof HTMLImageElement && e instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && e instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && e instanceof ImageBitmap) {
                    const r = t ? I.floorPowerOfTwo : Math.floor
                      , o = r(i * e.width)
                      , a = r(i * e.height);
                    void 0 === A && (A = C(o, a));
                    const s = n ? C(o, a) : A;
                    s.width = o,
                    s.height = a;
                    return s.getContext("2d").drawImage(e, 0, 0, o, a),
                    console.warn("THREE.WebGLRenderer: Texture has been resized from (" + e.width + "x" + e.height + ") to (" + o + "x" + a + ")."),
                    s
                }
                return "data"in e && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + e.width + "x" + e.height + ")."),
                e
            }
            return e
        }
        function D(e) {
            return I.isPowerOfTwo(e.width) && I.isPowerOfTwo(e.height)
        }
        function O(e, t) {
            return e.generateMipmaps && t && e.minFilter !== f && e.minFilter !== m
        }
        function N(t, n, i, o) {
            e.generateMipmap(t);
            r.get(n).__maxMipLevel = Math.log2(Math.max(i, o))
        }
        function k(n, r, i) {
            if (!1 === s)
                return r;
            if (null !== n) {
                if (void 0 !== e[n])
                    return e[n];
                console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
            }
            let o = r;
            return 6403 === r && (5126 === i && (o = 33326),
            5131 === i && (o = 33325),
            5121 === i && (o = 33321)),
            6407 === r && (5126 === i && (o = 34837),
            5131 === i && (o = 34843),
            5121 === i && (o = 32849)),
            6408 === r && (5126 === i && (o = 34836),
            5131 === i && (o = 34842),
            5121 === i && (o = 32856)),
            33325 !== o && 33326 !== o && 34842 !== o && 34836 !== o || t.get("EXT_color_buffer_float"),
            o
        }
        function z(e) {
            return e === f || 1004 === e || 1005 === e ? 9728 : 9729
        }
        function F(t) {
            const n = t.target;
            n.removeEventListener("dispose", F),
            function(t) {
                const n = r.get(t);
                if (void 0 === n.__webglInit)
                    return;
                e.deleteTexture(n.__webglTexture),
                r.remove(t)
            }(n),
            n.isVideoTexture && L.delete(n),
            a.memory.textures--
        }
        function B(t) {
            const n = t.target;
            n.removeEventListener("dispose", B),
            function(t) {
                const n = t.texture
                  , i = r.get(t)
                  , o = r.get(n);
                if (!t)
                    return;
                void 0 !== o.__webglTexture && e.deleteTexture(o.__webglTexture);
                t.depthTexture && t.depthTexture.dispose();
                if (t.isWebGLCubeRenderTarget)
                    for (let t = 0; t < 6; t++)
                        e.deleteFramebuffer(i.__webglFramebuffer[t]),
                        i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer[t]);
                else
                    e.deleteFramebuffer(i.__webglFramebuffer),
                    i.__webglDepthbuffer && e.deleteRenderbuffer(i.__webglDepthbuffer),
                    i.__webglMultisampledFramebuffer && e.deleteFramebuffer(i.__webglMultisampledFramebuffer),
                    i.__webglColorRenderbuffer && e.deleteRenderbuffer(i.__webglColorRenderbuffer),
                    i.__webglDepthRenderbuffer && e.deleteRenderbuffer(i.__webglDepthRenderbuffer);
                r.remove(n),
                r.remove(t)
            }(n),
            a.memory.textures--
        }
        let U = 0;
        function H(e, t) {
            const i = r.get(e);
            if (e.isVideoTexture && function(e) {
                const t = a.render.frame;
                L.get(e) !== t && (L.set(e, t),
                e.update())
            }(e),
            e.version > 0 && i.__version !== e.version) {
                const n = e.image;
                if (void 0 === n)
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                else {
                    if (!1 !== n.complete)
                        return void X(i, e, t);
                    console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                }
            }
            n.activeTexture(33984 + t),
            n.bindTexture(3553, i.__webglTexture)
        }
        function j(t, i) {
            const a = r.get(t);
            t.version > 0 && a.__version !== t.version ? function(t, r, i) {
                if (6 !== r.image.length)
                    return;
                q(t, r),
                n.activeTexture(33984 + i),
                n.bindTexture(34067, t.__webglTexture),
                e.pixelStorei(37440, r.flipY),
                e.pixelStorei(37441, r.premultiplyAlpha),
                e.pixelStorei(3317, r.unpackAlignment),
                e.pixelStorei(37443, 0);
                const a = r && (r.isCompressedTexture || r.image[0].isCompressedTexture)
                  , c = r.image[0] && r.image[0].isDataTexture
                  , u = [];
                for (let e = 0; e < 6; e++)
                    u[e] = a || c ? c ? r.image[e].image : r.image[e] : R(r.image[e], !1, !0, l);
                const h = u[0]
                  , d = D(h) || s
                  , p = o.convert(r.format)
                  , f = o.convert(r.type)
                  , m = k(r.internalFormat, p, f);
                let g;
                if (W(34067, r, d),
                a) {
                    for (let e = 0; e < 6; e++) {
                        g = u[e].mipmaps;
                        for (let t = 0; t < g.length; t++) {
                            const i = g[t];
                            r.format !== E && r.format !== M ? null !== p ? n.compressedTexImage2D(34069 + e, t, m, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + e, t, m, i.width, i.height, 0, p, f, i.data)
                        }
                    }
                    t.__maxMipLevel = g.length - 1
                } else {
                    g = r.mipmaps;
                    for (let e = 0; e < 6; e++)
                        if (c) {
                            n.texImage2D(34069 + e, 0, m, u[e].width, u[e].height, 0, p, f, u[e].data);
                            for (let t = 0; t < g.length; t++) {
                                const r = g[t].image[e].image;
                                n.texImage2D(34069 + e, t + 1, m, r.width, r.height, 0, p, f, r.data)
                            }
                        } else {
                            n.texImage2D(34069 + e, 0, m, p, f, u[e]);
                            for (let t = 0; t < g.length; t++) {
                                const r = g[t];
                                n.texImage2D(34069 + e, t + 1, m, p, f, r.image[e])
                            }
                        }
                    t.__maxMipLevel = g.length
                }
                O(r, d) && N(34067, r, h.width, h.height);
                t.__version = r.version,
                r.onUpdate && r.onUpdate(r)
            }(a, t, i) : (n.activeTexture(33984 + i),
            n.bindTexture(34067, a.__webglTexture))
        }
        const G = {
            [h]: 10497,
            [d]: 33071,
            [p]: 33648
        }
          , V = {
            [f]: 9728,
            1004: 9984,
            1005: 9986,
            [m]: 9729,
            1007: 9985,
            [g]: 9987
        };
        function W(n, o, a) {
            if (a ? (e.texParameteri(n, 10242, G[o.wrapS]),
            e.texParameteri(n, 10243, G[o.wrapT]),
            32879 !== n && 35866 !== n || e.texParameteri(n, 32882, G[o.wrapR]),
            e.texParameteri(n, 10240, V[o.magFilter]),
            e.texParameteri(n, 10241, V[o.minFilter])) : (e.texParameteri(n, 10242, 33071),
            e.texParameteri(n, 10243, 33071),
            32879 !== n && 35866 !== n || e.texParameteri(n, 32882, 33071),
            o.wrapS === d && o.wrapT === d || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),
            e.texParameteri(n, 10240, z(o.magFilter)),
            e.texParameteri(n, 10241, z(o.minFilter)),
            o.minFilter !== f && o.minFilter !== m && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),
            !0 === t.has("EXT_texture_filter_anisotropic")) {
                const a = t.get("EXT_texture_filter_anisotropic");
                if (o.type === x && !1 === t.has("OES_texture_float_linear"))
                    return;
                if (!1 === s && o.type === _ && !1 === t.has("OES_texture_half_float_linear"))
                    return;
                (o.anisotropy > 1 || r.get(o).__currentAnisotropy) && (e.texParameterf(n, a.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, i.getMaxAnisotropy())),
                r.get(o).__currentAnisotropy = o.anisotropy)
            }
        }
        function q(t, n) {
            void 0 === t.__webglInit && (t.__webglInit = !0,
            n.addEventListener("dispose", F),
            t.__webglTexture = e.createTexture(),
            a.memory.textures++)
        }
        function X(t, r, i) {
            let a = 3553;
            r.isDataTexture2DArray && (a = 35866),
            r.isDataTexture3D && (a = 32879),
            q(t, r),
            n.activeTexture(33984 + i),
            n.bindTexture(a, t.__webglTexture),
            e.pixelStorei(37440, r.flipY),
            e.pixelStorei(37441, r.premultiplyAlpha),
            e.pixelStorei(3317, r.unpackAlignment),
            e.pixelStorei(37443, 0);
            const c = function(e) {
                return !s && (e.wrapS !== d || e.wrapT !== d || e.minFilter !== f && e.minFilter !== m)
            }(r) && !1 === D(r.image)
              , l = R(r.image, c, !1, u)
              , h = D(l) || s
              , p = o.convert(r.format);
            let g, v = o.convert(r.type), _ = k(r.internalFormat, p, v);
            W(a, r, h);
            const L = r.mipmaps;
            if (r.isDepthTexture)
                _ = 6402,
                s ? _ = r.type === x ? 36012 : r.type === b ? 33190 : r.type === w ? 35056 : 33189 : r.type === x && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),
                r.format === S && 6402 === _ && r.type !== y && r.type !== b && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
                r.type = y,
                v = o.convert(r.type)),
                r.format === T && 6402 === _ && (_ = 34041,
                r.type !== w && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),
                r.type = w,
                v = o.convert(r.type))),
                n.texImage2D(3553, 0, _, l.width, l.height, 0, p, v, null);
            else if (r.isDataTexture)
                if (L.length > 0 && h) {
                    for (let e = 0, t = L.length; e < t; e++)
                        g = L[e],
                        n.texImage2D(3553, e, _, g.width, g.height, 0, p, v, g.data);
                    r.generateMipmaps = !1,
                    t.__maxMipLevel = L.length - 1
                } else
                    n.texImage2D(3553, 0, _, l.width, l.height, 0, p, v, l.data),
                    t.__maxMipLevel = 0;
            else if (r.isCompressedTexture) {
                for (let e = 0, t = L.length; e < t; e++)
                    g = L[e],
                    r.format !== E && r.format !== M ? null !== p ? n.compressedTexImage2D(3553, e, _, g.width, g.height, 0, g.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, e, _, g.width, g.height, 0, p, v, g.data);
                t.__maxMipLevel = L.length - 1
            } else if (r.isDataTexture2DArray)
                n.texImage3D(35866, 0, _, l.width, l.height, l.depth, 0, p, v, l.data),
                t.__maxMipLevel = 0;
            else if (r.isDataTexture3D)
                n.texImage3D(32879, 0, _, l.width, l.height, l.depth, 0, p, v, l.data),
                t.__maxMipLevel = 0;
            else if (L.length > 0 && h) {
                for (let e = 0, t = L.length; e < t; e++)
                    g = L[e],
                    n.texImage2D(3553, e, _, p, v, g);
                r.generateMipmaps = !1,
                t.__maxMipLevel = L.length - 1
            } else
                n.texImage2D(3553, 0, _, p, v, l),
                t.__maxMipLevel = 0;
            O(r, h) && N(a, r, l.width, l.height),
            t.__version = r.version,
            r.onUpdate && r.onUpdate(r)
        }
        function Y(t, i, a, s) {
            const c = i.texture
              , l = o.convert(c.format)
              , u = o.convert(c.type)
              , h = k(c.internalFormat, l, u);
            32879 === s || 35866 === s ? n.texImage3D(s, 0, h, i.width, i.height, i.depth, 0, l, u, null) : n.texImage2D(s, 0, h, i.width, i.height, 0, l, u, null),
            n.bindFramebuffer(36160, t),
            e.framebufferTexture2D(36160, a, s, r.get(c).__webglTexture, 0),
            n.bindFramebuffer(36160, null)
        }
        function Z(t, n, r) {
            if (e.bindRenderbuffer(36161, t),
            n.depthBuffer && !n.stencilBuffer) {
                let i = 33189;
                if (r) {
                    const t = n.depthTexture;
                    t && t.isDepthTexture && (t.type === x ? i = 36012 : t.type === b && (i = 33190));
                    const r = J(n);
                    e.renderbufferStorageMultisample(36161, r, i, n.width, n.height)
                } else
                    e.renderbufferStorage(36161, i, n.width, n.height);
                e.framebufferRenderbuffer(36160, 36096, 36161, t)
            } else if (n.depthBuffer && n.stencilBuffer) {
                if (r) {
                    const t = J(n);
                    e.renderbufferStorageMultisample(36161, t, 35056, n.width, n.height)
                } else
                    e.renderbufferStorage(36161, 34041, n.width, n.height);
                e.framebufferRenderbuffer(36160, 33306, 36161, t)
            } else {
                const t = n.texture
                  , i = o.convert(t.format)
                  , a = o.convert(t.type)
                  , s = k(t.internalFormat, i, a);
                if (r) {
                    const t = J(n);
                    e.renderbufferStorageMultisample(36161, t, s, n.width, n.height)
                } else
                    e.renderbufferStorage(36161, s, n.width, n.height)
            }
            e.bindRenderbuffer(36161, null)
        }
        function $(t) {
            const i = r.get(t)
              , o = !0 === t.isWebGLCubeRenderTarget;
            if (t.depthTexture) {
                if (o)
                    throw new Error("target.depthTexture not supported in Cube render targets");
                !function(t, i) {
                    if (i && i.isWebGLCubeRenderTarget)
                        throw new Error("Depth Texture with cube render targets is not supported");
                    if (n.bindFramebuffer(36160, t),
                    !i.depthTexture || !i.depthTexture.isDepthTexture)
                        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    r.get(i.depthTexture).__webglTexture && i.depthTexture.image.width === i.width && i.depthTexture.image.height === i.height || (i.depthTexture.image.width = i.width,
                    i.depthTexture.image.height = i.height,
                    i.depthTexture.needsUpdate = !0),
                    H(i.depthTexture, 0);
                    const o = r.get(i.depthTexture).__webglTexture;
                    if (i.depthTexture.format === S)
                        e.framebufferTexture2D(36160, 36096, 3553, o, 0);
                    else {
                        if (i.depthTexture.format !== T)
                            throw new Error("Unknown depthTexture format");
                        e.framebufferTexture2D(36160, 33306, 3553, o, 0)
                    }
                }(i.__webglFramebuffer, t)
            } else if (o) {
                i.__webglDepthbuffer = [];
                for (let r = 0; r < 6; r++)
                    n.bindFramebuffer(36160, i.__webglFramebuffer[r]),
                    i.__webglDepthbuffer[r] = e.createRenderbuffer(),
                    Z(i.__webglDepthbuffer[r], t, !1)
            } else
                n.bindFramebuffer(36160, i.__webglFramebuffer),
                i.__webglDepthbuffer = e.createRenderbuffer(),
                Z(i.__webglDepthbuffer, t, !1);
            n.bindFramebuffer(36160, null)
        }
        function J(e) {
            return s && e.isWebGLMultisampleRenderTarget ? Math.min(v, e.samples) : 0
        }
        let Q = !1
          , K = !1;
        this.allocateTextureUnit = function() {
            const e = U;
            return e >= c && console.warn("THREE.WebGLTextures: Trying to use " + e + " texture units while this GPU supports only " + c),
            U += 1,
            e
        }
        ,
        this.resetTextureUnits = function() {
            U = 0
        }
        ,
        this.setTexture2D = H,
        this.setTexture2DArray = function(e, t) {
            const i = r.get(e);
            e.version > 0 && i.__version !== e.version ? X(i, e, t) : (n.activeTexture(33984 + t),
            n.bindTexture(35866, i.__webglTexture))
        }
        ,
        this.setTexture3D = function(e, t) {
            const i = r.get(e);
            e.version > 0 && i.__version !== e.version ? X(i, e, t) : (n.activeTexture(33984 + t),
            n.bindTexture(32879, i.__webglTexture))
        }
        ,
        this.setTextureCube = j,
        this.setupRenderTarget = function(t) {
            const i = t.texture
              , c = r.get(t)
              , l = r.get(i);
            t.addEventListener("dispose", B),
            l.__webglTexture = e.createTexture(),
            l.__version = i.version,
            a.memory.textures++;
            const u = !0 === t.isWebGLCubeRenderTarget
              , h = !0 === t.isWebGLMultisampleRenderTarget
              , d = i.isDataTexture3D || i.isDataTexture2DArray
              , p = D(t) || s;
            if (!s || i.format !== M || i.type !== x && i.type !== _ || (i.format = E,
            console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),
            u) {
                c.__webglFramebuffer = [];
                for (let t = 0; t < 6; t++)
                    c.__webglFramebuffer[t] = e.createFramebuffer()
            } else if (c.__webglFramebuffer = e.createFramebuffer(),
            h)
                if (s) {
                    c.__webglMultisampledFramebuffer = e.createFramebuffer(),
                    c.__webglColorRenderbuffer = e.createRenderbuffer(),
                    e.bindRenderbuffer(36161, c.__webglColorRenderbuffer);
                    const r = o.convert(i.format)
                      , a = o.convert(i.type)
                      , s = k(i.internalFormat, r, a)
                      , l = J(t);
                    e.renderbufferStorageMultisample(36161, l, s, t.width, t.height),
                    n.bindFramebuffer(36160, c.__webglMultisampledFramebuffer),
                    e.framebufferRenderbuffer(36160, 36064, 36161, c.__webglColorRenderbuffer),
                    e.bindRenderbuffer(36161, null),
                    t.depthBuffer && (c.__webglDepthRenderbuffer = e.createRenderbuffer(),
                    Z(c.__webglDepthRenderbuffer, t, !0)),
                    n.bindFramebuffer(36160, null)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (u) {
                n.bindTexture(34067, l.__webglTexture),
                W(34067, i, p);
                for (let e = 0; e < 6; e++)
                    Y(c.__webglFramebuffer[e], t, 36064, 34069 + e);
                O(i, p) && N(34067, i, t.width, t.height),
                n.bindTexture(34067, null)
            } else {
                let e = 3553;
                if (d)
                    if (s) {
                        e = i.isDataTexture3D ? 32879 : 35866
                    } else
                        console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
                n.bindTexture(e, l.__webglTexture),
                W(e, i, p),
                Y(c.__webglFramebuffer, t, 36064, e),
                O(i, p) && N(3553, i, t.width, t.height),
                n.bindTexture(3553, null)
            }
            t.depthBuffer && $(t)
        }
        ,
        this.updateRenderTargetMipmap = function(e) {
            const t = e.texture;
            if (O(t, D(e) || s)) {
                const i = e.isWebGLCubeRenderTarget ? 34067 : 3553
                  , o = r.get(t).__webglTexture;
                n.bindTexture(i, o),
                N(i, t, e.width, e.height),
                n.bindTexture(i, null)
            }
        }
        ,
        this.updateMultisampleRenderTarget = function(t) {
            if (t.isWebGLMultisampleRenderTarget)
                if (s) {
                    const i = r.get(t);
                    n.bindFramebuffer(36008, i.__webglMultisampledFramebuffer),
                    n.bindFramebuffer(36009, i.__webglFramebuffer);
                    const o = t.width
                      , a = t.height;
                    let s = 16384;
                    t.depthBuffer && (s |= 256),
                    t.stencilBuffer && (s |= 1024),
                    e.blitFramebuffer(0, 0, o, a, 0, 0, o, a, s, 9728),
                    n.bindFramebuffer(36160, i.__webglMultisampledFramebuffer)
                } else
                    console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }
        ,
        this.safeSetTexture2D = function(e, t) {
            e && e.isWebGLRenderTarget && (!1 === Q && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),
            Q = !0),
            e = e.texture),
            H(e, t)
        }
        ,
        this.safeSetTextureCube = function(e, t) {
            e && e.isWebGLCubeRenderTarget && (!1 === K && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),
            K = !0),
            e = e.texture),
            j(e, t)
        }
    }
    function Ci(e, t, n) {
        const r = n.isWebGL2;
        return {
            convert: function(e) {
                let n;
                if (e === v)
                    return 5121;
                if (1017 === e)
                    return 32819;
                if (1018 === e)
                    return 32820;
                if (1019 === e)
                    return 33635;
                if (1010 === e)
                    return 5120;
                if (1011 === e)
                    return 5122;
                if (e === y)
                    return 5123;
                if (1013 === e)
                    return 5124;
                if (e === b)
                    return 5125;
                if (e === x)
                    return 5126;
                if (e === _)
                    return r ? 5131 : (n = t.get("OES_texture_half_float"),
                    null !== n ? n.HALF_FLOAT_OES : null);
                if (1021 === e)
                    return 6406;
                if (e === M)
                    return 6407;
                if (e === E)
                    return 6408;
                if (1024 === e)
                    return 6409;
                if (1025 === e)
                    return 6410;
                if (e === S)
                    return 6402;
                if (e === T)
                    return 34041;
                if (1028 === e)
                    return 6403;
                if (1029 === e)
                    return 36244;
                if (1030 === e)
                    return 33319;
                if (1031 === e)
                    return 33320;
                if (1032 === e)
                    return 36248;
                if (1033 === e)
                    return 36249;
                if (33776 === e || 33777 === e || 33778 === e || 33779 === e) {
                    if (n = t.get("WEBGL_compressed_texture_s3tc"),
                    null === n)
                        return null;
                    if (33776 === e)
                        return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === e)
                        return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === e)
                        return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === e)
                        return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if (35840 === e || 35841 === e || 35842 === e || 35843 === e) {
                    if (n = t.get("WEBGL_compressed_texture_pvrtc"),
                    null === n)
                        return null;
                    if (35840 === e)
                        return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === e)
                        return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === e)
                        return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === e)
                        return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === e)
                    return n = t.get("WEBGL_compressed_texture_etc1"),
                    null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
                if ((37492 === e || 37496 === e) && (n = t.get("WEBGL_compressed_texture_etc"),
                null !== n)) {
                    if (37492 === e)
                        return n.COMPRESSED_RGB8_ETC2;
                    if (37496 === e)
                        return n.COMPRESSED_RGBA8_ETC2_EAC
                }
                return 37808 === e || 37809 === e || 37810 === e || 37811 === e || 37812 === e || 37813 === e || 37814 === e || 37815 === e || 37816 === e || 37817 === e || 37818 === e || 37819 === e || 37820 === e || 37821 === e || 37840 === e || 37841 === e || 37842 === e || 37843 === e || 37844 === e || 37845 === e || 37846 === e || 37847 === e || 37848 === e || 37849 === e || 37850 === e || 37851 === e || 37852 === e || 37853 === e ? (n = t.get("WEBGL_compressed_texture_astc"),
                null !== n ? e : null) : 36492 === e ? (n = t.get("EXT_texture_compression_bptc"),
                null !== n ? e : null) : e === w ? r ? 34042 : (n = t.get("WEBGL_depth_texture"),
                null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
            }
        }
    }
    class Ri extends fn {
        constructor(e=[]) {
            super(),
            this.cameras = e
        }
    }
    Ri.prototype.isArrayCamera = !0;
    class Di extends Ye {
        constructor() {
            super(),
            this.type = "Group"
        }
    }
    function Oi() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    function Ni(e, t) {
        const n = this
          , r = e.state;
        let i = null
          , o = 1
          , a = null
          , s = "local-floor"
          , c = null;
        const l = []
          , u = new Map
          , h = new fn;
        h.layers.enable(1),
        h.viewport = new G;
        const d = new fn;
        d.layers.enable(2),
        d.viewport = new G;
        const p = [h, d]
          , f = new Ri;
        f.layers.enable(1),
        f.layers.enable(2);
        let m = null
          , g = null;
        function v(e) {
            const t = u.get(e.inputSource);
            t && t.dispatchEvent({
                type: e.type,
                data: e.inputSource
            })
        }
        function y() {
            u.forEach((function(e, t) {
                e.disconnect(t)
            }
            )),
            u.clear(),
            m = null,
            g = null,
            r.bindXRFramebuffer(null),
            e.setRenderTarget(e.getRenderTarget()),
            E.stop(),
            n.isPresenting = !1,
            n.dispatchEvent({
                type: "sessionend"
            })
        }
        function b(e) {
            const t = i.inputSources;
            for (let e = 0; e < l.length; e++)
                u.set(t[e], l[e]);
            for (let t = 0; t < e.removed.length; t++) {
                const n = e.removed[t]
                  , r = u.get(n);
                r && (r.dispatchEvent({
                    type: "disconnected",
                    data: n
                }),
                u.delete(n))
            }
            for (let t = 0; t < e.added.length; t++) {
                const n = e.added[t]
                  , r = u.get(n);
                r && r.dispatchEvent({
                    type: "connected",
                    data: n
                })
            }
        }
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(e) {
            let t = l[e];
            return void 0 === t && (t = new Oi,
            l[e] = t),
            t.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(e) {
            let t = l[e];
            return void 0 === t && (t = new Oi,
            l[e] = t),
            t.getGripSpace()
        }
        ,
        this.getHand = function(e) {
            let t = l[e];
            return void 0 === t && (t = new Oi,
            l[e] = t),
            t.getHandSpace()
        }
        ,
        this.setFramebufferScaleFactor = function(e) {
            o = e,
            !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(e) {
            s = e,
            !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return a
        }
        ,
        this.getSession = function() {
            return i
        }
        ,
        this.setSession = async function(e) {
            if (i = e,
            null !== i) {
                i.addEventListener("select", v),
                i.addEventListener("selectstart", v),
                i.addEventListener("selectend", v),
                i.addEventListener("squeeze", v),
                i.addEventListener("squeezestart", v),
                i.addEventListener("squeezeend", v),
                i.addEventListener("end", y),
                i.addEventListener("inputsourceschange", b);
                const e = t.getContextAttributes();
                !0 !== e.xrCompatible && await t.makeXRCompatible();
                const r = {
                    antialias: e.antialias,
                    alpha: e.alpha,
                    depth: e.depth,
                    stencil: e.stencil,
                    framebufferScaleFactor: o
                }
                  , c = new XRWebGLLayer(i,t,r);
                i.updateRenderState({
                    baseLayer: c
                }),
                a = await i.requestReferenceSpace(s),
                E.setContext(i),
                E.start(),
                n.isPresenting = !0,
                n.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ;
        const x = new q
          , _ = new q;
        function w(e, t) {
            null === t ? e.matrixWorld.copy(e.matrix) : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
            e.matrixWorldInverse.copy(e.matrixWorld).invert()
        }
        this.getCamera = function(e) {
            f.near = d.near = h.near = e.near,
            f.far = d.far = h.far = e.far,
            m === f.near && g === f.far || (i.updateRenderState({
                depthNear: f.near,
                depthFar: f.far
            }),
            m = f.near,
            g = f.far);
            const t = e.parent
              , n = f.cameras;
            w(f, t);
            for (let e = 0; e < n.length; e++)
                w(n[e], t);
            e.matrixWorld.copy(f.matrixWorld),
            e.matrix.copy(f.matrix),
            e.matrix.decompose(e.position, e.quaternion, e.scale);
            const r = e.children;
            for (let e = 0, t = r.length; e < t; e++)
                r[e].updateMatrixWorld(!0);
            return 2 === n.length ? function(e, t, n) {
                x.setFromMatrixPosition(t.matrixWorld),
                _.setFromMatrixPosition(n.matrixWorld);
                const r = x.distanceTo(_)
                  , i = t.projectionMatrix.elements
                  , o = n.projectionMatrix.elements
                  , a = i[14] / (i[10] - 1)
                  , s = i[14] / (i[10] + 1)
                  , c = (i[9] + 1) / i[5]
                  , l = (i[9] - 1) / i[5]
                  , u = (i[8] - 1) / i[0]
                  , h = (o[8] + 1) / o[0]
                  , d = a * u
                  , p = a * h
                  , f = r / (-u + h)
                  , m = f * -u;
                t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                e.translateX(m),
                e.translateZ(f),
                e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                e.matrixWorldInverse.copy(e.matrixWorld).invert();
                const g = a + f
                  , v = s + f
                  , y = d - m
                  , b = p + (r - m)
                  , w = c * s / v * g
                  , M = l * s / v * g;
                e.projectionMatrix.makePerspective(y, b, w, M, g, v)
            }(f, h, d) : f.projectionMatrix.copy(h.projectionMatrix),
            f
        }
        ;
        let M = null;
        const E = new Mn;
        E.setAnimationLoop((function(e, t) {
            if (c = t.getViewerPose(a),
            null !== c) {
                const e = c.views
                  , t = i.renderState.baseLayer;
                r.bindXRFramebuffer(t.framebuffer);
                let n = !1;
                e.length !== f.cameras.length && (f.cameras.length = 0,
                n = !0);
                for (let r = 0; r < e.length; r++) {
                    const i = e[r]
                      , o = t.getViewport(i)
                      , a = p[r];
                    a.matrix.fromArray(i.transform.matrix),
                    a.projectionMatrix.fromArray(i.projectionMatrix),
                    a.viewport.set(o.x, o.y, o.width, o.height),
                    0 === r && f.matrix.copy(a.matrix),
                    !0 === n && f.cameras.push(a)
                }
            }
            const n = i.inputSources;
            for (let e = 0; e < l.length; e++) {
                const r = l[e]
                  , i = n[e];
                r.update(i, t, a)
            }
            M && M(e, t)
        }
        )),
        this.setAnimationLoop = function(e) {
            M = e
        }
        ,
        this.dispose = function() {}
    }
    function Ii(e) {
        function t(t, n) {
            t.opacity.value = n.opacity,
            n.color && t.diffuse.value.copy(n.color),
            n.emissive && t.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
            n.map && (t.map.value = n.map),
            n.alphaMap && (t.alphaMap.value = n.alphaMap),
            n.specularMap && (t.specularMap.value = n.specularMap);
            const r = e.get(n).envMap;
            if (r) {
                t.envMap.value = r,
                t.flipEnvMap.value = r.isCubeTexture && r._needsFlipEnvMap ? -1 : 1,
                t.reflectivity.value = n.reflectivity,
                t.refractionRatio.value = n.refractionRatio;
                const i = e.get(r).__maxMipLevel;
                void 0 !== i && (t.maxMipLevel.value = i)
            }
            let i, o;
            n.lightMap && (t.lightMap.value = n.lightMap,
            t.lightMapIntensity.value = n.lightMapIntensity),
            n.aoMap && (t.aoMap.value = n.aoMap,
            t.aoMapIntensity.value = n.aoMapIntensity),
            n.map ? i = n.map : n.specularMap ? i = n.specularMap : n.displacementMap ? i = n.displacementMap : n.normalMap ? i = n.normalMap : n.bumpMap ? i = n.bumpMap : n.roughnessMap ? i = n.roughnessMap : n.metalnessMap ? i = n.metalnessMap : n.alphaMap ? i = n.alphaMap : n.emissiveMap ? i = n.emissiveMap : n.clearcoatMap ? i = n.clearcoatMap : n.clearcoatNormalMap ? i = n.clearcoatNormalMap : n.clearcoatRoughnessMap && (i = n.clearcoatRoughnessMap),
            void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture),
            !0 === i.matrixAutoUpdate && i.updateMatrix(),
            t.uvTransform.value.copy(i.matrix)),
            n.aoMap ? o = n.aoMap : n.lightMap && (o = n.lightMap),
            void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture),
            !0 === o.matrixAutoUpdate && o.updateMatrix(),
            t.uv2Transform.value.copy(o.matrix))
        }
        function n(t, n) {
            t.roughness.value = n.roughness,
            t.metalness.value = n.metalness,
            n.roughnessMap && (t.roughnessMap.value = n.roughnessMap),
            n.metalnessMap && (t.metalnessMap.value = n.metalnessMap),
            n.emissiveMap && (t.emissiveMap.value = n.emissiveMap),
            n.bumpMap && (t.bumpMap.value = n.bumpMap,
            t.bumpScale.value = n.bumpScale,
            1 === n.side && (t.bumpScale.value *= -1)),
            n.normalMap && (t.normalMap.value = n.normalMap,
            t.normalScale.value.copy(n.normalScale),
            1 === n.side && t.normalScale.value.negate()),
            n.displacementMap && (t.displacementMap.value = n.displacementMap,
            t.displacementScale.value = n.displacementScale,
            t.displacementBias.value = n.displacementBias);
            e.get(n).envMap && (t.envMapIntensity.value = n.envMapIntensity)
        }
        return {
            refreshFogUniforms: function(e, t) {
                e.fogColor.value.copy(t.color),
                t.isFog ? (e.fogNear.value = t.near,
                e.fogFar.value = t.far) : t.isFogExp2 && (e.fogDensity.value = t.density)
            },
            refreshMaterialUniforms: function(e, r, i, o) {
                r.isMeshBasicMaterial ? t(e, r) : r.isMeshLambertMaterial ? (t(e, r),
                function(e, t) {
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap)
                }(e, r)) : r.isMeshToonMaterial ? (t(e, r),
                function(e, t) {
                    t.gradientMap && (e.gradientMap.value = t.gradientMap);
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap,
                    e.bumpScale.value = t.bumpScale,
                    1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap,
                    e.normalScale.value.copy(t.normalScale),
                    1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap,
                    e.displacementScale.value = t.displacementScale,
                    e.displacementBias.value = t.displacementBias)
                }(e, r)) : r.isMeshPhongMaterial ? (t(e, r),
                function(e, t) {
                    e.specular.value.copy(t.specular),
                    e.shininess.value = Math.max(t.shininess, 1e-4),
                    t.emissiveMap && (e.emissiveMap.value = t.emissiveMap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap,
                    e.bumpScale.value = t.bumpScale,
                    1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap,
                    e.normalScale.value.copy(t.normalScale),
                    1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap,
                    e.displacementScale.value = t.displacementScale,
                    e.displacementBias.value = t.displacementBias)
                }(e, r)) : r.isMeshStandardMaterial ? (t(e, r),
                r.isMeshPhysicalMaterial ? function(e, t) {
                    n(e, t),
                    e.reflectivity.value = t.reflectivity,
                    e.clearcoat.value = t.clearcoat,
                    e.clearcoatRoughness.value = t.clearcoatRoughness,
                    t.sheen && e.sheen.value.copy(t.sheen);
                    t.clearcoatMap && (e.clearcoatMap.value = t.clearcoatMap);
                    t.clearcoatRoughnessMap && (e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap);
                    t.clearcoatNormalMap && (e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                    e.clearcoatNormalMap.value = t.clearcoatNormalMap,
                    1 === t.side && e.clearcoatNormalScale.value.negate());
                    e.transmission.value = t.transmission,
                    t.transmissionMap && (e.transmissionMap.value = t.transmissionMap)
                }(e, r) : n(e, r)) : r.isMeshMatcapMaterial ? (t(e, r),
                function(e, t) {
                    t.matcap && (e.matcap.value = t.matcap);
                    t.bumpMap && (e.bumpMap.value = t.bumpMap,
                    e.bumpScale.value = t.bumpScale,
                    1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap,
                    e.normalScale.value.copy(t.normalScale),
                    1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap,
                    e.displacementScale.value = t.displacementScale,
                    e.displacementBias.value = t.displacementBias)
                }(e, r)) : r.isMeshDepthMaterial ? (t(e, r),
                function(e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap,
                    e.displacementScale.value = t.displacementScale,
                    e.displacementBias.value = t.displacementBias)
                }(e, r)) : r.isMeshDistanceMaterial ? (t(e, r),
                function(e, t) {
                    t.displacementMap && (e.displacementMap.value = t.displacementMap,
                    e.displacementScale.value = t.displacementScale,
                    e.displacementBias.value = t.displacementBias);
                    e.referencePosition.value.copy(t.referencePosition),
                    e.nearDistance.value = t.nearDistance,
                    e.farDistance.value = t.farDistance
                }(e, r)) : r.isMeshNormalMaterial ? (t(e, r),
                function(e, t) {
                    t.bumpMap && (e.bumpMap.value = t.bumpMap,
                    e.bumpScale.value = t.bumpScale,
                    1 === t.side && (e.bumpScale.value *= -1));
                    t.normalMap && (e.normalMap.value = t.normalMap,
                    e.normalScale.value.copy(t.normalScale),
                    1 === t.side && e.normalScale.value.negate());
                    t.displacementMap && (e.displacementMap.value = t.displacementMap,
                    e.displacementScale.value = t.displacementScale,
                    e.displacementBias.value = t.displacementBias)
                }(e, r)) : r.isLineBasicMaterial ? (function(e, t) {
                    e.diffuse.value.copy(t.color),
                    e.opacity.value = t.opacity
                }(e, r),
                r.isLineDashedMaterial && function(e, t) {
                    e.dashSize.value = t.dashSize,
                    e.totalSize.value = t.dashSize + t.gapSize,
                    e.scale.value = t.scale
                }(e, r)) : r.isPointsMaterial ? function(e, t, n, r) {
                    e.diffuse.value.copy(t.color),
                    e.opacity.value = t.opacity,
                    e.size.value = t.size * n,
                    e.scale.value = .5 * r,
                    t.map && (e.map.value = t.map);
                    t.alphaMap && (e.alphaMap.value = t.alphaMap);
                    let i;
                    t.map ? i = t.map : t.alphaMap && (i = t.alphaMap);
                    void 0 !== i && (!0 === i.matrixAutoUpdate && i.updateMatrix(),
                    e.uvTransform.value.copy(i.matrix))
                }(e, r, i, o) : r.isSpriteMaterial ? function(e, t) {
                    e.diffuse.value.copy(t.color),
                    e.opacity.value = t.opacity,
                    e.rotation.value = t.rotation,
                    t.map && (e.map.value = t.map);
                    t.alphaMap && (e.alphaMap.value = t.alphaMap);
                    let n;
                    t.map ? n = t.map : t.alphaMap && (n = t.alphaMap);
                    void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(),
                    e.uvTransform.value.copy(n.matrix))
                }(e, r) : r.isShadowMaterial ? (e.color.value.copy(r.color),
                e.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
            }
        }
    }
    function ki(e) {
        const t = void 0 !== (e = e || {}).canvas ? e.canvas : function() {
            const e = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
            return e.style.display = "block",
            e
        }()
          , n = void 0 !== e.context ? e.context : null
          , r = void 0 !== e.alpha && e.alpha
          , i = void 0 === e.depth || e.depth
          , o = void 0 === e.stencil || e.stencil
          , a = void 0 !== e.antialias && e.antialias
          , s = void 0 === e.premultipliedAlpha || e.premultipliedAlpha
          , c = void 0 !== e.preserveDrawingBuffer && e.preserveDrawingBuffer
          , l = void 0 !== e.powerPreference ? e.powerPreference : "default"
          , u = void 0 !== e.failIfMajorPerformanceCaveat && e.failIfMajorPerformanceCaveat;
        let h = null
          , d = null;
        const p = []
          , f = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this.gammaFactor = 2,
        this.outputEncoding = L,
        this.physicallyCorrectLights = !1,
        this.toneMapping = 0,
        this.toneMappingExposure = 1;
        const m = this;
        let g = !1
          , y = 0
          , b = 0
          , w = null
          , M = -1
          , S = null;
        const T = new G
          , A = new G;
        let P = null
          , C = t.width
          , R = t.height
          , D = 1
          , O = null
          , N = null;
        const z = new G(0,0,C,R)
          , F = new G(0,0,C,R);
        let B = !1;
        const U = new wn;
        let H = !1
          , j = !1;
        const V = new Me
          , W = new q
          , X = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        function Y() {
            return null === w ? D : 1
        }
        let Z, $, J, Q, K, ee, te, ne, re, ie, oe, ae, se, ce, le, ue, he, de, pe, fe, me, ge, ve = n;
        function ye(e, n) {
            for (let r = 0; r < e.length; r++) {
                const i = e[r]
                  , o = t.getContext(i, n);
                if (null !== o)
                    return o
            }
            return null
        }
        try {
            const e = {
                alpha: r,
                depth: i,
                stencil: o,
                antialias: a,
                premultipliedAlpha: s,
                preserveDrawingBuffer: c,
                powerPreference: l,
                failIfMajorPerformanceCaveat: u
            };
            if (t.addEventListener("webglcontextlost", _e, !1),
            t.addEventListener("webglcontextrestored", we, !1),
            null === ve) {
                const t = ["webgl2", "webgl", "experimental-webgl"];
                if (!0 === m.isWebGL1Renderer && t.shift(),
                ve = ye(t, e),
                null === ve)
                    throw ye(t) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
            void 0 === ve.getShaderPrecisionFormat && (ve.getShaderPrecisionFormat = function() {
                return {
                    rangeMin: 1,
                    rangeMax: 1,
                    precision: 1
                }
            }
            )
        } catch (e) {
            throw console.error("THREE.WebGLRenderer: " + e.message),
            e
        }
        function be() {
            Z = new In(ve),
            $ = new Dn(ve,Z,e),
            Z.init($),
            me = new Ci(ve,Z,$),
            J = new Ai(ve,Z,$),
            Q = new Fn(ve),
            K = new fi,
            ee = new Pi(ve,Z,J,K,$,me,Q),
            te = new Nn(m),
            ne = new En(ve,$),
            ge = new Cn(ve,Z,ne,$),
            re = new kn(ve,ne,Q,ge),
            ie = new jn(ve,re,ne,Q),
            de = new Hn(ve),
            le = new On(K),
            oe = new pi(m,te,Z,$,ge,le),
            ae = new Ii(K),
            se = new yi(K),
            ce = new Ei(Z,$),
            he = new Pn(m,te,J,ie,s),
            ue = new Li(m,ie,$),
            pe = new Rn(ve,Z,Q,$),
            fe = new zn(ve,Z,Q,$),
            Q.programs = oe.programs,
            m.capabilities = $,
            m.extensions = Z,
            m.properties = K,
            m.renderLists = se,
            m.shadowMap = ue,
            m.state = J,
            m.info = Q
        }
        be();
        const xe = new Ni(m,ve);
        function _e(e) {
            e.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            g = !0
        }
        function we() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            g = !1;
            const e = Q.autoReset
              , t = ue.enabled
              , n = ue.autoUpdate
              , r = ue.needsUpdate
              , i = ue.type;
            be(),
            Q.autoReset = e,
            ue.enabled = t,
            ue.autoUpdate = n,
            ue.needsUpdate = r,
            ue.type = i
        }
        function Ee(e) {
            const t = e.target;
            t.removeEventListener("dispose", Ee),
            function(e) {
                (function(e) {
                    const t = K.get(e).programs;
                    void 0 !== t && t.forEach((function(e) {
                        oe.releaseProgram(e)
                    }
                    ))
                }
                )(e),
                K.remove(e)
            }(t)
        }
        this.xr = xe,
        this.getContext = function() {
            return ve
        }
        ,
        this.getContextAttributes = function() {
            return ve.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const e = Z.get("WEBGL_lose_context");
            e && e.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const e = Z.get("WEBGL_lose_context");
            e && e.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return D
        }
        ,
        this.setPixelRatio = function(e) {
            void 0 !== e && (D = e,
            this.setSize(C, R, !1))
        }
        ,
        this.getSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),
            e = new k),
            e.set(C, R)
        }
        ,
        this.setSize = function(e, n, r) {
            xe.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (C = e,
            R = n,
            t.width = Math.floor(e * D),
            t.height = Math.floor(n * D),
            !1 !== r && (t.style.width = e + "px",
            t.style.height = n + "px"),
            this.setViewport(0, 0, e, n))
        }
        ,
        this.getDrawingBufferSize = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),
            e = new k),
            e.set(C * D, R * D).floor()
        }
        ,
        this.setDrawingBufferSize = function(e, n, r) {
            C = e,
            R = n,
            D = r,
            t.width = Math.floor(e * r),
            t.height = Math.floor(n * r),
            this.setViewport(0, 0, e, n)
        }
        ,
        this.getCurrentViewport = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),
            e = new G),
            e.copy(T)
        }
        ,
        this.getViewport = function(e) {
            return e.copy(z)
        }
        ,
        this.setViewport = function(e, t, n, r) {
            e.isVector4 ? z.set(e.x, e.y, e.z, e.w) : z.set(e, t, n, r),
            J.viewport(T.copy(z).multiplyScalar(D).floor())
        }
        ,
        this.getScissor = function(e) {
            return e.copy(F)
        }
        ,
        this.setScissor = function(e, t, n, r) {
            e.isVector4 ? F.set(e.x, e.y, e.z, e.w) : F.set(e, t, n, r),
            J.scissor(A.copy(F).multiplyScalar(D).floor())
        }
        ,
        this.getScissorTest = function() {
            return B
        }
        ,
        this.setScissorTest = function(e) {
            J.setScissorTest(B = e)
        }
        ,
        this.setOpaqueSort = function(e) {
            O = e
        }
        ,
        this.setTransparentSort = function(e) {
            N = e
        }
        ,
        this.getClearColor = function(e) {
            return void 0 === e && (console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),
            e = new yt),
            e.copy(he.getClearColor())
        }
        ,
        this.setClearColor = function() {
            he.setClearColor.apply(he, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return he.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            he.setClearAlpha.apply(he, arguments)
        }
        ,
        this.clear = function(e, t, n) {
            let r = 0;
            (void 0 === e || e) && (r |= 16384),
            (void 0 === t || t) && (r |= 256),
            (void 0 === n || n) && (r |= 1024),
            ve.clear(r)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", _e, !1),
            t.removeEventListener("webglcontextrestored", we, !1),
            se.dispose(),
            ce.dispose(),
            K.dispose(),
            te.dispose(),
            ie.dispose(),
            ge.dispose(),
            xe.dispose(),
            xe.removeEventListener("sessionstart", Te),
            xe.removeEventListener("sessionend", Le),
            Ae.stop()
        }
        ,
        this.renderBufferImmediate = function(e, t) {
            ge.initAttributes();
            const n = K.get(e);
            e.hasPositions && !n.position && (n.position = ve.createBuffer()),
            e.hasNormals && !n.normal && (n.normal = ve.createBuffer()),
            e.hasUvs && !n.uv && (n.uv = ve.createBuffer()),
            e.hasColors && !n.color && (n.color = ve.createBuffer());
            const r = t.getAttributes();
            e.hasPositions && (ve.bindBuffer(34962, n.position),
            ve.bufferData(34962, e.positionArray, 35048),
            ge.enableAttribute(r.position),
            ve.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)),
            e.hasNormals && (ve.bindBuffer(34962, n.normal),
            ve.bufferData(34962, e.normalArray, 35048),
            ge.enableAttribute(r.normal),
            ve.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)),
            e.hasUvs && (ve.bindBuffer(34962, n.uv),
            ve.bufferData(34962, e.uvArray, 35048),
            ge.enableAttribute(r.uv),
            ve.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)),
            e.hasColors && (ve.bindBuffer(34962, n.color),
            ve.bufferData(34962, e.colorArray, 35048),
            ge.enableAttribute(r.color),
            ve.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)),
            ge.disableUnusedAttributes(),
            ve.drawArrays(4, 0, e.count),
            e.count = 0
        }
        ,
        this.renderBufferDirect = function(e, t, n, r, i, o) {
            null === t && (t = X);
            const a = i.isMesh && i.matrixWorld.determinant() < 0
              , s = Ne(e, t, r, i);
            J.setMaterial(r, a);
            let c = n.index;
            const l = n.attributes.position;
            if (null === c) {
                if (void 0 === l || 0 === l.count)
                    return
            } else if (0 === c.count)
                return;
            let u, h = 1;
            !0 === r.wireframe && (c = re.getWireframeAttribute(n),
            h = 2),
            (r.morphTargets || r.morphNormals) && de.update(i, n, r, s),
            ge.setup(i, r, s, n, c);
            let d = pe;
            null !== c && (u = ne.get(c),
            d = fe,
            d.setIndex(u));
            const p = null !== c ? c.count : l.count
              , f = n.drawRange.start * h
              , m = n.drawRange.count * h
              , g = null !== o ? o.start * h : 0
              , v = null !== o ? o.count * h : 1 / 0
              , y = Math.max(f, g)
              , b = Math.min(p, f + m, g + v) - 1
              , x = Math.max(0, b - y + 1);
            if (0 !== x) {
                if (i.isMesh)
                    !0 === r.wireframe ? (J.setLineWidth(r.wireframeLinewidth * Y()),
                    d.setMode(1)) : d.setMode(4);
                else if (i.isLine) {
                    let e = r.linewidth;
                    void 0 === e && (e = 1),
                    J.setLineWidth(e * Y()),
                    i.isLineSegments ? d.setMode(1) : i.isLineLoop ? d.setMode(2) : d.setMode(3)
                } else
                    i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4);
                if (i.isInstancedMesh)
                    d.renderInstances(y, x, i.count);
                else if (n.isInstancedBufferGeometry) {
                    const e = Math.min(n.instanceCount, n._maxInstanceCount);
                    d.renderInstances(y, x, e)
                } else
                    d.render(y, x)
            }
        }
        ,
        this.compile = function(e, t) {
            d = ce.get(e),
            d.init(),
            e.traverseVisible((function(e) {
                e.isLight && e.layers.test(t.layers) && (d.pushLight(e),
                e.castShadow && d.pushShadow(e))
            }
            )),
            d.setupLights(),
            e.traverse((function(t) {
                const n = t.material;
                if (n)
                    if (Array.isArray(n))
                        for (let r = 0; r < n.length; r++) {
                            De(n[r], e, t)
                        }
                    else
                        De(n, e, t)
            }
            ))
        }
        ;
        let Se = null;
        function Te() {
            Ae.stop()
        }
        function Le() {
            Ae.start()
        }
        const Ae = new Mn;
        function Pe(e, t, n, r) {
            if (!1 === e.visible)
                return;
            if (e.layers.test(t.layers))
                if (e.isGroup)
                    n = e.renderOrder;
                else if (e.isLOD)
                    !0 === e.autoUpdate && e.update(t);
                else if (e.isLight)
                    d.pushLight(e),
                    e.castShadow && d.pushShadow(e);
                else if (e.isSprite) {
                    if (!e.frustumCulled || U.intersectsSprite(e)) {
                        r && W.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);
                        const t = ie.update(e)
                          , i = e.material;
                        i.visible && h.push(e, t, i, n, W.z, null)
                    }
                } else if (e.isImmediateRenderObject)
                    r && W.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V),
                    h.push(e, null, e.material, n, W.z, null);
                else if ((e.isMesh || e.isLine || e.isPoints) && (e.isSkinnedMesh && e.skeleton.frame !== Q.render.frame && (e.skeleton.update(),
                e.skeleton.frame = Q.render.frame),
                !e.frustumCulled || U.intersectsObject(e))) {
                    r && W.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);
                    const t = ie.update(e)
                      , i = e.material;
                    if (Array.isArray(i)) {
                        const r = t.groups;
                        for (let o = 0, a = r.length; o < a; o++) {
                            const a = r[o]
                              , s = i[a.materialIndex];
                            s && s.visible && h.push(e, t, s, n, W.z, a)
                        }
                    } else
                        i.visible && h.push(e, t, i, n, W.z, null)
                }
            const i = e.children;
            for (let e = 0, o = i.length; e < o; e++)
                Pe(i[e], t, n, r)
        }
        function Ce(e, t, n) {
            const r = !0 === t.isScene ? t.overrideMaterial : null;
            for (let i = 0, o = e.length; i < o; i++) {
                const o = e[i]
                  , a = o.object
                  , s = o.geometry
                  , c = null === r ? o.material : r
                  , l = o.group;
                if (n.isArrayCamera) {
                    const e = n.cameras;
                    for (let n = 0, r = e.length; n < r; n++) {
                        const r = e[n];
                        a.layers.test(r.layers) && (J.viewport(T.copy(r.viewport)),
                        d.setupLightsView(r),
                        Re(a, t, r, s, c, l))
                    }
                } else
                    Re(a, t, n, s, c, l)
            }
        }
        function Re(e, t, n, r, i, o) {
            if (e.onBeforeRender(m, t, n, r, i, o),
            e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld),
            e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
            e.isImmediateRenderObject) {
                const r = Ne(n, t, i, e);
                J.setMaterial(i),
                ge.reset(),
                function(e, t) {
                    e.render((function(e) {
                        m.renderBufferImmediate(e, t)
                    }
                    ))
                }(e, r)
            } else
                m.renderBufferDirect(n, t, r, i, e, o);
            e.onAfterRender(m, t, n, r, i, o)
        }
        function De(e, t, n) {
            !0 !== t.isScene && (t = X);
            const r = K.get(e)
              , i = d.state.lights
              , o = d.state.shadowsArray
              , a = i.state.version
              , s = oe.getParameters(e, i.state, o, t, n)
              , c = oe.getProgramCacheKey(s);
            let l = r.programs;
            r.environment = e.isMeshStandardMaterial ? t.environment : null,
            r.fog = t.fog,
            r.envMap = te.get(e.envMap || r.environment),
            void 0 === l && (e.addEventListener("dispose", Ee),
            l = new Map,
            r.programs = l);
            let u = l.get(c);
            if (void 0 !== u) {
                if (r.currentProgram === u && r.lightsStateVersion === a)
                    return Oe(e, s),
                    u
            } else
                s.uniforms = oe.getUniforms(e),
                e.onBeforeCompile(s, m),
                u = oe.acquireProgram(s, c),
                l.set(c, u),
                r.uniforms = s.uniforms;
            const h = r.uniforms;
            (e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping || (h.clippingPlanes = le.uniform),
            Oe(e, s),
            r.needsLights = function(e) {
                return e.isMeshLambertMaterial || e.isMeshToonMaterial || e.isMeshPhongMaterial || e.isMeshStandardMaterial || e.isShadowMaterial || e.isShaderMaterial && !0 === e.lights
            }(e),
            r.lightsStateVersion = a,
            r.needsLights && (h.ambientLightColor.value = i.state.ambient,
            h.lightProbe.value = i.state.probe,
            h.directionalLights.value = i.state.directional,
            h.directionalLightShadows.value = i.state.directionalShadow,
            h.spotLights.value = i.state.spot,
            h.spotLightShadows.value = i.state.spotShadow,
            h.rectAreaLights.value = i.state.rectArea,
            h.ltc_1.value = i.state.rectAreaLTC1,
            h.ltc_2.value = i.state.rectAreaLTC2,
            h.pointLights.value = i.state.point,
            h.pointLightShadows.value = i.state.pointShadow,
            h.hemisphereLights.value = i.state.hemi,
            h.directionalShadowMap.value = i.state.directionalShadowMap,
            h.directionalShadowMatrix.value = i.state.directionalShadowMatrix,
            h.spotShadowMap.value = i.state.spotShadowMap,
            h.spotShadowMatrix.value = i.state.spotShadowMatrix,
            h.pointShadowMap.value = i.state.pointShadowMap,
            h.pointShadowMatrix.value = i.state.pointShadowMatrix);
            const p = u.getUniforms()
              , f = qr.seqWithValue(p.seq, h);
            return r.currentProgram = u,
            r.uniformsList = f,
            u
        }
        function Oe(e, t) {
            const n = K.get(e);
            n.outputEncoding = t.outputEncoding,
            n.instancing = t.instancing,
            n.numClippingPlanes = t.numClippingPlanes,
            n.numIntersection = t.numClipIntersection,
            n.vertexAlphas = t.vertexAlphas
        }
        function Ne(e, t, n, r) {
            !0 !== t.isScene && (t = X),
            ee.resetTextureUnits();
            const i = t.fog
              , o = n.isMeshStandardMaterial ? t.environment : null
              , a = null === w ? m.outputEncoding : w.texture.encoding
              , s = te.get(n.envMap || o)
              , c = !0 === n.vertexColors && r.geometry.attributes.color && 4 === r.geometry.attributes.color.itemSize
              , l = K.get(n)
              , u = d.state.lights;
            if (!0 === H && (!0 === j || e !== S)) {
                const t = e === S && n.id === M;
                le.setState(n, e, t)
            }
            let h = !1;
            n.version === l.__version ? l.needsLights && l.lightsStateVersion !== u.state.version || l.outputEncoding !== a || r.isInstancedMesh && !1 === l.instancing ? h = !0 : r.isInstancedMesh || !0 !== l.instancing ? l.envMap !== s || n.fog && l.fog !== i ? h = !0 : void 0 === l.numClippingPlanes || l.numClippingPlanes === le.numPlanes && l.numIntersection === le.numIntersection ? l.vertexAlphas !== c && (h = !0) : h = !0 : h = !0 : (h = !0,
            l.__version = n.version);
            let p = l.currentProgram;
            !0 === h && (p = De(n, t, r));
            let f = !1
              , g = !1
              , v = !1;
            const y = p.getUniforms()
              , b = l.uniforms;
            if (J.useProgram(p.program) && (f = !0,
            g = !0,
            v = !0),
            n.id !== M && (M = n.id,
            g = !0),
            f || S !== e) {
                if (y.setValue(ve, "projectionMatrix", e.projectionMatrix),
                $.logarithmicDepthBuffer && y.setValue(ve, "logDepthBufFC", 2 / (Math.log(e.far + 1) / Math.LN2)),
                S !== e && (S = e,
                g = !0,
                v = !0),
                n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshStandardMaterial || n.envMap) {
                    const t = y.map.cameraPosition;
                    void 0 !== t && t.setValue(ve, W.setFromMatrixPosition(e.matrixWorld))
                }
                (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial) && y.setValue(ve, "isOrthographic", !0 === e.isOrthographicCamera),
                (n.isMeshPhongMaterial || n.isMeshToonMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.isShadowMaterial || n.skinning) && y.setValue(ve, "viewMatrix", e.matrixWorldInverse)
            }
            if (n.skinning) {
                y.setOptional(ve, r, "bindMatrix"),
                y.setOptional(ve, r, "bindMatrixInverse");
                const e = r.skeleton;
                if (e) {
                    const t = e.bones;
                    if ($.floatVertexTextures) {
                        if (null === e.boneTexture) {
                            let n = Math.sqrt(4 * t.length);
                            n = I.ceilPowerOfTwo(n),
                            n = Math.max(n, 4);
                            const r = new Float32Array(n * n * 4);
                            r.set(e.boneMatrices);
                            const i = new bn(r,n,n,E,x);
                            e.boneMatrices = r,
                            e.boneTexture = i,
                            e.boneTextureSize = n
                        }
                        y.setValue(ve, "boneTexture", e.boneTexture, ee),
                        y.setValue(ve, "boneTextureSize", e.boneTextureSize)
                    } else
                        y.setOptional(ve, e, "boneMatrices")
                }
            }
            var _, T;
            return (g || l.receiveShadow !== r.receiveShadow) && (l.receiveShadow = r.receiveShadow,
            y.setValue(ve, "receiveShadow", r.receiveShadow)),
            g && (y.setValue(ve, "toneMappingExposure", m.toneMappingExposure),
            l.needsLights && (T = v,
            (_ = b).ambientLightColor.needsUpdate = T,
            _.lightProbe.needsUpdate = T,
            _.directionalLights.needsUpdate = T,
            _.directionalLightShadows.needsUpdate = T,
            _.pointLights.needsUpdate = T,
            _.pointLightShadows.needsUpdate = T,
            _.spotLights.needsUpdate = T,
            _.spotLightShadows.needsUpdate = T,
            _.rectAreaLights.needsUpdate = T,
            _.hemisphereLights.needsUpdate = T),
            i && n.fog && ae.refreshFogUniforms(b, i),
            ae.refreshMaterialUniforms(b, n, D, R),
            qr.upload(ve, l.uniformsList, b, ee)),
            n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (qr.upload(ve, l.uniformsList, b, ee),
            n.uniformsNeedUpdate = !1),
            n.isSpriteMaterial && y.setValue(ve, "center", r.center),
            y.setValue(ve, "modelViewMatrix", r.modelViewMatrix),
            y.setValue(ve, "normalMatrix", r.normalMatrix),
            y.setValue(ve, "modelMatrix", r.matrixWorld),
            p
        }
        Ae.setAnimationLoop((function(e) {
            Se && Se(e)
        }
        )),
        "undefined" != typeof window && Ae.setContext(window),
        this.setAnimationLoop = function(e) {
            Se = e,
            xe.setAnimationLoop(e),
            null === e ? Ae.stop() : Ae.start()
        }
        ,
        xe.addEventListener("sessionstart", Te),
        xe.addEventListener("sessionend", Le),
        this.render = function(e, t) {
            let n, r;
            if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),
            n = arguments[2]),
            void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),
            r = arguments[3]),
            void 0 !== t && !0 !== t.isCamera)
                return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            if (!0 === g)
                return;
            !0 === e.autoUpdate && e.updateMatrixWorld(),
            null === t.parent && t.updateMatrixWorld(),
            !0 === xe.enabled && !0 === xe.isPresenting && (t = xe.getCamera(t)),
            !0 === e.isScene && e.onBeforeRender(m, e, t, n || w),
            d = ce.get(e, f.length),
            d.init(),
            f.push(d),
            V.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            U.setFromProjectionMatrix(V),
            j = this.localClippingEnabled,
            H = le.init(this.clippingPlanes, j, t),
            h = se.get(e, p.length),
            h.init(),
            p.push(h),
            Pe(e, t, 0, m.sortObjects),
            h.finish(),
            !0 === m.sortObjects && h.sort(O, N),
            !0 === H && le.beginShadows();
            const i = d.state.shadowsArray;
            ue.render(i, e, t),
            d.setupLights(),
            d.setupLightsView(t),
            !0 === H && le.endShadows(),
            !0 === this.info.autoReset && this.info.reset(),
            void 0 !== n && this.setRenderTarget(n),
            he.render(h, e, t, r);
            const o = h.opaque
              , a = h.transparent;
            o.length > 0 && Ce(o, e, t),
            a.length > 0 && Ce(a, e, t),
            null !== w && (ee.updateRenderTargetMipmap(w),
            ee.updateMultisampleRenderTarget(w)),
            !0 === e.isScene && e.onAfterRender(m, e, t),
            J.buffers.depth.setTest(!0),
            J.buffers.depth.setMask(!0),
            J.buffers.color.setMask(!0),
            J.setPolygonOffset(!1),
            ge.resetDefaultState(),
            M = -1,
            S = null,
            f.pop(),
            d = f.length > 0 ? f[f.length - 1] : null,
            p.pop(),
            h = p.length > 0 ? p[p.length - 1] : null
        }
        ,
        this.getActiveCubeFace = function() {
            return y
        }
        ,
        this.getActiveMipmapLevel = function() {
            return b
        }
        ,
        this.getRenderTarget = function() {
            return w
        }
        ,
        this.setRenderTarget = function(e, t=0, n=0) {
            w = e,
            y = t,
            b = n,
            e && void 0 === K.get(e).__webglFramebuffer && ee.setupRenderTarget(e);
            let r = null
              , i = !1
              , o = !1;
            if (e) {
                const n = e.texture;
                (n.isDataTexture3D || n.isDataTexture2DArray) && (o = !0);
                const a = K.get(e).__webglFramebuffer;
                e.isWebGLCubeRenderTarget ? (r = a[t],
                i = !0) : r = e.isWebGLMultisampleRenderTarget ? K.get(e).__webglMultisampledFramebuffer : a,
                T.copy(e.viewport),
                A.copy(e.scissor),
                P = e.scissorTest
            } else
                T.copy(z).multiplyScalar(D).floor(),
                A.copy(F).multiplyScalar(D).floor(),
                P = B;
            if (J.bindFramebuffer(36160, r),
            J.viewport(T),
            J.scissor(A),
            J.setScissorTest(P),
            i) {
                const r = K.get(e.texture);
                ve.framebufferTexture2D(36160, 36064, 34069 + t, r.__webglTexture, n)
            } else if (o) {
                const r = K.get(e.texture)
                  , i = t || 0;
                ve.framebufferTextureLayer(36160, 36064, r.__webglTexture, n || 0, i)
            }
        }
        ,
        this.readRenderTargetPixels = function(e, t, n, r, i, o, a) {
            if (!e || !e.isWebGLRenderTarget)
                return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let s = K.get(e).__webglFramebuffer;
            if (e.isWebGLCubeRenderTarget && void 0 !== a && (s = s[a]),
            s) {
                J.bindFramebuffer(36160, s);
                try {
                    const a = e.texture
                      , s = a.format
                      , c = a.type;
                    if (s !== E && me.convert(s) !== ve.getParameter(35739))
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                    const l = c === _ && (Z.has("EXT_color_buffer_half_float") || $.isWebGL2 && Z.has("EXT_color_buffer_float"));
                    if (!(c === v || me.convert(c) === ve.getParameter(35738) || c === x && ($.isWebGL2 || Z.has("OES_texture_float") || Z.has("WEBGL_color_buffer_float")) || l))
                        return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                    36053 === ve.checkFramebufferStatus(36160) ? t >= 0 && t <= e.width - r && n >= 0 && n <= e.height - i && ve.readPixels(t, n, r, i, me.convert(s), me.convert(c), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                } finally {
                    const e = null !== w ? K.get(w).__webglFramebuffer : null;
                    J.bindFramebuffer(36160, e)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(e, t, n=0) {
            const r = Math.pow(2, -n)
              , i = Math.floor(t.image.width * r)
              , o = Math.floor(t.image.height * r)
              , a = me.convert(t.format);
            ee.setTexture2D(t, 0),
            ve.copyTexImage2D(3553, n, a, e.x, e.y, i, o, 0),
            J.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(e, t, n, r=0) {
            const i = t.image.width
              , o = t.image.height
              , a = me.convert(n.format)
              , s = me.convert(n.type);
            ee.setTexture2D(n, 0),
            ve.pixelStorei(37440, n.flipY),
            ve.pixelStorei(37441, n.premultiplyAlpha),
            ve.pixelStorei(3317, n.unpackAlignment),
            t.isDataTexture ? ve.texSubImage2D(3553, r, e.x, e.y, i, o, a, s, t.image.data) : t.isCompressedTexture ? ve.compressedTexSubImage2D(3553, r, e.x, e.y, t.mipmaps[0].width, t.mipmaps[0].height, a, t.mipmaps[0].data) : ve.texSubImage2D(3553, r, e.x, e.y, a, s, t.image),
            0 === r && n.generateMipmaps && ve.generateMipmap(3553),
            J.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(e, t, n, r, i=0) {
            if (m.isWebGL1Renderer)
                return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
            const {width: o, height: a, data: s} = n.image
              , c = me.convert(r.format)
              , l = me.convert(r.type);
            let u;
            if (r.isDataTexture3D)
                ee.setTexture3D(r, 0),
                u = 32879;
            else {
                if (!r.isDataTexture2DArray)
                    return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                ee.setTexture2DArray(r, 0),
                u = 35866
            }
            ve.pixelStorei(37440, r.flipY),
            ve.pixelStorei(37441, r.premultiplyAlpha),
            ve.pixelStorei(3317, r.unpackAlignment);
            const h = ve.getParameter(3314)
              , d = ve.getParameter(32878)
              , p = ve.getParameter(3316)
              , f = ve.getParameter(3315)
              , g = ve.getParameter(32877);
            ve.pixelStorei(3314, o),
            ve.pixelStorei(32878, a),
            ve.pixelStorei(3316, e.min.x),
            ve.pixelStorei(3315, e.min.y),
            ve.pixelStorei(32877, e.min.z),
            ve.texSubImage3D(u, i, t.x, t.y, t.z, e.max.x - e.min.x + 1, e.max.y - e.min.y + 1, e.max.z - e.min.z + 1, c, l, s),
            ve.pixelStorei(3314, h),
            ve.pixelStorei(32878, d),
            ve.pixelStorei(3316, p),
            ve.pixelStorei(3315, f),
            ve.pixelStorei(32877, g),
            0 === i && r.generateMipmaps && ve.generateMipmap(u),
            J.unbindTexture()
        }
        ,
        this.initTexture = function(e) {
            ee.setTexture2D(e, 0),
            J.unbindTexture()
        }
        ,
        this.resetState = function() {
            y = 0,
            b = 0,
            w = null,
            J.reset(),
            ge.reset()
        }
        ,
        "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    Di.prototype.isGroup = !0,
    Object.assign(Oi.prototype, {
        constructor: Oi,
        getHandSpace: function() {
            return null === this._hand && (this._hand = new Di,
            this._hand.matrixAutoUpdate = !1,
            this._hand.visible = !1,
            this._hand.joints = {},
            this._hand.inputState = {
                pinching: !1
            }),
            this._hand
        },
        getTargetRaySpace: function() {
            return null === this._targetRay && (this._targetRay = new Di,
            this._targetRay.matrixAutoUpdate = !1,
            this._targetRay.visible = !1),
            this._targetRay
        },
        getGripSpace: function() {
            return null === this._grip && (this._grip = new Di,
            this._grip.matrixAutoUpdate = !1,
            this._grip.visible = !1),
            this._grip
        },
        dispatchEvent: function(e) {
            return null !== this._targetRay && this._targetRay.dispatchEvent(e),
            null !== this._grip && this._grip.dispatchEvent(e),
            null !== this._hand && this._hand.dispatchEvent(e),
            this
        },
        disconnect: function(e) {
            return this.dispatchEvent({
                type: "disconnected",
                data: e
            }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
        },
        update: function(e, t, n) {
            let r = null
              , i = null
              , o = null;
            const a = this._targetRay
              , s = this._grip
              , c = this._hand;
            if (e && "visible-blurred" !== t.session.visibilityState)
                if (null !== a && (r = t.getPose(e.targetRaySpace, n),
                null !== r && (a.matrix.fromArray(r.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale))),
                c && e.hand) {
                    o = !0;
                    for (const r of e.hand.values()) {
                        const e = t.getJointPose(r, n);
                        if (void 0 === c.joints[r.jointName]) {
                            const e = new Di;
                            e.matrixAutoUpdate = !1,
                            e.visible = !1,
                            c.joints[r.jointName] = e,
                            c.add(e)
                        }
                        const i = c.joints[r.jointName];
                        null !== e && (i.matrix.fromArray(e.transform.matrix),
                        i.matrix.decompose(i.position, i.rotation, i.scale),
                        i.jointRadius = e.radius),
                        i.visible = null !== e
                    }
                    const r = c.joints["index-finger-tip"]
                      , i = c.joints["thumb-tip"]
                      , a = r.position.distanceTo(i.position)
                      , s = .02
                      , l = .005;
                    c.inputState.pinching && a > s + l ? (c.inputState.pinching = !1,
                    this.dispatchEvent({
                        type: "pinchend",
                        handedness: e.handedness,
                        target: this
                    })) : !c.inputState.pinching && a <= s - l && (c.inputState.pinching = !0,
                    this.dispatchEvent({
                        type: "pinchstart",
                        handedness: e.handedness,
                        target: this
                    }))
                } else
                    null !== s && e.gripSpace && (i = t.getPose(e.gripSpace, n),
                    null !== i && (s.matrix.fromArray(i.transform.matrix),
                    s.matrix.decompose(s.position, s.rotation, s.scale)));
            return null !== a && (a.visible = null !== r),
            null !== s && (s.visible = null !== i),
            null !== c && (c.visible = null !== o),
            this
        }
    }),
    Object.assign(Ni.prototype, D.prototype);
    class zi extends Ye {
        constructor() {
            super(),
            this.type = "Scene",
            this.background = null,
            this.environment = null,
            this.fog = null,
            this.overrideMaterial = null,
            this.autoUpdate = !0,
            "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
                detail: this
            }))
        }
        copy(e, t) {
            return super.copy(e, t),
            null !== e.background && (this.background = e.background.clone()),
            null !== e.environment && (this.environment = e.environment.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
            this.autoUpdate = e.autoUpdate,
            this.matrixAutoUpdate = e.matrixAutoUpdate,
            this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return null !== this.background && (t.object.background = this.background.toJSON(e)),
            null !== this.environment && (t.object.environment = this.environment.toJSON(e)),
            null !== this.fog && (t.object.fog = this.fog.toJSON()),
            t
        }
    }
    function Fi(e, t) {
        this.array = e,
        this.stride = t,
        this.count = void 0 !== e ? e.length / t : 0,
        this.usage = P,
        this.updateRange = {
            offset: 0,
            count: -1
        },
        this.version = 0,
        this.uuid = I.generateUUID()
    }
    zi.prototype.isScene = !0,
    Object.defineProperty(Fi.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(Fi.prototype, {
        isInterleavedBuffer: !0,
        onUploadCallback: function() {},
        setUsage: function(e) {
            return this.usage = e,
            this
        },
        copy: function(e) {
            return this.array = new e.array.constructor(e.array),
            this.count = e.count,
            this.stride = e.stride,
            this.usage = e.usage,
            this
        },
        copyAt: function(e, t, n) {
            e *= this.stride,
            n *= t.stride;
            for (let r = 0, i = this.stride; r < i; r++)
                this.array[e + r] = t.array[n + r];
            return this
        },
        set: function(e, t=0) {
            return this.array.set(e, t),
            this
        },
        clone: function(e) {
            void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = I.generateUUID()),
            void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
            const t = new Fi(new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),this.stride);
            return t.setUsage(this.usage),
            t
        },
        onUpload: function(e) {
            return this.onUploadCallback = e,
            this
        },
        toJSON: function(e) {
            return void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = I.generateUUID()),
            void 0 === e.arrayBuffers[this.array.buffer._uuid] && (e.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))),
            {
                uuid: this.uuid,
                buffer: this.array.buffer._uuid,
                type: this.array.constructor.name,
                stride: this.stride
            }
        }
    });
    const Bi = new q;
    function Ui(e, t, n, r) {
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = n,
        this.normalized = !0 === r
    }
    Object.defineProperties(Ui.prototype, {
        count: {
            get: function() {
                return this.data.count
            }
        },
        array: {
            get: function() {
                return this.data.array
            }
        },
        needsUpdate: {
            set: function(e) {
                this.data.needsUpdate = e
            }
        }
    }),
    Object.assign(Ui.prototype, {
        isInterleavedBufferAttribute: !0,
        applyMatrix4: function(e) {
            for (let t = 0, n = this.data.count; t < n; t++)
                Bi.x = this.getX(t),
                Bi.y = this.getY(t),
                Bi.z = this.getZ(t),
                Bi.applyMatrix4(e),
                this.setXYZ(t, Bi.x, Bi.y, Bi.z);
            return this
        },
        applyNormalMatrix: function(e) {
            for (let t = 0, n = this.count; t < n; t++)
                Bi.x = this.getX(t),
                Bi.y = this.getY(t),
                Bi.z = this.getZ(t),
                Bi.applyNormalMatrix(e),
                this.setXYZ(t, Bi.x, Bi.y, Bi.z);
            return this
        },
        transformDirection: function(e) {
            for (let t = 0, n = this.count; t < n; t++)
                Bi.x = this.getX(t),
                Bi.y = this.getY(t),
                Bi.z = this.getZ(t),
                Bi.transformDirection(e),
                this.setXYZ(t, Bi.x, Bi.y, Bi.z);
            return this
        },
        setX: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset] = t,
            this
        },
        setY: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 1] = t,
            this
        },
        setZ: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 2] = t,
            this
        },
        setW: function(e, t) {
            return this.data.array[e * this.data.stride + this.offset + 3] = t,
            this
        },
        getX: function(e) {
            return this.data.array[e * this.data.stride + this.offset]
        },
        getY: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 1]
        },
        getZ: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 2]
        },
        getW: function(e) {
            return this.data.array[e * this.data.stride + this.offset + 3]
        },
        setXY: function(e, t, n) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = n,
            this
        },
        setXYZ: function(e, t, n, r) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = n,
            this.data.array[e + 2] = r,
            this
        },
        setXYZW: function(e, t, n, r, i) {
            return e = e * this.data.stride + this.offset,
            this.data.array[e + 0] = t,
            this.data.array[e + 1] = n,
            this.data.array[e + 2] = r,
            this.data.array[e + 3] = i,
            this
        },
        clone: function(e) {
            if (void 0 === e) {
                console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
                const e = [];
                for (let t = 0; t < this.count; t++) {
                    const n = t * this.data.stride + this.offset;
                    for (let t = 0; t < this.itemSize; t++)
                        e.push(this.data.array[n + t])
                }
                return new wt(new this.array.constructor(e),this.itemSize,this.normalized)
            }
            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
            void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new Ui(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
        },
        toJSON: function(e) {
            if (void 0 === e) {
                console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
                const e = [];
                for (let t = 0; t < this.count; t++) {
                    const n = t * this.data.stride + this.offset;
                    for (let t = 0; t < this.itemSize; t++)
                        e.push(this.data.array[n + t])
                }
                return {
                    itemSize: this.itemSize,
                    type: this.array.constructor.name,
                    array: e,
                    normalized: this.normalized
                }
            }
            return void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
            void 0 === e.interleavedBuffers[this.data.uuid] && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
        }
    });
    const Hi = new q
      , ji = new G
      , Gi = new G
      , Vi = new q
      , Wi = new Me;
    function qi(e, t) {
        an.call(this, e, t),
        this.type = "SkinnedMesh",
        this.bindMode = "attached",
        this.bindMatrix = new Me,
        this.bindMatrixInverse = new Me
    }
    function Xi() {
        Ye.call(this),
        this.type = "Bone"
    }
    qi.prototype = Object.assign(Object.create(an.prototype), {
        constructor: qi,
        isSkinnedMesh: !0,
        copy: function(e) {
            return an.prototype.copy.call(this, e),
            this.bindMode = e.bindMode,
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            this.skeleton = e.skeleton,
            this
        },
        bind: function(e, t) {
            this.skeleton = e,
            void 0 === t && (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            t = this.matrixWorld),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert()
        },
        pose: function() {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function() {
            const e = new G
              , t = this.geometry.attributes.skinWeight;
            for (let n = 0, r = t.count; n < r; n++) {
                e.x = t.getX(n),
                e.y = t.getY(n),
                e.z = t.getZ(n),
                e.w = t.getW(n);
                const r = 1 / e.manhattanLength();
                r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
                t.setXYZW(n, e.x, e.y, e.z, e.w)
            }
        },
        updateMatrixWorld: function(e) {
            an.prototype.updateMatrixWorld.call(this, e),
            "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        boneTransform: function(e, t) {
            const n = this.skeleton
              , r = this.geometry;
            ji.fromBufferAttribute(r.attributes.skinIndex, e),
            Gi.fromBufferAttribute(r.attributes.skinWeight, e),
            Hi.fromBufferAttribute(r.attributes.position, e).applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
            for (let e = 0; e < 4; e++) {
                const r = Gi.getComponent(e);
                if (0 !== r) {
                    const i = ji.getComponent(e);
                    Wi.multiplyMatrices(n.bones[i].matrixWorld, n.boneInverses[i]),
                    t.addScaledVector(Vi.copy(Hi).applyMatrix4(Wi), r)
                }
            }
            return t.applyMatrix4(this.bindMatrixInverse)
        }
    }),
    Xi.prototype = Object.assign(Object.create(Ye.prototype), {
        constructor: Xi,
        isBone: !0
    });
    const Yi = new Me
      , Zi = new Me
      , $i = []
      , Ji = new an;
    function Qi(e, t, n) {
        an.call(this, e, t),
        this.instanceMatrix = new wt(new Float32Array(16 * n),16),
        this.instanceColor = null,
        this.count = n,
        this.frustumCulled = !1
    }
    Qi.prototype = Object.assign(Object.create(an.prototype), {
        constructor: Qi,
        isInstancedMesh: !0,
        copy: function(e) {
            return an.prototype.copy.call(this, e),
            this.instanceMatrix.copy(e.instanceMatrix),
            null !== e.instanceColor && (this.instanceColor = e.instanceColor.clone()),
            this.count = e.count,
            this
        },
        getColorAt: function(e, t) {
            t.fromArray(this.instanceColor.array, 3 * e)
        },
        getMatrixAt: function(e, t) {
            t.fromArray(this.instanceMatrix.array, 16 * e)
        },
        raycast: function(e, t) {
            const n = this.matrixWorld
              , r = this.count;
            if (Ji.geometry = this.geometry,
            Ji.material = this.material,
            void 0 !== Ji.material)
                for (let i = 0; i < r; i++) {
                    this.getMatrixAt(i, Yi),
                    Zi.multiplyMatrices(n, Yi),
                    Ji.matrixWorld = Zi,
                    Ji.raycast(e, $i);
                    for (let e = 0, n = $i.length; e < n; e++) {
                        const n = $i[e];
                        n.instanceId = i,
                        n.object = this,
                        t.push(n)
                    }
                    $i.length = 0
                }
        },
        setColorAt: function(e, t) {
            null === this.instanceColor && (this.instanceColor = new wt(new Float32Array(3 * this.count),3)),
            t.toArray(this.instanceColor.array, 3 * e)
        },
        setMatrixAt: function(e, t) {
            t.toArray(this.instanceMatrix.array, 16 * e)
        },
        updateMorphTargets: function() {},
        dispose: function() {
            this.dispatchEvent({
                type: "dispose"
            })
        }
    });
    class Ki extends ht {
        constructor(e) {
            super(),
            this.type = "LineBasicMaterial",
            this.color = new yt(16777215),
            this.linewidth = 1,
            this.linecap = "round",
            this.linejoin = "round",
            this.morphTargets = !1,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.color.copy(e.color),
            this.linewidth = e.linewidth,
            this.linecap = e.linecap,
            this.linejoin = e.linejoin,
            this.morphTargets = e.morphTargets,
            this
        }
    }
    Ki.prototype.isLineBasicMaterial = !0;
    const eo = new q
      , to = new q
      , no = new Me
      , ro = new we
      , io = new fe;
    function oo(e=new Ht, t=new Ki) {
        Ye.call(this),
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    oo.prototype = Object.assign(Object.create(Ye.prototype), {
        constructor: oo,
        isLine: !0,
        copy: function(e) {
            return Ye.prototype.copy.call(this, e),
            this.material = e.material,
            this.geometry = e.geometry,
            this
        },
        computeLineDistances: function() {
            const e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    const t = e.attributes.position
                      , n = [0];
                    for (let e = 1, r = t.count; e < r; e++)
                        eo.fromBufferAttribute(t, e - 1),
                        to.fromBufferAttribute(t, e),
                        n[e] = n[e - 1],
                        n[e] += eo.distanceTo(to);
                    e.setAttribute("lineDistance", new Rt(n,1))
                } else
                    console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else
                e.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            return this
        },
        raycast: function(e, t) {
            const n = this.geometry
              , r = this.matrixWorld
              , i = e.params.Line.threshold
              , o = n.drawRange;
            if (null === n.boundingSphere && n.computeBoundingSphere(),
            io.copy(n.boundingSphere),
            io.applyMatrix4(r),
            io.radius += i,
            !1 === e.ray.intersectsSphere(io))
                return;
            no.copy(r).invert(),
            ro.copy(e.ray).applyMatrix4(no);
            const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3)
              , s = a * a
              , c = new q
              , l = new q
              , u = new q
              , h = new q
              , d = this.isLineSegments ? 2 : 1;
            if (n.isBufferGeometry) {
                const r = n.index
                  , i = n.attributes.position;
                if (null !== r) {
                    for (let n = Math.max(0, o.start), a = Math.min(r.count, o.start + o.count) - 1; n < a; n += d) {
                        const o = r.getX(n)
                          , a = r.getX(n + 1);
                        c.fromBufferAttribute(i, o),
                        l.fromBufferAttribute(i, a);
                        if (ro.distanceSqToSegment(c, l, h, u) > s)
                            continue;
                        h.applyMatrix4(this.matrixWorld);
                        const d = e.ray.origin.distanceTo(h);
                        d < e.near || d > e.far || t.push({
                            distance: d,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                } else {
                    for (let n = Math.max(0, o.start), r = Math.min(i.count, o.start + o.count) - 1; n < r; n += d) {
                        c.fromBufferAttribute(i, n),
                        l.fromBufferAttribute(i, n + 1);
                        if (ro.distanceSqToSegment(c, l, h, u) > s)
                            continue;
                        h.applyMatrix4(this.matrixWorld);
                        const r = e.ray.origin.distanceTo(h);
                        r < e.near || r > e.far || t.push({
                            distance: r,
                            point: u.clone().applyMatrix4(this.matrixWorld),
                            index: n,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            } else
                n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        },
        updateMorphTargets: function() {
            const e = this.geometry;
            if (e.isBufferGeometry) {
                const t = e.morphAttributes
                  , n = Object.keys(t);
                if (n.length > 0) {
                    const e = t[n[0]];
                    if (void 0 !== e) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t].name || String(t);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = t
                        }
                    }
                }
            } else {
                const t = e.morphTargets;
                void 0 !== t && t.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    });
    const ao = new q
      , so = new q;
    function co(e, t) {
        oo.call(this, e, t),
        this.type = "LineSegments"
    }
    co.prototype = Object.assign(Object.create(oo.prototype), {
        constructor: co,
        isLineSegments: !0,
        computeLineDistances: function() {
            const e = this.geometry;
            if (e.isBufferGeometry)
                if (null === e.index) {
                    const t = e.attributes.position
                      , n = [];
                    for (let e = 0, r = t.count; e < r; e += 2)
                        ao.fromBufferAttribute(t, e),
                        so.fromBufferAttribute(t, e + 1),
                        n[e] = 0 === e ? 0 : n[e - 1],
                        n[e + 1] = n[e] + ao.distanceTo(so);
                    e.setAttribute("lineDistance", new Rt(n,1))
                } else
                    console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
            else
                e.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
            return this
        }
    });
    class lo extends ht {
        constructor(e) {
            super(),
            this.type = "PointsMaterial",
            this.color = new yt(16777215),
            this.map = null,
            this.alphaMap = null,
            this.size = 1,
            this.sizeAttenuation = !0,
            this.morphTargets = !1,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.color.copy(e.color),
            this.map = e.map,
            this.alphaMap = e.alphaMap,
            this.size = e.size,
            this.sizeAttenuation = e.sizeAttenuation,
            this.morphTargets = e.morphTargets,
            this
        }
    }
    lo.prototype.isPointsMaterial = !0;
    const uo = new Me
      , ho = new we
      , po = new fe
      , fo = new q;
    function mo(e=new Ht, t=new lo) {
        Ye.call(this),
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    function go(e, t, n, r, i, o, a) {
        const s = ho.distanceSqToPoint(e);
        if (s < n) {
            const n = new q;
            ho.closestPointToPoint(e, n),
            n.applyMatrix4(r);
            const c = i.ray.origin.distanceTo(n);
            if (c < i.near || c > i.far)
                return;
            o.push({
                distance: c,
                distanceToRay: Math.sqrt(s),
                point: n,
                index: t,
                face: null,
                object: a
            })
        }
    }
    mo.prototype = Object.assign(Object.create(Ye.prototype), {
        constructor: mo,
        isPoints: !0,
        copy: function(e) {
            return Ye.prototype.copy.call(this, e),
            this.material = e.material,
            this.geometry = e.geometry,
            this
        },
        raycast: function(e, t) {
            const n = this.geometry
              , r = this.matrixWorld
              , i = e.params.Points.threshold
              , o = n.drawRange;
            if (null === n.boundingSphere && n.computeBoundingSphere(),
            po.copy(n.boundingSphere),
            po.applyMatrix4(r),
            po.radius += i,
            !1 === e.ray.intersectsSphere(po))
                return;
            uo.copy(r).invert(),
            ho.copy(e.ray).applyMatrix4(uo);
            const a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3)
              , s = a * a;
            if (n.isBufferGeometry) {
                const i = n.index
                  , a = n.attributes.position;
                if (null !== i) {
                    for (let n = Math.max(0, o.start), c = Math.min(i.count, o.start + o.count); n < c; n++) {
                        const o = i.getX(n);
                        fo.fromBufferAttribute(a, o),
                        go(fo, o, s, r, e, t, this)
                    }
                } else {
                    for (let n = Math.max(0, o.start), i = Math.min(a.count, o.start + o.count); n < i; n++)
                        fo.fromBufferAttribute(a, n),
                        go(fo, n, s, r, e, t, this)
                }
            } else
                console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        },
        updateMorphTargets: function() {
            const e = this.geometry;
            if (e.isBufferGeometry) {
                const t = e.morphAttributes
                  , n = Object.keys(t);
                if (n.length > 0) {
                    const e = t[n[0]];
                    if (void 0 !== e) {
                        this.morphTargetInfluences = [],
                        this.morphTargetDictionary = {};
                        for (let t = 0, n = e.length; t < n; t++) {
                            const n = e[t].name || String(t);
                            this.morphTargetInfluences.push(0),
                            this.morphTargetDictionary[n] = t
                        }
                    }
                }
            } else {
                const t = e.morphTargets;
                void 0 !== t && t.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
            }
        }
    });
    class vo extends H {
        constructor(e, t, n, r, i, o, a, s, c, l, u, h) {
            super(null, o, a, s, c, l, r, i, u, h),
            this.image = {
                width: t,
                height: n
            },
            this.mipmaps = e,
            this.flipY = !1,
            this.generateMipmaps = !1
        }
    }
    vo.prototype.isCompressedTexture = !0;
    class yo extends Ht {
        constructor(e=1, t=1, n=1, r=8, i=1, o=!1, a=0, s=2 * Math.PI) {
            super(),
            this.type = "CylinderGeometry",
            this.parameters = {
                radiusTop: e,
                radiusBottom: t,
                height: n,
                radialSegments: r,
                heightSegments: i,
                openEnded: o,
                thetaStart: a,
                thetaLength: s
            };
            const c = this;
            r = Math.floor(r),
            i = Math.floor(i);
            const l = []
              , u = []
              , h = []
              , d = [];
            let p = 0;
            const f = []
              , m = n / 2;
            let g = 0;
            function v(n) {
                const i = p
                  , o = new k
                  , f = new q;
                let v = 0;
                const y = !0 === n ? e : t
                  , b = !0 === n ? 1 : -1;
                for (let e = 1; e <= r; e++)
                    u.push(0, m * b, 0),
                    h.push(0, b, 0),
                    d.push(.5, .5),
                    p++;
                const x = p;
                for (let e = 0; e <= r; e++) {
                    const t = e / r * s + a
                      , n = Math.cos(t)
                      , i = Math.sin(t);
                    f.x = y * i,
                    f.y = m * b,
                    f.z = y * n,
                    u.push(f.x, f.y, f.z),
                    h.push(0, b, 0),
                    o.x = .5 * n + .5,
                    o.y = .5 * i * b + .5,
                    d.push(o.x, o.y),
                    p++
                }
                for (let e = 0; e < r; e++) {
                    const t = i + e
                      , r = x + e;
                    !0 === n ? l.push(r, r + 1, t) : l.push(r + 1, r, t),
                    v += 3
                }
                c.addGroup(g, v, !0 === n ? 1 : 2),
                g += v
            }
            !function() {
                const o = new q
                  , v = new q;
                let y = 0;
                const b = (t - e) / n;
                for (let c = 0; c <= i; c++) {
                    const l = []
                      , g = c / i
                      , y = g * (t - e) + e;
                    for (let e = 0; e <= r; e++) {
                        const t = e / r
                          , i = t * s + a
                          , c = Math.sin(i)
                          , f = Math.cos(i);
                        v.x = y * c,
                        v.y = -g * n + m,
                        v.z = y * f,
                        u.push(v.x, v.y, v.z),
                        o.set(c, b, f).normalize(),
                        h.push(o.x, o.y, o.z),
                        d.push(t, 1 - g),
                        l.push(p++)
                    }
                    f.push(l)
                }
                for (let e = 0; e < r; e++)
                    for (let t = 0; t < i; t++) {
                        const n = f[t][e]
                          , r = f[t + 1][e]
                          , i = f[t + 1][e + 1]
                          , o = f[t][e + 1];
                        l.push(n, r, o),
                        l.push(r, i, o),
                        y += 6
                    }
                c.addGroup(g, y, 0),
                g += y
            }(),
            !1 === o && (e > 0 && v(!0),
            t > 0 && v(!1)),
            this.setIndex(l),
            this.setAttribute("position", new Rt(u,3)),
            this.setAttribute("normal", new Rt(h,3)),
            this.setAttribute("uv", new Rt(d,2))
        }
    }
    function bo(e, t, n) {
        Ht.call(this),
        this.type = "ParametricGeometry",
        this.parameters = {
            func: e,
            slices: t,
            stacks: n
        };
        const r = []
          , i = []
          , o = []
          , a = []
          , s = 1e-5
          , c = new q
          , l = new q
          , u = new q
          , h = new q
          , d = new q;
        e.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        const p = t + 1;
        for (let r = 0; r <= n; r++) {
            const p = r / n;
            for (let n = 0; n <= t; n++) {
                const r = n / t;
                e(r, p, l),
                i.push(l.x, l.y, l.z),
                r - s >= 0 ? (e(r - s, p, u),
                h.subVectors(l, u)) : (e(r + s, p, u),
                h.subVectors(u, l)),
                p - s >= 0 ? (e(r, p - s, u),
                d.subVectors(l, u)) : (e(r, p + s, u),
                d.subVectors(u, l)),
                c.crossVectors(h, d).normalize(),
                o.push(c.x, c.y, c.z),
                a.push(r, p)
            }
        }
        for (let e = 0; e < n; e++)
            for (let n = 0; n < t; n++) {
                const t = e * p + n
                  , i = e * p + n + 1
                  , o = (e + 1) * p + n + 1
                  , a = (e + 1) * p + n;
                r.push(t, i, a),
                r.push(i, o, a)
            }
        this.setIndex(r),
        this.setAttribute("position", new Rt(i,3)),
        this.setAttribute("normal", new Rt(o,3)),
        this.setAttribute("uv", new Rt(a,2))
    }
    bo.prototype = Object.create(Ht.prototype),
    bo.prototype.constructor = bo;
    class xo extends Ht {
        constructor(e=1, t=8, n=6, r=0, i=2 * Math.PI, o=0, a=Math.PI) {
            super(),
            this.type = "SphereGeometry",
            this.parameters = {
                radius: e,
                widthSegments: t,
                heightSegments: n,
                phiStart: r,
                phiLength: i,
                thetaStart: o,
                thetaLength: a
            },
            t = Math.max(3, Math.floor(t)),
            n = Math.max(2, Math.floor(n));
            const s = Math.min(o + a, Math.PI);
            let c = 0;
            const l = []
              , u = new q
              , h = new q
              , d = []
              , p = []
              , f = []
              , m = [];
            for (let d = 0; d <= n; d++) {
                const g = []
                  , v = d / n;
                let y = 0;
                0 == d && 0 == o ? y = .5 / t : d == n && s == Math.PI && (y = -.5 / t);
                for (let n = 0; n <= t; n++) {
                    const s = n / t;
                    u.x = -e * Math.cos(r + s * i) * Math.sin(o + v * a),
                    u.y = e * Math.cos(o + v * a),
                    u.z = e * Math.sin(r + s * i) * Math.sin(o + v * a),
                    p.push(u.x, u.y, u.z),
                    h.copy(u).normalize(),
                    f.push(h.x, h.y, h.z),
                    m.push(s + y, 1 - v),
                    g.push(c++)
                }
                l.push(g)
            }
            for (let e = 0; e < n; e++)
                for (let r = 0; r < t; r++) {
                    const t = l[e][r + 1]
                      , i = l[e][r]
                      , a = l[e + 1][r]
                      , c = l[e + 1][r + 1];
                    (0 !== e || o > 0) && d.push(t, i, c),
                    (e !== n - 1 || s < Math.PI) && d.push(i, a, c)
                }
            this.setIndex(d),
            this.setAttribute("position", new Rt(p,3)),
            this.setAttribute("normal", new Rt(f,3)),
            this.setAttribute("uv", new Rt(m,2))
        }
    }
    function _o(e) {
        ht.call(this),
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new yt(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new yt(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = 0,
        this.normalScale = new k(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapIntensity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.skinning = !1,
        this.morphTargets = !1,
        this.morphNormals = !1,
        this.flatShading = !1,
        this.vertexTangents = !1,
        this.setValues(e)
    }
    function wo(e) {
        _o.call(this),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.clearcoat = 0,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new k(1,1),
        this.clearcoatNormalMap = null,
        this.reflectivity = .5,
        Object.defineProperty(this, "ior", {
            get: function() {
                return (1 + .4 * this.reflectivity) / (1 - .4 * this.reflectivity)
            },
            set: function(e) {
                this.reflectivity = I.clamp(2.5 * (e - 1) / (e + 1), 0, 1)
            }
        }),
        this.sheen = null,
        this.transmission = 0,
        this.transmissionMap = null,
        this.setValues(e)
    }
    _o.prototype = Object.create(ht.prototype),
    _o.prototype.constructor = _o,
    _o.prototype.isMeshStandardMaterial = !0,
    _o.prototype.copy = function(e) {
        return ht.prototype.copy.call(this, e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapIntensity = e.envMapIntensity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.skinning = e.skinning,
        this.morphTargets = e.morphTargets,
        this.morphNormals = e.morphNormals,
        this.flatShading = e.flatShading,
        this.vertexTangents = e.vertexTangents,
        this
    }
    ,
    wo.prototype = Object.create(_o.prototype),
    wo.prototype.constructor = wo,
    wo.prototype.isMeshPhysicalMaterial = !0,
    wo.prototype.copy = function(e) {
        return _o.prototype.copy.call(this, e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.reflectivity = e.reflectivity,
        e.sheen ? this.sheen = (this.sheen || new yt).copy(e.sheen) : this.sheen = null,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this
    }
    ;
    class Mo extends ht {
        constructor(e) {
            super(),
            this.type = "MeshLambertMaterial",
            this.color = new yt(16777215),
            this.map = null,
            this.lightMap = null,
            this.lightMapIntensity = 1,
            this.aoMap = null,
            this.aoMapIntensity = 1,
            this.emissive = new yt(0),
            this.emissiveIntensity = 1,
            this.emissiveMap = null,
            this.specularMap = null,
            this.alphaMap = null,
            this.envMap = null,
            this.combine = 0,
            this.reflectivity = 1,
            this.refractionRatio = .98,
            this.wireframe = !1,
            this.wireframeLinewidth = 1,
            this.wireframeLinecap = "round",
            this.wireframeLinejoin = "round",
            this.skinning = !1,
            this.morphTargets = !1,
            this.morphNormals = !1,
            this.setValues(e)
        }
        copy(e) {
            return super.copy(e),
            this.color.copy(e.color),
            this.map = e.map,
            this.lightMap = e.lightMap,
            this.lightMapIntensity = e.lightMapIntensity,
            this.aoMap = e.aoMap,
            this.aoMapIntensity = e.aoMapIntensity,
            this.emissive.copy(e.emissive),
            this.emissiveMap = e.emissiveMap,
            this.emissiveIntensity = e.emissiveIntensity,
            this.specularMap = e.specularMap,
            this.alphaMap = e.alphaMap,
            this.envMap = e.envMap,
            this.combine = e.combine,
            this.reflectivity = e.reflectivity,
            this.refractionRatio = e.refractionRatio,
            this.wireframe = e.wireframe,
            this.wireframeLinewidth = e.wireframeLinewidth,
            this.wireframeLinecap = e.wireframeLinecap,
            this.wireframeLinejoin = e.wireframeLinejoin,
            this.skinning = e.skinning,
            this.morphTargets = e.morphTargets,
            this.morphNormals = e.morphNormals,
            this
        }
    }
    function Eo(e, t, n, r) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = void 0 !== r ? r : new t.constructor(n),
        this.sampleValues = t,
        this.valueSize = n
    }
    function So(e, t, n, r) {
        Eo.call(this, e, t, n, r),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0
    }
    function To(e, t, n, r) {
        Eo.call(this, e, t, n, r)
    }
    function Lo(e, t, n, r) {
        Eo.call(this, e, t, n, r)
    }
    function Ao(e, t, n, r) {
        Eo.call(this, e, t, n, r)
    }
    Mo.prototype.isMeshLambertMaterial = !0,
    Object.assign(Eo.prototype, {
        evaluate: function(e) {
            const t = this.parameterPositions;
            let n = this._cachedIndex
              , r = t[n]
              , i = t[n - 1];
            e: {
                t: {
                    let o;
                    n: {
                        r: if (!(e < r)) {
                            for (let o = n + 2; ; ) {
                                if (void 0 === r) {
                                    if (e < i)
                                        break r;
                                    return n = t.length,
                                    this._cachedIndex = n,
                                    this.afterEnd_(n - 1, e, i)
                                }
                                if (n === o)
                                    break;
                                if (i = r,
                                r = t[++n],
                                e < r)
                                    break t
                            }
                            o = t.length;
                            break n
                        }
                        if (e >= i)
                            break e;
                        {
                            const a = t[1];
                            e < a && (n = 2,
                            i = a);
                            for (let o = n - 2; ; ) {
                                if (void 0 === i)
                                    return this._cachedIndex = 0,
                                    this.beforeStart_(0, e, r);
                                if (n === o)
                                    break;
                                if (r = i,
                                i = t[--n - 1],
                                e >= i)
                                    break t
                            }
                            o = n,
                            n = 0
                        }
                    }
                    for (; n < o; ) {
                        const r = n + o >>> 1;
                        e < t[r] ? o = r : n = r + 1
                    }
                    if (r = t[n],
                    i = t[n - 1],
                    void 0 === i)
                        return this._cachedIndex = 0,
                        this.beforeStart_(0, e, r);
                    if (void 0 === r)
                        return n = t.length,
                        this._cachedIndex = n,
                        this.afterEnd_(n - 1, i, e)
                }
                this._cachedIndex = n,
                this.intervalChanged_(n, i, r)
            }
            return this.interpolate_(n, i, e, r)
        },
        settings: null,
        DefaultSettings_: {},
        getSettings_: function() {
            return this.settings || this.DefaultSettings_
        },
        copySampleValue_: function(e) {
            const t = this.resultBuffer
              , n = this.sampleValues
              , r = this.valueSize
              , i = e * r;
            for (let e = 0; e !== r; ++e)
                t[e] = n[i + e];
            return t
        },
        interpolate_: function() {
            throw new Error("call to abstract method")
        },
        intervalChanged_: function() {}
    }),
    Object.assign(Eo.prototype, {
        beforeStart_: Eo.prototype.copySampleValue_,
        afterEnd_: Eo.prototype.copySampleValue_
    }),
    So.prototype = Object.assign(Object.create(Eo.prototype), {
        constructor: So,
        DefaultSettings_: {
            endingStart: 2400,
            endingEnd: 2400
        },
        intervalChanged_: function(e, t, n) {
            const r = this.parameterPositions;
            let i = e - 2
              , o = e + 1
              , a = r[i]
              , s = r[o];
            if (void 0 === a)
                switch (this.getSettings_().endingStart) {
                case 2401:
                    i = e,
                    a = 2 * t - n;
                    break;
                case 2402:
                    i = r.length - 2,
                    a = t + r[i] - r[i + 1];
                    break;
                default:
                    i = e,
                    a = n
                }
            if (void 0 === s)
                switch (this.getSettings_().endingEnd) {
                case 2401:
                    o = e,
                    s = 2 * n - t;
                    break;
                case 2402:
                    o = 1,
                    s = n + r[1] - r[0];
                    break;
                default:
                    o = e - 1,
                    s = t
                }
            const c = .5 * (n - t)
              , l = this.valueSize;
            this._weightPrev = c / (t - a),
            this._weightNext = c / (s - n),
            this._offsetPrev = i * l,
            this._offsetNext = o * l
        },
        interpolate_: function(e, t, n, r) {
            const i = this.resultBuffer
              , o = this.sampleValues
              , a = this.valueSize
              , s = e * a
              , c = s - a
              , l = this._offsetPrev
              , u = this._offsetNext
              , h = this._weightPrev
              , d = this._weightNext
              , p = (n - t) / (r - t)
              , f = p * p
              , m = f * p
              , g = -h * m + 2 * h * f - h * p
              , v = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * p + 1
              , y = (-1 - d) * m + (1.5 + d) * f + .5 * p
              , b = d * m - d * f;
            for (let e = 0; e !== a; ++e)
                i[e] = g * o[l + e] + v * o[c + e] + y * o[s + e] + b * o[u + e];
            return i
        }
    }),
    To.prototype = Object.assign(Object.create(Eo.prototype), {
        constructor: To,
        interpolate_: function(e, t, n, r) {
            const i = this.resultBuffer
              , o = this.sampleValues
              , a = this.valueSize
              , s = e * a
              , c = s - a
              , l = (n - t) / (r - t)
              , u = 1 - l;
            for (let e = 0; e !== a; ++e)
                i[e] = o[c + e] * u + o[s + e] * l;
            return i
        }
    }),
    Lo.prototype = Object.assign(Object.create(Eo.prototype), {
        constructor: Lo,
        interpolate_: function(e) {
            return this.copySampleValue_(e - 1)
        }
    }),
    Ao.prototype = Object.assign(Object.create(Eo.prototype), {
        constructor: Ao,
        interpolate_: function(e, t, n, r) {
            const i = this.resultBuffer
              , o = this.sampleValues
              , a = this.valueSize
              , s = (n - t) / (r - t);
            let c = e * a;
            for (let e = c + a; c !== e; c += 4)
                W.slerpFlat(i, 0, o, c - a, o, c, s);
            return i
        }
    });
    const Po = {
        enabled: !1,
        files: {},
        add: function(e, t) {
            !1 !== this.enabled && (this.files[e] = t)
        },
        get: function(e) {
            if (!1 !== this.enabled)
                return this.files[e]
        },
        remove: function(e) {
            delete this.files[e]
        },
        clear: function() {
            this.files = {}
        }
    };
    const Co = new function(e, t, n) {
        const r = this;
        let i, o = !1, a = 0, s = 0;
        const c = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = n,
        this.itemStart = function(e) {
            s++,
            !1 === o && void 0 !== r.onStart && r.onStart(e, a, s),
            o = !0
        }
        ,
        this.itemEnd = function(e) {
            a++,
            void 0 !== r.onProgress && r.onProgress(e, a, s),
            a === s && (o = !1,
            void 0 !== r.onLoad && r.onLoad())
        }
        ,
        this.itemError = function(e) {
            void 0 !== r.onError && r.onError(e)
        }
        ,
        this.resolveURL = function(e) {
            return i ? i(e) : e
        }
        ,
        this.setURLModifier = function(e) {
            return i = e,
            this
        }
        ,
        this.addHandler = function(e, t) {
            return c.push(e, t),
            this
        }
        ,
        this.removeHandler = function(e) {
            const t = c.indexOf(e);
            return -1 !== t && c.splice(t, 2),
            this
        }
        ,
        this.getHandler = function(e) {
            for (let t = 0, n = c.length; t < n; t += 2) {
                const n = c[t]
                  , r = c[t + 1];
                if (n.global && (n.lastIndex = 0),
                n.test(e))
                    return r
            }
            return null
        }
    }
    ;
    function Ro(e) {
        this.manager = void 0 !== e ? e : Co,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    Object.assign(Ro.prototype, {
        load: function() {},
        loadAsync: function(e, t) {
            const n = this;
            return new Promise((function(r, i) {
                n.load(e, r, t, i)
            }
            ))
        },
        parse: function() {},
        setCrossOrigin: function(e) {
            return this.crossOrigin = e,
            this
        },
        setWithCredentials: function(e) {
            return this.withCredentials = e,
            this
        },
        setPath: function(e) {
            return this.path = e,
            this
        },
        setResourcePath: function(e) {
            return this.resourcePath = e,
            this
        },
        setRequestHeader: function(e) {
            return this.requestHeader = e,
            this
        }
    });
    const Do = {};
    function Oo(e) {
        Ro.call(this, e)
    }
    function No(e) {
        Ro.call(this, e)
    }
    Oo.prototype = Object.assign(Object.create(Ro.prototype), {
        constructor: Oo,
        load: function(e, t, n, r) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            const i = this
              , o = Po.get(e);
            if (void 0 !== o)
                return i.manager.itemStart(e),
                setTimeout((function() {
                    t && t(o),
                    i.manager.itemEnd(e)
                }
                ), 0),
                o;
            if (void 0 !== Do[e])
                return void Do[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: r
                });
            const a = e.match(/^data:(.*?)(;base64)?,(.*)$/);
            let s;
            if (a) {
                const n = a[1]
                  , o = !!a[2];
                let s = a[3];
                s = decodeURIComponent(s),
                o && (s = atob(s));
                try {
                    let r;
                    const o = (this.responseType || "").toLowerCase();
                    switch (o) {
                    case "arraybuffer":
                    case "blob":
                        const e = new Uint8Array(s.length);
                        for (let t = 0; t < s.length; t++)
                            e[t] = s.charCodeAt(t);
                        r = "blob" === o ? new Blob([e.buffer],{
                            type: n
                        }) : e.buffer;
                        break;
                    case "document":
                        const t = new DOMParser;
                        r = t.parseFromString(s, n);
                        break;
                    case "json":
                        r = JSON.parse(s);
                        break;
                    default:
                        r = s
                    }
                    setTimeout((function() {
                        t && t(r),
                        i.manager.itemEnd(e)
                    }
                    ), 0)
                } catch (t) {
                    setTimeout((function() {
                        r && r(t),
                        i.manager.itemError(e),
                        i.manager.itemEnd(e)
                    }
                    ), 0)
                }
            } else {
                Do[e] = [],
                Do[e].push({
                    onLoad: t,
                    onProgress: n,
                    onError: r
                }),
                s = new XMLHttpRequest,
                s.open("GET", e, !0),
                s.addEventListener("load", (function(t) {
                    const n = this.response
                      , r = Do[e];
                    if (delete Do[e],
                    200 === this.status || 0 === this.status) {
                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                        Po.add(e, n);
                        for (let e = 0, t = r.length; e < t; e++) {
                            const t = r[e];
                            t.onLoad && t.onLoad(n)
                        }
                        i.manager.itemEnd(e)
                    } else {
                        for (let e = 0, n = r.length; e < n; e++) {
                            const n = r[e];
                            n.onError && n.onError(t)
                        }
                        i.manager.itemError(e),
                        i.manager.itemEnd(e)
                    }
                }
                ), !1),
                s.addEventListener("progress", (function(t) {
                    const n = Do[e];
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        r.onProgress && r.onProgress(t)
                    }
                }
                ), !1),
                s.addEventListener("error", (function(t) {
                    const n = Do[e];
                    delete Do[e];
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        r.onError && r.onError(t)
                    }
                    i.manager.itemError(e),
                    i.manager.itemEnd(e)
                }
                ), !1),
                s.addEventListener("abort", (function(t) {
                    const n = Do[e];
                    delete Do[e];
                    for (let e = 0, r = n.length; e < r; e++) {
                        const r = n[e];
                        r.onError && r.onError(t)
                    }
                    i.manager.itemError(e),
                    i.manager.itemEnd(e)
                }
                ), !1),
                void 0 !== this.responseType && (s.responseType = this.responseType),
                void 0 !== this.withCredentials && (s.withCredentials = this.withCredentials),
                s.overrideMimeType && s.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                for (const e in this.requestHeader)
                    s.setRequestHeader(e, this.requestHeader[e]);
                s.send(null)
            }
            return i.manager.itemStart(e),
            s
        },
        setResponseType: function(e) {
            return this.responseType = e,
            this
        },
        setMimeType: function(e) {
            return this.mimeType = e,
            this
        }
    }),
    No.prototype = Object.assign(Object.create(Ro.prototype), {
        constructor: No,
        load: function(e, t, n, r) {
            const i = this
              , o = []
              , a = new vo
              , s = new Oo(this.manager);
            s.setPath(this.path),
            s.setResponseType("arraybuffer"),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(i.withCredentials);
            let c = 0;
            function l(l) {
                s.load(e[l], (function(e) {
                    const n = i.parse(e, !0);
                    o[l] = {
                        width: n.width,
                        height: n.height,
                        format: n.format,
                        mipmaps: n.mipmaps
                    },
                    c += 1,
                    6 === c && (1 === n.mipmapCount && (a.minFilter = m),
                    a.image = o,
                    a.format = n.format,
                    a.needsUpdate = !0,
                    t && t(a))
                }
                ), n, r)
            }
            if (Array.isArray(e))
                for (let t = 0, n = e.length; t < n; ++t)
                    l(t);
            else
                s.load(e, (function(e) {
                    const n = i.parse(e, !0);
                    if (n.isCubemap) {
                        const e = n.mipmaps.length / n.mipmapCount;
                        for (let t = 0; t < e; t++) {
                            o[t] = {
                                mipmaps: []
                            };
                            for (let e = 0; e < n.mipmapCount; e++)
                                o[t].mipmaps.push(n.mipmaps[t * n.mipmapCount + e]),
                                o[t].format = n.format,
                                o[t].width = n.width,
                                o[t].height = n.height
                        }
                        a.image = o
                    } else
                        a.image.width = n.width,
                        a.image.height = n.height,
                        a.mipmaps = n.mipmaps;
                    1 === n.mipmapCount && (a.minFilter = m),
                    a.format = n.format,
                    a.needsUpdate = !0,
                    t && t(a)
                }
                ), n, r);
            return a
        }
    });
    class Io extends Ro {
        constructor(e) {
            super(e)
        }
        load(e, t, n, r) {
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            const i = this
              , o = Po.get(e);
            if (void 0 !== o)
                return i.manager.itemStart(e),
                setTimeout((function() {
                    t && t(o),
                    i.manager.itemEnd(e)
                }
                ), 0),
                o;
            const a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            function s() {
                a.removeEventListener("load", s, !1),
                a.removeEventListener("error", c, !1),
                Po.add(e, this),
                t && t(this),
                i.manager.itemEnd(e)
            }
            function c(t) {
                a.removeEventListener("load", s, !1),
                a.removeEventListener("error", c, !1),
                r && r(t),
                i.manager.itemError(e),
                i.manager.itemEnd(e)
            }
            return a.addEventListener("load", s, !1),
            a.addEventListener("error", c, !1),
            "data:" !== e.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin),
            i.manager.itemStart(e),
            a.src = e,
            a
        }
    }
    class ko extends Ro {
        constructor(e) {
            super(e)
        }
        load(e, t, n, r) {
            const i = new vn
              , o = new Io(this.manager);
            o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path);
            let a = 0;
            function s(n) {
                o.load(e[n], (function(e) {
                    i.images[n] = e,
                    a++,
                    6 === a && (i.needsUpdate = !0,
                    t && t(i))
                }
                ), void 0, r)
            }
            for (let t = 0; t < e.length; ++t)
                s(t);
            return i
        }
    }
    function zo(e) {
        Ro.call(this, e)
    }
    function Fo(e) {
        Ro.call(this, e)
    }
    function Bo() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    function Uo(e, t, n, r) {
        return function(e, t) {
            const n = 1 - e;
            return n * n * t
        }(e, t) + function(e, t) {
            return 2 * (1 - e) * e * t
        }(e, n) + function(e, t) {
            return e * e * t
        }(e, r)
    }
    function Ho(e, t, n, r, i) {
        return function(e, t) {
            const n = 1 - e;
            return n * n * n * t
        }(e, t) + function(e, t) {
            const n = 1 - e;
            return 3 * n * n * e * t
        }(e, n) + function(e, t) {
            return 3 * (1 - e) * e * e * t
        }(e, r) + function(e, t) {
            return e * e * e * t
        }(e, i)
    }
    zo.prototype = Object.assign(Object.create(Ro.prototype), {
        constructor: zo,
        load: function(e, t, n, r) {
            const i = this
              , o = new bn
              , a = new Oo(this.manager);
            return a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setPath(this.path),
            a.setWithCredentials(i.withCredentials),
            a.load(e, (function(e) {
                const n = i.parse(e);
                n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width,
                o.image.height = n.height,
                o.image.data = n.data),
                o.wrapS = void 0 !== n.wrapS ? n.wrapS : d,
                o.wrapT = void 0 !== n.wrapT ? n.wrapT : d,
                o.magFilter = void 0 !== n.magFilter ? n.magFilter : m,
                o.minFilter = void 0 !== n.minFilter ? n.minFilter : m,
                o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1,
                void 0 !== n.encoding && (o.encoding = n.encoding),
                void 0 !== n.flipY && (o.flipY = n.flipY),
                void 0 !== n.format && (o.format = n.format),
                void 0 !== n.type && (o.type = n.type),
                void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps,
                o.minFilter = g),
                1 === n.mipmapCount && (o.minFilter = m),
                void 0 !== n.generateMipmaps && (o.generateMipmaps = n.generateMipmaps),
                o.needsUpdate = !0,
                t && t(o, n))
            }
            ), n, r),
            o
        }
    }),
    Fo.prototype = Object.assign(Object.create(Ro.prototype), {
        constructor: Fo,
        load: function(e, t, n, r) {
            const i = new H
              , o = new Io(this.manager);
            return o.setCrossOrigin(this.crossOrigin),
            o.setPath(this.path),
            o.load(e, (function(n) {
                i.image = n;
                const r = e.search(/\.jpe?g($|\?)/i) > 0 || 0 === e.search(/^data\:image\/jpeg/);
                i.format = r ? M : E,
                i.needsUpdate = !0,
                void 0 !== t && t(i)
            }
            ), n, r),
            i
        }
    }),
    Object.assign(Bo.prototype, {
        getPoint: function() {
            return console.warn("THREE.Curve: .getPoint() not implemented."),
            null
        },
        getPointAt: function(e, t) {
            const n = this.getUtoTmapping(e);
            return this.getPoint(n, t)
        },
        getPoints: function(e=5) {
            const t = [];
            for (let n = 0; n <= e; n++)
                t.push(this.getPoint(n / e));
            return t
        },
        getSpacedPoints: function(e=5) {
            const t = [];
            for (let n = 0; n <= e; n++)
                t.push(this.getPointAt(n / e));
            return t
        },
        getLength: function() {
            const e = this.getLengths();
            return e[e.length - 1]
        },
        getLengths: function(e) {
            if (void 0 === e && (e = this.arcLengthDivisions),
            this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
                return this.cacheArcLengths;
            this.needsUpdate = !1;
            const t = [];
            let n, r = this.getPoint(0), i = 0;
            t.push(0);
            for (let o = 1; o <= e; o++)
                n = this.getPoint(o / e),
                i += n.distanceTo(r),
                t.push(i),
                r = n;
            return this.cacheArcLengths = t,
            t
        },
        updateArcLengths: function() {
            this.needsUpdate = !0,
            this.getLengths()
        },
        getUtoTmapping: function(e, t) {
            const n = this.getLengths();
            let r = 0;
            const i = n.length;
            let o;
            o = t || e * n[i - 1];
            let a, s = 0, c = i - 1;
            for (; s <= c; )
                if (r = Math.floor(s + (c - s) / 2),
                a = n[r] - o,
                a < 0)
                    s = r + 1;
                else {
                    if (!(a > 0)) {
                        c = r;
                        break
                    }
                    c = r - 1
                }
            if (r = c,
            n[r] === o)
                return r / (i - 1);
            const l = n[r];
            return (r + (o - l) / (n[r + 1] - l)) / (i - 1)
        },
        getTangent: function(e, t) {
            const n = 1e-4;
            let r = e - n
              , i = e + n;
            r < 0 && (r = 0),
            i > 1 && (i = 1);
            const o = this.getPoint(r)
              , a = this.getPoint(i)
              , s = t || (o.isVector2 ? new k : new q);
            return s.copy(a).sub(o).normalize(),
            s
        },
        getTangentAt: function(e, t) {
            const n = this.getUtoTmapping(e);
            return this.getTangent(n, t)
        },
        computeFrenetFrames: function(e, t) {
            const n = new q
              , r = []
              , i = []
              , o = []
              , a = new q
              , s = new Me;
            for (let t = 0; t <= e; t++) {
                const n = t / e;
                r[t] = this.getTangentAt(n, new q),
                r[t].normalize()
            }
            i[0] = new q,
            o[0] = new q;
            let c = Number.MAX_VALUE;
            const l = Math.abs(r[0].x)
              , u = Math.abs(r[0].y)
              , h = Math.abs(r[0].z);
            l <= c && (c = l,
            n.set(1, 0, 0)),
            u <= c && (c = u,
            n.set(0, 1, 0)),
            h <= c && n.set(0, 0, 1),
            a.crossVectors(r[0], n).normalize(),
            i[0].crossVectors(r[0], a),
            o[0].crossVectors(r[0], i[0]);
            for (let t = 1; t <= e; t++) {
                if (i[t] = i[t - 1].clone(),
                o[t] = o[t - 1].clone(),
                a.crossVectors(r[t - 1], r[t]),
                a.length() > Number.EPSILON) {
                    a.normalize();
                    const e = Math.acos(I.clamp(r[t - 1].dot(r[t]), -1, 1));
                    i[t].applyMatrix4(s.makeRotationAxis(a, e))
                }
                o[t].crossVectors(r[t], i[t])
            }
            if (!0 === t) {
                let t = Math.acos(I.clamp(i[0].dot(i[e]), -1, 1));
                t /= e,
                r[0].dot(a.crossVectors(i[0], i[e])) > 0 && (t = -t);
                for (let n = 1; n <= e; n++)
                    i[n].applyMatrix4(s.makeRotationAxis(r[n], t * n)),
                    o[n].crossVectors(r[n], i[n])
            }
            return {
                tangents: r,
                normals: i,
                binormals: o
            }
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        copy: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        },
        toJSON: function() {
            const e = {
                metadata: {
                    version: 4.5,
                    type: "Curve",
                    generator: "Curve.toJSON"
                }
            };
            return e.arcLengthDivisions = this.arcLengthDivisions,
            e.type = this.type,
            e
        },
        fromJSON: function(e) {
            return this.arcLengthDivisions = e.arcLengthDivisions,
            this
        }
    });
    class jo extends Bo {
        constructor(e=new q, t=new q, n=new q, r=new q) {
            super(),
            this.type = "CubicBezierCurve3",
            this.v0 = e,
            this.v1 = t,
            this.v2 = n,
            this.v3 = r
        }
        getPoint(e, t=new q) {
            const n = t
              , r = this.v0
              , i = this.v1
              , o = this.v2
              , a = this.v3;
            return n.set(Ho(e, r.x, i.x, o.x, a.x), Ho(e, r.y, i.y, o.y, a.y), Ho(e, r.z, i.z, o.z, a.z)),
            n
        }
        copy(e) {
            return super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this.v3.copy(e.v3),
            this
        }
        toJSON() {
            const e = super.toJSON();
            return e.v0 = this.v0.toArray(),
            e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e.v3 = this.v3.toArray(),
            e
        }
        fromJSON(e) {
            return super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this.v3.fromArray(e.v3),
            this
        }
    }
    jo.prototype.isCubicBezierCurve3 = !0;
    class Go extends Bo {
        constructor(e=new q, t=new q, n=new q) {
            super(),
            this.type = "QuadraticBezierCurve3",
            this.v0 = e,
            this.v1 = t,
            this.v2 = n
        }
        getPoint(e, t=new q) {
            const n = t
              , r = this.v0
              , i = this.v1
              , o = this.v2;
            return n.set(Uo(e, r.x, i.x, o.x), Uo(e, r.y, i.y, o.y), Uo(e, r.z, i.z, o.z)),
            n
        }
        copy(e) {
            return super.copy(e),
            this.v0.copy(e.v0),
            this.v1.copy(e.v1),
            this.v2.copy(e.v2),
            this
        }
        toJSON() {
            const e = super.toJSON();
            return e.v0 = this.v0.toArray(),
            e.v1 = this.v1.toArray(),
            e.v2 = this.v2.toArray(),
            e
        }
        fromJSON(e) {
            return super.fromJSON(e),
            this.v0.fromArray(e.v0),
            this.v1.fromArray(e.v1),
            this.v2.fromArray(e.v2),
            this
        }
    }
    Go.prototype.isQuadraticBezierCurve3 = !0;
    class Vo extends Ye {
        constructor(e, t=1) {
            super(),
            this.type = "Light",
            this.color = new yt(e),
            this.intensity = t
        }
        copy(e) {
            return super.copy(e),
            this.color.copy(e.color),
            this.intensity = e.intensity,
            this
        }
        toJSON(e) {
            const t = super.toJSON(e);
            return t.object.color = this.color.getHex(),
            t.object.intensity = this.intensity,
            void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
            t
        }
    }
    Vo.prototype.isLight = !0;
    const Wo = new Me
      , qo = new q
      , Xo = new q;
    class Yo extends pn {
        constructor(e=-1, t=1, n=1, r=-1, i=.1, o=2e3) {
            super(),
            this.type = "OrthographicCamera",
            this.zoom = 1,
            this.view = null,
            this.left = e,
            this.right = t,
            this.top = n,
            this.bottom = r,
            this.near = i,
            this.far = o,
            this.updateProjectionMatrix()
        }
        copy(e, t) {
            return super.copy(e, t),
            this.left = e.left,
            this.right = e.right,
            this.top = e.top,
            this.bottom = e.bottom,
            this.near = e.near,
            this.far = e.far,
            this.zoom = e.zoom,
            this.view = null === e.view ? null : Object.assign({}, e.view),
            this
        }
        setViewOffset(e, t, n, r, i, o) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }),
            this.view.enabled = !0,
            this.view.fullWidth = e,
            this.view.fullHeight = t,
            this.view.offsetX = n,
            this.view.offsetY = r,
            this.view.width = i,
            this.view.height = o,
            this.updateProjectionMatrix()
        }
        clearViewOffset() {
            null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix()
        }
        updateProjectionMatrix() {
            const e = (this.right - this.left) / (2 * this.zoom)
              , t = (this.top - this.bottom) / (2 * this.zoom)
              , n = (this.right + this.left) / 2
              , r = (this.top + this.bottom) / 2;
            let i = n - e
              , o = n + e
              , a = r + t
              , s = r - t;
            if (null !== this.view && this.view.enabled) {
                const e = (this.right - this.left) / this.view.fullWidth / this.zoom
                  , t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                i += e * this.view.offsetX,
                o = i + e * this.view.width,
                a -= t * this.view.offsetY,
                s = a - t * this.view.height
            }
            this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
        }
        toJSON(e) {
            const t = Ye.prototype.toJSON.call(this, e);
            return t.object.zoom = this.zoom,
            t.object.left = this.left,
            t.object.right = this.right,
            t.object.top = this.top,
            t.object.bottom = this.bottom,
            t.object.near = this.near,
            t.object.far = this.far,
            null !== this.view && (t.object.view = Object.assign({}, this.view)),
            t
        }
    }
    Yo.prototype.isOrthographicCamera = !0;
    class Zo extends class {
        constructor(e) {
            this.camera = e,
            this.bias = 0,
            this.normalBias = 0,
            this.radius = 1,
            this.mapSize = new k(512,512),
            this.map = null,
            this.mapPass = null,
            this.matrix = new Me,
            this.autoUpdate = !0,
            this.needsUpdate = !1,
            this._frustum = new wn,
            this._frameExtents = new k(1,1),
            this._viewportCount = 1,
            this._viewports = [new G(0,0,1,1)]
        }
        getViewportCount() {
            return this._viewportCount
        }
        getFrustum() {
            return this._frustum
        }
        updateMatrices(e) {
            const t = this.camera
              , n = this.matrix;
            qo.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(qo),
            Xo.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(Xo),
            t.updateMatrixWorld(),
            Wo.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Wo),
            n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            n.multiply(t.projectionMatrix),
            n.multiply(t.matrixWorldInverse)
        }
        getViewport(e) {
            return this._viewports[e]
        }
        getFrameExtents() {
            return this._frameExtents
        }
        copy(e) {
            return this.camera = e.camera.clone(),
            this.bias = e.bias,
            this.radius = e.radius,
            this.mapSize.copy(e.mapSize),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
        toJSON() {
            const e = {};
            return 0 !== this.bias && (e.bias = this.bias),
            0 !== this.normalBias && (e.normalBias = this.normalBias),
            1 !== this.radius && (e.radius = this.radius),
            512 === this.mapSize.x && 512 === this.mapSize.y || (e.mapSize = this.mapSize.toArray()),
            e.camera = this.camera.toJSON(!1).object,
            delete e.camera.matrix,
            e
        }
    }
    {
        constructor() {
            super(new Yo(-5,5,5,-5,.5,500))
        }
    }
    Zo.prototype.isDirectionalLightShadow = !0;
    class $o extends Vo {
        constructor(e, t) {
            super(e, t),
            this.type = "DirectionalLight",
            this.position.copy(Ye.DefaultUp),
            this.updateMatrix(),
            this.target = new Ye,
            this.shadow = new Zo
        }
        copy(e) {
            return super.copy(e),
            this.target = e.target.clone(),
            this.shadow = e.shadow.clone(),
            this
        }
    }
    $o.prototype.isDirectionalLight = !0;
    class Jo extends Vo {
        constructor(e, t) {
            super(e, t),
            this.type = "AmbientLight"
        }
    }
    Jo.prototype.isAmbientLight = !0;
    const Qo = function(e) {
        const t = e.lastIndexOf("/");
        return -1 === t ? "./" : e.substr(0, t + 1)
    };
    function Ko() {
        Ht.call(this),
        this.type = "InstancedBufferGeometry",
        this.instanceCount = 1 / 0
    }
    function ea(e, t, n, r) {
        "number" == typeof n && (r = n,
        n = !1,
        console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),
        wt.call(this, e, t, n),
        this.meshPerAttribute = r || 1
    }
    function ta(e) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        Ro.call(this, e),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    Ko.prototype = Object.assign(Object.create(Ht.prototype), {
        constructor: Ko,
        isInstancedBufferGeometry: !0,
        copy: function(e) {
            return Ht.prototype.copy.call(this, e),
            this.instanceCount = e.instanceCount,
            this
        },
        clone: function() {
            return (new this.constructor).copy(this)
        },
        toJSON: function() {
            const e = Ht.prototype.toJSON.call(this);
            return e.instanceCount = this.instanceCount,
            e.isInstancedBufferGeometry = !0,
            e
        }
    }),
    ea.prototype = Object.assign(Object.create(wt.prototype), {
        constructor: ea,
        isInstancedBufferAttribute: !0,
        copy: function(e) {
            return wt.prototype.copy.call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        },
        toJSON: function() {
            const e = wt.prototype.toJSON.call(this);
            return e.meshPerAttribute = this.meshPerAttribute,
            e.isInstancedBufferAttribute = !0,
            e
        }
    }),
    ta.prototype = Object.assign(Object.create(Ro.prototype), {
        constructor: ta,
        isImageBitmapLoader: !0,
        setOptions: function(e) {
            return this.options = e,
            this
        },
        load: function(e, t, n, r) {
            void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            e = this.manager.resolveURL(e);
            const i = this
              , o = Po.get(e);
            if (void 0 !== o)
                return i.manager.itemStart(e),
                setTimeout((function() {
                    t && t(o),
                    i.manager.itemEnd(e)
                }
                ), 0),
                o;
            const a = {};
            a.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include",
            a.headers = this.requestHeader,
            fetch(e, a).then((function(e) {
                return e.blob()
            }
            )).then((function(e) {
                return createImageBitmap(e, Object.assign(i.options, {
                    colorSpaceConversion: "none"
                }))
            }
            )).then((function(n) {
                Po.add(e, n),
                t && t(n),
                i.manager.itemEnd(e)
            }
            )).catch((function(t) {
                r && r(t),
                i.manager.itemError(e),
                i.manager.itemEnd(e)
            }
            )),
            i.manager.itemStart(e)
        }
    }),
    new Me,
    new Me;
    class na {
        constructor(e) {
            this.autoStart = void 0 === e || e,
            this.startTime = 0,
            this.oldTime = 0,
            this.elapsedTime = 0,
            this.running = !1
        }
        start() {
            this.startTime = ra(),
            this.oldTime = this.startTime,
            this.elapsedTime = 0,
            this.running = !0
        }
        stop() {
            this.getElapsedTime(),
            this.running = !1,
            this.autoStart = !1
        }
        getElapsedTime() {
            return this.getDelta(),
            this.elapsedTime
        }
        getDelta() {
            let e = 0;
            if (this.autoStart && !this.running)
                return this.start(),
                0;
            if (this.running) {
                const t = ra();
                e = (t - this.oldTime) / 1e3,
                this.oldTime = t,
                this.elapsedTime += e
            }
            return e
        }
    }
    function ra() {
        return ("undefined" == typeof performance ? Date : performance).now()
    }
    const ia = "\\[\\]\\.:\\/"
      , oa = new RegExp("[\\[\\]\\.:\\/]","g")
      , aa = "[^\\[\\]\\.:\\/]"
      , sa = "[^" + ia.replace("\\.", "") + "]"
      , ca = /((?:WC+[\/:])*)/.source.replace("WC", aa)
      , la = /(WCOD+)?/.source.replace("WCOD", sa)
      , ua = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", aa)
      , ha = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", aa)
      , da = new RegExp("^" + ca + la + ua + ha + "$")
      , pa = ["material", "materials", "bones"];
    function fa(e, t, n) {
        const r = n || ma.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, r)
    }
    function ma(e, t, n) {
        this.path = t,
        this.parsedPath = n || ma.parseTrackName(t),
        this.node = ma.findNode(e, this.parsedPath.nodeName) || e,
        this.rootNode = e
    }
    function ga(e, t, n) {
        Fi.call(this, e, t),
        this.meshPerAttribute = n || 1
    }
    function va(e, t, n, r, i) {
        this.buffer = e,
        this.type = t,
        this.itemSize = n,
        this.elementSize = r,
        this.count = i,
        this.version = 0
    }
    function ya(e, t, n=0, r=1 / 0) {
        this.ray = new we(e,t),
        this.near = n,
        this.far = r,
        this.camera = null,
        this.layers = new Ne,
        this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                    this.Points
                }
            }
        })
    }
    function ba(e, t) {
        return e.distance - t.distance
    }
    function xa(e, t, n, r) {
        if (e.layers.test(t.layers) && e.raycast(t, n),
        !0 === r) {
            const r = e.children;
            for (let e = 0, i = r.length; e < i; e++)
                xa(r[e], t, n, !0)
        }
    }
    Object.assign(fa.prototype, {
        getValue: function(e, t) {
            this.bind();
            const n = this._targetGroup.nCachedObjects_
              , r = this._bindings[n];
            void 0 !== r && r.getValue(e, t)
        },
        setValue: function(e, t) {
            const n = this._bindings;
            for (let r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r)
                n[r].setValue(e, t)
        },
        bind: function() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                e[t].bind()
        },
        unbind: function() {
            const e = this._bindings;
            for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
                e[t].unbind()
        }
    }),
    Object.assign(ma, {
        Composite: fa,
        create: function(e, t, n) {
            return e && e.isAnimationObjectGroup ? new ma.Composite(e,t,n) : new ma(e,t,n)
        },
        sanitizeNodeName: function(e) {
            return e.replace(/\s/g, "_").replace(oa, "")
        },
        parseTrackName: function(e) {
            const t = da.exec(e);
            if (!t)
                throw new Error("PropertyBinding: Cannot parse trackName: " + e);
            const n = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            }
              , r = n.nodeName && n.nodeName.lastIndexOf(".");
            if (void 0 !== r && -1 !== r) {
                const e = n.nodeName.substring(r + 1);
                -1 !== pa.indexOf(e) && (n.nodeName = n.nodeName.substring(0, r),
                n.objectName = e)
            }
            if (null === n.propertyName || 0 === n.propertyName.length)
                throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
            return n
        },
        findNode: function(e, t) {
            if (!t || "" === t || "." === t || -1 === t || t === e.name || t === e.uuid)
                return e;
            if (e.skeleton) {
                const n = e.skeleton.getBoneByName(t);
                if (void 0 !== n)
                    return n
            }
            if (e.children) {
                const n = function(e) {
                    for (let r = 0; r < e.length; r++) {
                        const i = e[r];
                        if (i.name === t || i.uuid === t)
                            return i;
                        const o = n(i.children);
                        if (o)
                            return o
                    }
                    return null
                }
                  , r = n(e.children);
                if (r)
                    return r
            }
            return null
        }
    }),
    Object.assign(ma.prototype, {
        _getValue_unavailable: function() {},
        _setValue_unavailable: function() {},
        BindingType: {
            Direct: 0,
            EntireArray: 1,
            ArrayElement: 2,
            HasFromToArray: 3
        },
        Versioning: {
            None: 0,
            NeedsUpdate: 1,
            MatrixWorldNeedsUpdate: 2
        },
        GetterByBindingType: [function(e, t) {
            e[t] = this.node[this.propertyName]
        }
        , function(e, t) {
            const n = this.resolvedProperty;
            for (let r = 0, i = n.length; r !== i; ++r)
                e[t++] = n[r]
        }
        , function(e, t) {
            e[t] = this.resolvedProperty[this.propertyIndex]
        }
        , function(e, t) {
            this.resolvedProperty.toArray(e, t)
        }
        ],
        SetterByBindingTypeAndVersioning: [[function(e, t) {
            this.targetObject[this.propertyName] = e[t]
        }
        , function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.targetObject[this.propertyName] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            const n = this.resolvedProperty;
            for (let r = 0, i = n.length; r !== i; ++r)
                n[r] = e[t++]
        }
        , function(e, t) {
            const n = this.resolvedProperty;
            for (let r = 0, i = n.length; r !== i; ++r)
                n[r] = e[t++];
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            const n = this.resolvedProperty;
            for (let r = 0, i = n.length; r !== i; ++r)
                n[r] = e[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t]
        }
        , function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.resolvedProperty[this.propertyIndex] = e[t],
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ], [function(e, t) {
            this.resolvedProperty.fromArray(e, t)
        }
        , function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.needsUpdate = !0
        }
        , function(e, t) {
            this.resolvedProperty.fromArray(e, t),
            this.targetObject.matrixWorldNeedsUpdate = !0
        }
        ]],
        getValue: function(e, t) {
            this.bind(),
            this.getValue(e, t)
        },
        setValue: function(e, t) {
            this.bind(),
            this.setValue(e, t)
        },
        bind: function() {
            let e = this.node;
            const t = this.parsedPath
              , n = t.objectName
              , r = t.propertyName;
            let i = t.propertyIndex;
            if (e || (e = ma.findNode(this.rootNode, t.nodeName) || this.rootNode,
            this.node = e),
            this.getValue = this._getValue_unavailable,
            this.setValue = this._setValue_unavailable,
            !e)
                return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
            if (n) {
                let r = t.objectIndex;
                switch (n) {
                case "materials":
                    if (!e.material)
                        return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    if (!e.material.materials)
                        return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    e = e.material.materials;
                    break;
                case "bones":
                    if (!e.skeleton)
                        return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    e = e.skeleton.bones;
                    for (let t = 0; t < e.length; t++)
                        if (e[t].name === r) {
                            r = t;
                            break
                        }
                    break;
                default:
                    if (void 0 === e[n])
                        return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    e = e[n]
                }
                if (void 0 !== r) {
                    if (void 0 === e[r])
                        return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    e = e[r]
                }
            }
            const o = e[r];
            if (void 0 === o) {
                const n = t.nodeName;
                return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", e)
            }
            let a = this.Versioning.None;
            this.targetObject = e,
            void 0 !== e.needsUpdate ? a = this.Versioning.NeedsUpdate : void 0 !== e.matrixWorldNeedsUpdate && (a = this.Versioning.MatrixWorldNeedsUpdate);
            let s = this.BindingType.Direct;
            if (void 0 !== i) {
                if ("morphTargetInfluences" === r) {
                    if (!e.geometry)
                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    if (!e.geometry.isBufferGeometry)
                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
                    if (!e.geometry.morphAttributes)
                        return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    void 0 !== e.morphTargetDictionary[i] && (i = e.morphTargetDictionary[i])
                }
                s = this.BindingType.ArrayElement,
                this.resolvedProperty = o,
                this.propertyIndex = i
            } else
                void 0 !== o.fromArray && void 0 !== o.toArray ? (s = this.BindingType.HasFromToArray,
                this.resolvedProperty = o) : Array.isArray(o) ? (s = this.BindingType.EntireArray,
                this.resolvedProperty = o) : this.propertyName = r;
            this.getValue = this.GetterByBindingType[s],
            this.setValue = this.SetterByBindingTypeAndVersioning[s][a]
        },
        unbind: function() {
            this.node = null,
            this.getValue = this._getValue_unbound,
            this.setValue = this._setValue_unbound
        }
    }),
    Object.assign(ma.prototype, {
        _getValue_unbound: ma.prototype.getValue,
        _setValue_unbound: ma.prototype.setValue
    }),
    ga.prototype = Object.assign(Object.create(Fi.prototype), {
        constructor: ga,
        isInstancedInterleavedBuffer: !0,
        copy: function(e) {
            return Fi.prototype.copy.call(this, e),
            this.meshPerAttribute = e.meshPerAttribute,
            this
        },
        clone: function(e) {
            const t = Fi.prototype.clone.call(this, e);
            return t.meshPerAttribute = this.meshPerAttribute,
            t
        },
        toJSON: function(e) {
            const t = Fi.prototype.toJSON.call(this, e);
            return t.isInstancedInterleavedBuffer = !0,
            t.meshPerAttribute = this.meshPerAttribute,
            t
        }
    }),
    Object.defineProperty(va.prototype, "needsUpdate", {
        set: function(e) {
            !0 === e && this.version++
        }
    }),
    Object.assign(va.prototype, {
        isGLBufferAttribute: !0,
        setBuffer: function(e) {
            return this.buffer = e,
            this
        },
        setType: function(e, t) {
            return this.type = e,
            this.elementSize = t,
            this
        },
        setItemSize: function(e) {
            return this.itemSize = e,
            this
        },
        setCount: function(e) {
            return this.count = e,
            this
        }
    }),
    Object.assign(ya.prototype, {
        set: function(e, t) {
            this.ray.set(e, t)
        },
        setFromCamera: function(e, t) {
            t && t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
            this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(),
            this.camera = t) : t && t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t),
            this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
            this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
        },
        intersectObject: function(e, t=!1, n=[]) {
            return xa(e, this, n, t),
            n.sort(ba),
            n
        },
        intersectObjects: function(e, t=!1, n=[]) {
            for (let r = 0, i = e.length; r < i; r++)
                xa(e[r], this, n, t);
            return n.sort(ba),
            n
        }
    });
    class _a {
        constructor(e=1, t=0, n=0) {
            return this.radius = e,
            this.phi = t,
            this.theta = n,
            this
        }
        set(e, t, n) {
            return this.radius = e,
            this.phi = t,
            this.theta = n,
            this
        }
        copy(e) {
            return this.radius = e.radius,
            this.phi = e.phi,
            this.theta = e.theta,
            this
        }
        makeSafe() {
            const e = 1e-6;
            return this.phi = Math.max(e, Math.min(Math.PI - e, this.phi)),
            this
        }
        setFromVector3(e) {
            return this.setFromCartesianCoords(e.x, e.y, e.z)
        }
        setFromCartesianCoords(e, t, n) {
            return this.radius = Math.sqrt(e * e + t * t + n * n),
            0 === this.radius ? (this.theta = 0,
            this.phi = 0) : (this.theta = Math.atan2(e, n),
            this.phi = Math.acos(I.clamp(t / this.radius, -1, 1))),
            this
        }
        clone() {
            return (new this.constructor).copy(this)
        }
    }
    function wa(e) {
        Ye.call(this),
        this.material = e,
        this.render = function() {}
        ,
        this.hasPositions = !1,
        this.hasNormals = !1,
        this.hasColors = !1,
        this.hasUvs = !1,
        this.positionArray = null,
        this.normalArray = null,
        this.colorArray = null,
        this.uvArray = null,
        this.count = 0
    }
    wa.prototype = Object.create(Ye.prototype),
    wa.prototype.constructor = wa,
    wa.prototype.isImmediateRenderObject = !0;
    const Ma = new bt({
        side: 1,
        depthWrite: !1,
        depthTest: !1
    });
    new an(new cn,Ma),
    Bo.create = function(e, t) {
        return console.log("THREE.Curve.create() has been deprecated"),
        e.prototype = Object.create(Bo.prototype),
        e.prototype.constructor = e,
        e.prototype.getPoint = t,
        e
    }
    ,
    Ro.prototype.extractUrlBase = function(e) {
        return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),
        Qo(e)
    }
    ,
    Ro.Handlers = {
        add: function() {
            console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
        },
        get: function() {
            console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
        }
    },
    Z.prototype.center = function(e) {
        return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),
        this.getCenter(e)
    }
    ,
    Z.prototype.empty = function() {
        return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
        this.isEmpty()
    }
    ,
    Z.prototype.isIntersectionBox = function(e) {
        return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
        this.intersectsBox(e)
    }
    ,
    Z.prototype.isIntersectionSphere = function(e) {
        return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
        this.intersectsSphere(e)
    }
    ,
    Z.prototype.size = function(e) {
        return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
        this.getSize(e)
    }
    ,
    fe.prototype.empty = function() {
        return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),
        this.isEmpty()
    }
    ,
    wn.prototype.setFromMatrix = function(e) {
        return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),
        this.setFromProjectionMatrix(e)
    }
    ,
    I.random16 = function() {
        return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),
        Math.random()
    }
    ,
    I.nearestPowerOfTwo = function(e) {
        return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),
        I.floorPowerOfTwo(e)
    }
    ,
    I.nextPowerOfTwo = function(e) {
        return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),
        I.ceilPowerOfTwo(e)
    }
    ,
    z.prototype.flattenToArrayOffset = function(e, t) {
        return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
        this.toArray(e, t)
    }
    ,
    z.prototype.multiplyVector3 = function(e) {
        return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
        e.applyMatrix3(this)
    }
    ,
    z.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
    }
    ,
    z.prototype.applyToBufferAttribute = function(e) {
        return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),
        e.applyMatrix3(this)
    }
    ,
    z.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
    }
    ,
    z.prototype.getInverse = function(e) {
        return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
        this.copy(e).invert()
    }
    ,
    Me.prototype.extractPosition = function(e) {
        return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
        this.copyPosition(e)
    }
    ,
    Me.prototype.flattenToArrayOffset = function(e, t) {
        return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),
        this.toArray(e, t)
    }
    ,
    Me.prototype.getPosition = function() {
        return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
        (new q).setFromMatrixColumn(this, 3)
    }
    ,
    Me.prototype.setRotationFromQuaternion = function(e) {
        return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
        this.makeRotationFromQuaternion(e)
    }
    ,
    Me.prototype.multiplyToArray = function() {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
    }
    ,
    Me.prototype.multiplyVector3 = function(e) {
        return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),
        e.applyMatrix4(this)
    }
    ,
    Me.prototype.multiplyVector4 = function(e) {
        return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
        e.applyMatrix4(this)
    }
    ,
    Me.prototype.multiplyVector3Array = function() {
        console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
    }
    ,
    Me.prototype.rotateAxis = function(e) {
        console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
        e.transformDirection(this)
    }
    ,
    Me.prototype.crossVector = function(e) {
        return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
        e.applyMatrix4(this)
    }
    ,
    Me.prototype.translate = function() {
        console.error("THREE.Matrix4: .translate() has been removed.")
    }
    ,
    Me.prototype.rotateX = function() {
        console.error("THREE.Matrix4: .rotateX() has been removed.")
    }
    ,
    Me.prototype.rotateY = function() {
        console.error("THREE.Matrix4: .rotateY() has been removed.")
    }
    ,
    Me.prototype.rotateZ = function() {
        console.error("THREE.Matrix4: .rotateZ() has been removed.")
    }
    ,
    Me.prototype.rotateByAxis = function() {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
    }
    ,
    Me.prototype.applyToBufferAttribute = function(e) {
        return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),
        e.applyMatrix4(this)
    }
    ,
    Me.prototype.applyToVector3Array = function() {
        console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
    }
    ,
    Me.prototype.makeFrustum = function(e, t, n, r, i, o) {
        return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),
        this.makePerspective(e, t, r, n, i, o)
    }
    ,
    Me.prototype.getInverse = function(e) {
        return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),
        this.copy(e).invert()
    }
    ,
    Qe.prototype.isIntersectionLine = function(e) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
        this.intersectsLine(e)
    }
    ,
    W.prototype.multiplyVector3 = function(e) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
        e.applyQuaternion(this)
    }
    ,
    W.prototype.inverse = function() {
        return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),
        this.invert()
    }
    ,
    we.prototype.isIntersectionBox = function(e) {
        return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
        this.intersectsBox(e)
    }
    ,
    we.prototype.isIntersectionPlane = function(e) {
        return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
        this.intersectsPlane(e)
    }
    ,
    we.prototype.isIntersectionSphere = function(e) {
        return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
        this.intersectsSphere(e)
    }
    ,
    lt.prototype.area = function() {
        return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),
        this.getArea()
    }
    ,
    lt.prototype.barycoordFromPoint = function(e, t) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
        this.getBarycoord(e, t)
    }
    ,
    lt.prototype.midpoint = function(e) {
        return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),
        this.getMidpoint(e)
    }
    ,
    lt.prototypenormal = function(e) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
        this.getNormal(e)
    }
    ,
    lt.prototype.plane = function(e) {
        return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),
        this.getPlane(e)
    }
    ,
    lt.barycoordFromPoint = function(e, t, n, r, i) {
        return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),
        lt.getBarycoord(e, t, n, r, i)
    }
    ,
    lt.normal = function(e, t, n, r) {
        return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),
        lt.getNormal(e, t, n, r)
    }
    ,
    k.prototype.fromAttribute = function(e, t, n) {
        return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),
        this.fromBufferAttribute(e, t, n)
    }
    ,
    k.prototype.distanceToManhattan = function(e) {
        return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
        this.manhattanDistanceTo(e)
    }
    ,
    k.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),
        this.manhattanLength()
    }
    ,
    q.prototype.setEulerFromRotationMatrix = function() {
        console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
    }
    ,
    q.prototype.setEulerFromQuaternion = function() {
        console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
    }
    ,
    q.prototype.getPositionFromMatrix = function(e) {
        return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
        this.setFromMatrixPosition(e)
    }
    ,
    q.prototype.getScaleFromMatrix = function(e) {
        return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
        this.setFromMatrixScale(e)
    }
    ,
    q.prototype.getColumnFromMatrix = function(e, t) {
        return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
        this.setFromMatrixColumn(t, e)
    }
    ,
    q.prototype.applyProjection = function(e) {
        return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),
        this.applyMatrix4(e)
    }
    ,
    q.prototype.fromAttribute = function(e, t, n) {
        return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),
        this.fromBufferAttribute(e, t, n)
    }
    ,
    q.prototype.distanceToManhattan = function(e) {
        return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),
        this.manhattanDistanceTo(e)
    }
    ,
    q.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),
        this.manhattanLength()
    }
    ,
    G.prototype.fromAttribute = function(e, t, n) {
        return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),
        this.fromBufferAttribute(e, t, n)
    }
    ,
    G.prototype.lengthManhattan = function() {
        return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),
        this.manhattanLength()
    }
    ,
    Ye.prototype.getChildByName = function(e) {
        return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
        this.getObjectByName(e)
    }
    ,
    Ye.prototype.renderDepth = function() {
        console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
    }
    ,
    Ye.prototype.translate = function(e, t) {
        return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
        this.translateOnAxis(t, e)
    }
    ,
    Ye.prototype.getWorldRotation = function() {
        console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
    }
    ,
    Ye.prototype.applyMatrix = function(e) {
        return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),
        this.applyMatrix4(e)
    }
    ,
    Object.defineProperties(Ye.prototype, {
        eulerOrder: {
            get: function() {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order
            },
            set: function(e) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
                this.rotation.order = e
            }
        },
        useQuaternion: {
            get: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            },
            set: function() {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }),
    an.prototype.setDrawMode = function() {
        console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
    }
    ,
    Object.defineProperties(an.prototype, {
        drawMode: {
            get: function() {
                return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),
                0
            },
            set: function() {
                console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
            }
        }
    }),
    qi.prototype.initBones = function() {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }
    ,
    Object.defineProperty(Bo.prototype, "__arcLengthDivisions", {
        get: function() {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions
        },
        set: function(e) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),
            this.arcLengthDivisions = e
        }
    }),
    fn.prototype.setLens = function(e, t) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),
        void 0 !== t && (this.filmGauge = t),
        this.setFocalLength(e)
    }
    ,
    Object.defineProperties(Vo.prototype, {
        onlyShadow: {
            set: function() {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        },
        shadowCameraFov: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
                this.shadow.camera.fov = e
            }
        },
        shadowCameraLeft: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
                this.shadow.camera.left = e
            }
        },
        shadowCameraRight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
                this.shadow.camera.right = e
            }
        },
        shadowCameraTop: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
                this.shadow.camera.top = e
            }
        },
        shadowCameraBottom: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
                this.shadow.camera.bottom = e
            }
        },
        shadowCameraNear: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
                this.shadow.camera.near = e
            }
        },
        shadowCameraFar: {
            set: function(e) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
                this.shadow.camera.far = e
            }
        },
        shadowCameraVisible: {
            set: function() {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        },
        shadowBias: {
            set: function(e) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
                this.shadow.bias = e
            }
        },
        shadowDarkness: {
            set: function() {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        },
        shadowMapWidth: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
                this.shadow.mapSize.width = e
            }
        },
        shadowMapHeight: {
            set: function(e) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
                this.shadow.mapSize.height = e
            }
        }
    }),
    Object.defineProperties(wt.prototype, {
        length: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),
                this.array.length
            }
        },
        dynamic: {
            get: function() {
                return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                this.usage === C
            },
            set: function() {
                console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),
                this.setUsage(C)
            }
        }
    }),
    wt.prototype.setDynamic = function(e) {
        return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),
        this.setUsage(!0 === e ? C : P),
        this
    }
    ,
    wt.prototype.copyIndicesArray = function() {
        console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
    }
    ,
    wt.prototype.setArray = function() {
        console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
    }
    ,
    Ht.prototype.addIndex = function(e) {
        console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
        this.setIndex(e)
    }
    ,
    Ht.prototype.addAttribute = function(e, t) {
        return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),
        t && t.isBufferAttribute || t && t.isInterleavedBufferAttribute ? "index" === e ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
        this.setIndex(t),
        this) : this.setAttribute(e, t) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
        this.setAttribute(e, new wt(arguments[1],arguments[2])))
    }
    ,
    Ht.prototype.addDrawCall = function(e, t, n) {
        void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
        console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
        this.addGroup(e, t)
    }
    ,
    Ht.prototype.clearDrawCalls = function() {
        console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
        this.clearGroups()
    }
    ,
    Ht.prototype.computeOffsets = function() {
        console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
    }
    ,
    Ht.prototype.removeAttribute = function(e) {
        return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),
        this.deleteAttribute(e)
    }
    ,
    Ht.prototype.applyMatrix = function(e) {
        return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),
        this.applyMatrix4(e)
    }
    ,
    Object.defineProperties(Ht.prototype, {
        drawcalls: {
            get: function() {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
                this.groups
            }
        },
        offsets: {
            get: function() {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
                this.groups
            }
        }
    }),
    Object.defineProperties(Ko.prototype, {
        maxInstancedCount: {
            get: function() {
                return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
                this.instanceCount
            },
            set: function(e) {
                console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),
                this.instanceCount = e
            }
        }
    }),
    Object.defineProperties(ya.prototype, {
        linePrecision: {
            get: function() {
                return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
                this.params.Line.threshold
            },
            set: function(e) {
                console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),
                this.params.Line.threshold = e
            }
        }
    }),
    Object.defineProperties(Fi.prototype, {
        dynamic: {
            get: function() {
                return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                this.usage === C
            },
            set: function(e) {
                console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),
                this.setUsage(e)
            }
        }
    }),
    Fi.prototype.setDynamic = function(e) {
        return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),
        this.setUsage(!0 === e ? C : P),
        this
    }
    ,
    Fi.prototype.setArray = function() {
        console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
    }
    ,
    zi.prototype.dispose = function() {
        console.error("THREE.Scene: .dispose() has been removed.")
    }
    ,
    Object.defineProperties(ht.prototype, {
        wrapAround: {
            get: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        },
        overdraw: {
            get: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            },
            set: function() {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        },
        wrapRGB: {
            get: function() {
                return console.warn("THREE.Material: .wrapRGB has been removed."),
                new yt
            }
        },
        shading: {
            get: function() {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            },
            set: function(e) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."),
                this.flatShading = 1 === e
            }
        },
        stencilMask: {
            get: function() {
                return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                this.stencilFuncMask
            },
            set: function(e) {
                console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."),
                this.stencilFuncMask = e
            }
        }
    }),
    Object.defineProperties(wo.prototype, {
        transparency: {
            get: function() {
                return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),
                this.transmission
            },
            set: function(e) {
                console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),
                this.transmission = e
            }
        }
    }),
    Object.defineProperties(dn.prototype, {
        derivatives: {
            get: function() {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives
            },
            set: function(e) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
                this.extensions.derivatives = e
            }
        }
    }),
    ki.prototype.clearTarget = function(e, t, n, r) {
        console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),
        this.setRenderTarget(e),
        this.clear(t, n, r)
    }
    ,
    ki.prototype.animate = function(e) {
        console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),
        this.setAnimationLoop(e)
    }
    ,
    ki.prototype.getCurrentRenderTarget = function() {
        return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),
        this.getRenderTarget()
    }
    ,
    ki.prototype.getMaxAnisotropy = function() {
        return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),
        this.capabilities.getMaxAnisotropy()
    }
    ,
    ki.prototype.getPrecision = function() {
        return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),
        this.capabilities.precision
    }
    ,
    ki.prototype.resetGLState = function() {
        return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),
        this.state.reset()
    }
    ,
    ki.prototype.supportsFloatTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
        this.extensions.get("OES_texture_float")
    }
    ,
    ki.prototype.supportsHalfFloatTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
        this.extensions.get("OES_texture_half_float")
    }
    ,
    ki.prototype.supportsStandardDerivatives = function() {
        return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
        this.extensions.get("OES_standard_derivatives")
    }
    ,
    ki.prototype.supportsCompressedTextureS3TC = function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
        this.extensions.get("WEBGL_compressed_texture_s3tc")
    }
    ,
    ki.prototype.supportsCompressedTexturePVRTC = function() {
        return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
        this.extensions.get("WEBGL_compressed_texture_pvrtc")
    }
    ,
    ki.prototype.supportsBlendMinMax = function() {
        return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
        this.extensions.get("EXT_blend_minmax")
    }
    ,
    ki.prototype.supportsVertexTextures = function() {
        return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),
        this.capabilities.vertexTextures
    }
    ,
    ki.prototype.supportsInstancedArrays = function() {
        return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
        this.extensions.get("ANGLE_instanced_arrays")
    }
    ,
    ki.prototype.enableScissorTest = function(e) {
        console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
        this.setScissorTest(e)
    }
    ,
    ki.prototype.initMaterial = function() {
        console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
    }
    ,
    ki.prototype.addPrePlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
    }
    ,
    ki.prototype.addPostPlugin = function() {
        console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
    }
    ,
    ki.prototype.updateShadowMap = function() {
        console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
    }
    ,
    ki.prototype.setFaceCulling = function() {
        console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
    }
    ,
    ki.prototype.allocTextureUnit = function() {
        console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
    }
    ,
    ki.prototype.setTexture = function() {
        console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
    }
    ,
    ki.prototype.setTexture2D = function() {
        console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
    }
    ,
    ki.prototype.setTextureCube = function() {
        console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
    }
    ,
    ki.prototype.getActiveMipMapLevel = function() {
        return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),
        this.getActiveMipmapLevel()
    }
    ,
    Object.defineProperties(ki.prototype, {
        shadowMapEnabled: {
            get: function() {
                return this.shadowMap.enabled
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
                this.shadowMap.enabled = e
            }
        },
        shadowMapType: {
            get: function() {
                return this.shadowMap.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
                this.shadowMap.type = e
            }
        },
        shadowMapCullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        context: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),
                this.getContext()
            }
        },
        vr: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),
                this.xr
            }
        },
        gammaInput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),
                !1
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
            }
        },
        gammaOutput: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                !1
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),
                this.outputEncoding = !0 === e ? 3001 : L
            }
        },
        toneMappingWhitePoint: {
            get: function() {
                return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),
                1
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
            }
        }
    }),
    Object.defineProperties(Li.prototype, {
        cullFace: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        },
        renderReverseSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        },
        renderSingleSided: {
            get: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            },
            set: function() {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }),
    Object.defineProperties(V.prototype, {
        wrapS: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
                this.texture.wrapS = e
            }
        },
        wrapT: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
                this.texture.wrapT = e
            }
        },
        magFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
                this.texture.magFilter = e
            }
        },
        minFilter: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
                this.texture.minFilter = e
            }
        },
        anisotropy: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
                this.texture.anisotropy = e
            }
        },
        offset: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
                this.texture.offset = e
            }
        },
        repeat: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
                this.texture.repeat = e
            }
        },
        format: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
                this.texture.format = e
            }
        },
        type: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
                this.texture.type = e
            }
        },
        generateMipmaps: {
            get: function() {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps
            },
            set: function(e) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
                this.texture.generateMipmaps = e
            }
        }
    }),
    gn.prototype.updateCubeMap = function(e, t) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
        this.update(e, t)
    }
    ,
    gn.prototype.clear = function(e, t, n, r) {
        return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),
        this.renderTarget.clear(e, t, n, r)
    }
    ,
    B.crossOrigin = void 0,
    B.loadTexture = function(e, t, n, r) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        const i = new Fo;
        i.setCrossOrigin(this.crossOrigin);
        const o = i.load(e, n, void 0, r);
        return t && (o.mapping = t),
        o
    }
    ,
    B.loadTextureCube = function(e, t, n, r) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        const i = new ko;
        i.setCrossOrigin(this.crossOrigin);
        const o = i.load(e, n, void 0, r);
        return t && (o.mapping = t),
        o
    }
    ,
    B.loadCompressedTexture = function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    B.loadCompressedTextureCube = function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }
    ,
    "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
        detail: {
            revision: "127"
        }
    })),
    "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = "127");
    var Ea = function(e, t, n) {
        var r = new Qe
          , i = new ya
          , o = new k
          , a = new q
          , s = new q
          , c = new q
          , l = new Me
          , u = []
          , h = null
          , d = null
          , p = this;
        function f() {
            n.addEventListener("pointermove", g),
            n.addEventListener("pointerdown", v),
            n.addEventListener("pointerup", y),
            n.addEventListener("pointerleave", y),
            n.addEventListener("touchmove", b),
            n.addEventListener("touchstart", x),
            n.addEventListener("touchend", _)
        }
        function m() {
            n.removeEventListener("pointermove", g),
            n.removeEventListener("pointerdown", v),
            n.removeEventListener("pointerup", y),
            n.removeEventListener("pointerleave", y),
            n.removeEventListener("touchmove", b),
            n.removeEventListener("touchstart", x),
            n.removeEventListener("touchend", _),
            n.style.cursor = ""
        }
        function g(f) {
            switch (f.preventDefault(),
            f.pointerType) {
            case "mouse":
            case "pen":
                !function(f) {
                    var m = n.getBoundingClientRect();
                    if (o.x = (f.clientX - m.left) / m.width * 2 - 1,
                    o.y = -(f.clientY - m.top) / m.height * 2 + 1,
                    i.setFromCamera(o, t),
                    h && p.enabled)
                        return i.ray.intersectPlane(r, s) && h.position.copy(s.sub(a).applyMatrix4(l)),
                        void p.dispatchEvent({
                            type: "drag",
                            object: h
                        });
                    if (u.length = 0,
                    i.setFromCamera(o, t),
                    i.intersectObjects(e, !0, u),
                    u.length > 0) {
                        var g = u[0].object;
                        r.setFromNormalAndCoplanarPoint(t.getWorldDirection(r.normal), c.setFromMatrixPosition(g.matrixWorld)),
                        d !== g && null !== d && (p.dispatchEvent({
                            type: "hoveroff",
                            object: d
                        }),
                        n.style.cursor = "auto",
                        d = null),
                        d !== g && (p.dispatchEvent({
                            type: "hoveron",
                            object: g
                        }),
                        n.style.cursor = "pointer",
                        d = g)
                    } else
                        null !== d && (p.dispatchEvent({
                            type: "hoveroff",
                            object: d
                        }),
                        n.style.cursor = "auto",
                        d = null)
                }(f)
            }
        }
        function v(d) {
            switch (d.preventDefault(),
            d.pointerType) {
            case "mouse":
            case "pen":
                !function(d) {
                    d.preventDefault(),
                    u.length = 0,
                    i.setFromCamera(o, t),
                    i.intersectObjects(e, !0, u),
                    u.length > 0 && (h = !0 === p.transformGroup ? e[0] : u[0].object,
                    i.ray.intersectPlane(r, s) && (l.copy(h.parent.matrixWorld).invert(),
                    a.copy(s).sub(c.setFromMatrixPosition(h.matrixWorld))),
                    n.style.cursor = "move",
                    p.dispatchEvent({
                        type: "dragstart",
                        object: h
                    }))
                }(d)
            }
        }
        function y(e) {
            switch (e.preventDefault(),
            e.pointerType) {
            case "mouse":
            case "pen":
                !function(e) {
                    e.preventDefault(),
                    h && (p.dispatchEvent({
                        type: "dragend",
                        object: h
                    }),
                    h = null);
                    n.style.cursor = d ? "pointer" : "auto"
                }(e)
            }
        }
        function b(e) {
            e.preventDefault(),
            e = e.changedTouches[0];
            var c = n.getBoundingClientRect();
            if (o.x = (e.clientX - c.left) / c.width * 2 - 1,
            o.y = -(e.clientY - c.top) / c.height * 2 + 1,
            i.setFromCamera(o, t),
            h && p.enabled)
                return i.ray.intersectPlane(r, s) && h.position.copy(s.sub(a).applyMatrix4(l)),
                void p.dispatchEvent({
                    type: "drag",
                    object: h
                })
        }
        function x(d) {
            d.preventDefault(),
            d = d.changedTouches[0];
            var f = n.getBoundingClientRect();
            o.x = (d.clientX - f.left) / f.width * 2 - 1,
            o.y = -(d.clientY - f.top) / f.height * 2 + 1,
            u.length = 0,
            i.setFromCamera(o, t),
            i.intersectObjects(e, !0, u),
            u.length > 0 && (h = !0 === p.transformGroup ? e[0] : u[0].object,
            r.setFromNormalAndCoplanarPoint(t.getWorldDirection(r.normal), c.setFromMatrixPosition(h.matrixWorld)),
            i.ray.intersectPlane(r, s) && (l.copy(h.parent.matrixWorld).invert(),
            a.copy(s).sub(c.setFromMatrixPosition(h.matrixWorld))),
            n.style.cursor = "move",
            p.dispatchEvent({
                type: "dragstart",
                object: h
            }))
        }
        function _(e) {
            e.preventDefault(),
            h && (p.dispatchEvent({
                type: "dragend",
                object: h
            }),
            h = null),
            n.style.cursor = "auto"
        }
        f(),
        this.enabled = !0,
        this.transformGroup = !1,
        this.activate = f,
        this.deactivate = m,
        this.dispose = function() {
            m()
        }
        ,
        this.getObjects = function() {
            return e
        }
    };
    function Sa(e, t, n) {
        var r, i = 1;
        function o() {
            var o, a, s = r.length, c = 0, l = 0, u = 0;
            for (o = 0; o < s; ++o)
                c += (a = r[o]).x || 0,
                l += a.y || 0,
                u += a.z || 0;
            for (c = (c / s - e) * i,
            l = (l / s - t) * i,
            u = (u / s - n) * i,
            o = 0; o < s; ++o)
                a = r[o],
                c && (a.x -= c),
                l && (a.y -= l),
                u && (a.z -= u)
        }
        return null == e && (e = 0),
        null == t && (t = 0),
        null == n && (n = 0),
        o.initialize = function(e) {
            r = e
        }
        ,
        o.x = function(t) {
            return arguments.length ? (e = +t,
            o) : e
        }
        ,
        o.y = function(e) {
            return arguments.length ? (t = +e,
            o) : t
        }
        ,
        o.z = function(e) {
            return arguments.length ? (n = +e,
            o) : n
        }
        ,
        o.strength = function(e) {
            return arguments.length ? (i = +e,
            o) : i
        }
        ,
        o
    }
    function Ta(e, t, n) {
        if (isNaN(t))
            return e;
        var r, i, o, a, s, c, l = e._root, u = {
            data: n
        }, h = e._x0, d = e._x1;
        if (!l)
            return e._root = u,
            e;
        for (; l.length; )
            if ((a = t >= (i = (h + d) / 2)) ? h = i : d = i,
            r = l,
            !(l = l[s = +a]))
                return r[s] = u,
                e;
        if (t === (o = +e._x.call(null, l.data)))
            return u.next = l,
            r ? r[s] = u : e._root = u,
            e;
        do {
            r = r ? r[s] = new Array(2) : e._root = new Array(2),
            (a = t >= (i = (h + d) / 2)) ? h = i : d = i
        } while ((s = +a) == (c = +(o >= i)));
        return r[c] = l,
        r[s] = u,
        e
    }
    function La(e, t, n) {
        this.node = e,
        this.x0 = t,
        this.x1 = n
    }
    function Aa(e) {
        return e[0]
    }
    function Pa(e, t) {
        var n = new Ca(null == t ? Aa : t,NaN,NaN);
        return null == e ? n : n.addAll(e)
    }
    function Ca(e, t, n) {
        this._x = e,
        this._x0 = t,
        this._x1 = n,
        this._root = void 0
    }
    function Ra(e) {
        for (var t = {
            data: e.data
        }, n = t; e = e.next; )
            n = n.next = {
                data: e.data
            };
        return t
    }
    (Ea.prototype = Object.create(D.prototype)).constructor = Ea;
    var Da = Pa.prototype = Ca.prototype;
    function Oa(e, t, n, r) {
        if (isNaN(t) || isNaN(n))
            return e;
        var i, o, a, s, c, l, u, h, d, p = e._root, f = {
            data: r
        }, m = e._x0, g = e._y0, v = e._x1, y = e._y1;
        if (!p)
            return e._root = f,
            e;
        for (; p.length; )
            if ((l = t >= (o = (m + v) / 2)) ? m = o : v = o,
            (u = n >= (a = (g + y) / 2)) ? g = a : y = a,
            i = p,
            !(p = p[h = u << 1 | l]))
                return i[h] = f,
                e;
        if (s = +e._x.call(null, p.data),
        c = +e._y.call(null, p.data),
        t === s && n === c)
            return f.next = p,
            i ? i[h] = f : e._root = f,
            e;
        do {
            i = i ? i[h] = new Array(4) : e._root = new Array(4),
            (l = t >= (o = (m + v) / 2)) ? m = o : v = o,
            (u = n >= (a = (g + y) / 2)) ? g = a : y = a
        } while ((h = u << 1 | l) == (d = (c >= a) << 1 | s >= o));
        return i[d] = p,
        i[h] = f,
        e
    }
    function Na(e, t, n, r, i) {
        this.node = e,
        this.x0 = t,
        this.y0 = n,
        this.x1 = r,
        this.y1 = i
    }
    function Ia(e) {
        return e[0]
    }
    function ka(e) {
        return e[1]
    }
    function za(e, t, n) {
        var r = new Fa(null == t ? Ia : t,null == n ? ka : n,NaN,NaN,NaN,NaN);
        return null == e ? r : r.addAll(e)
    }
    function Fa(e, t, n, r, i, o) {
        this._x = e,
        this._y = t,
        this._x0 = n,
        this._y0 = r,
        this._x1 = i,
        this._y1 = o,
        this._root = void 0
    }
    function Ba(e) {
        for (var t = {
            data: e.data
        }, n = t; e = e.next; )
            n = n.next = {
                data: e.data
            };
        return t
    }
    Da.copy = function() {
        var e, t, n = new Ca(this._x,this._x0,this._x1), r = this._root;
        if (!r)
            return n;
        if (!r.length)
            return n._root = Ra(r),
            n;
        for (e = [{
            source: r,
            target: n._root = new Array(2)
        }]; r = e.pop(); )
            for (var i = 0; i < 2; ++i)
                (t = r.source[i]) && (t.length ? e.push({
                    source: t,
                    target: r.target[i] = new Array(2)
                }) : r.target[i] = Ra(t));
        return n
    }
    ,
    Da.add = function(e) {
        var t = +this._x.call(null, e);
        return Ta(this.cover(t), t, e)
    }
    ,
    Da.addAll = function(e) {
        var t, n, r = e.length, i = new Array(r), o = 1 / 0, a = -1 / 0;
        for (t = 0; t < r; ++t)
            isNaN(n = +this._x.call(null, e[t])) || (i[t] = n,
            n < o && (o = n),
            n > a && (a = n));
        if (o > a)
            return this;
        for (this.cover(o).cover(a),
        t = 0; t < r; ++t)
            Ta(this, i[t], e[t]);
        return this
    }
    ,
    Da.cover = function(e) {
        if (isNaN(e = +e))
            return this;
        var t = this._x0
          , n = this._x1;
        if (isNaN(t))
            n = (t = Math.floor(e)) + 1;
        else {
            for (var r, i, o = n - t || 1, a = this._root; t > e || e >= n; )
                switch (i = +(e < t),
                (r = new Array(2))[i] = a,
                a = r,
                o *= 2,
                i) {
                case 0:
                    n = t + o;
                    break;
                case 1:
                    t = n - o
                }
            this._root && this._root.length && (this._root = a)
        }
        return this._x0 = t,
        this._x1 = n,
        this
    }
    ,
    Da.data = function() {
        var e = [];
        return this.visit((function(t) {
            if (!t.length)
                do {
                    e.push(t.data)
                } while (t = t.next)
        }
        )),
        e
    }
    ,
    Da.extent = function(e) {
        return arguments.length ? this.cover(+e[0][0]).cover(+e[1][0]) : isNaN(this._x0) ? void 0 : [[this._x0], [this._x1]]
    }
    ,
    Da.find = function(e, t) {
        var n, r, i, o, a, s = this._x0, c = this._x1, l = [], u = this._root;
        for (u && l.push(new La(u,s,c)),
        null == t ? t = 1 / 0 : (s = e - t,
        c = e + t); o = l.pop(); )
            if (!(!(u = o.node) || (r = o.x0) > c || (i = o.x1) < s))
                if (u.length) {
                    var h = (r + i) / 2;
                    l.push(new La(u[1],h,i), new La(u[0],r,h)),
                    (a = +(e >= h)) && (o = l[l.length - 1],
                    l[l.length - 1] = l[l.length - 1 - a],
                    l[l.length - 1 - a] = o)
                } else {
                    var d = Math.abs(e - +this._x.call(null, u.data));
                    d < t && (t = d,
                    s = e - d,
                    c = e + d,
                    n = u.data)
                }
        return n
    }
    ,
    Da.remove = function(e) {
        if (isNaN(o = +this._x.call(null, e)))
            return this;
        var t, n, r, i, o, a, s, c, l, u = this._root, h = this._x0, d = this._x1;
        if (!u)
            return this;
        if (u.length)
            for (; ; ) {
                if ((s = o >= (a = (h + d) / 2)) ? h = a : d = a,
                t = u,
                !(u = u[c = +s]))
                    return this;
                if (!u.length)
                    break;
                t[c + 1 & 1] && (n = t,
                l = c)
            }
        for (; u.data !== e; )
            if (r = u,
            !(u = u.next))
                return this;
        return (i = u.next) && delete u.next,
        r ? (i ? r.next = i : delete r.next,
        this) : t ? (i ? t[c] = i : delete t[c],
        (u = t[0] || t[1]) && u === (t[1] || t[0]) && !u.length && (n ? n[l] = u : this._root = u),
        this) : (this._root = i,
        this)
    }
    ,
    Da.removeAll = function(e) {
        for (var t = 0, n = e.length; t < n; ++t)
            this.remove(e[t]);
        return this
    }
    ,
    Da.root = function() {
        return this._root
    }
    ,
    Da.size = function() {
        var e = 0;
        return this.visit((function(t) {
            if (!t.length)
                do {
                    ++e
                } while (t = t.next)
        }
        )),
        e
    }
    ,
    Da.visit = function(e) {
        var t, n, r, i, o = [], a = this._root;
        for (a && o.push(new La(a,this._x0,this._x1)); t = o.pop(); )
            if (!e(a = t.node, r = t.x0, i = t.x1) && a.length) {
                var s = (r + i) / 2;
                (n = a[1]) && o.push(new La(n,s,i)),
                (n = a[0]) && o.push(new La(n,r,s))
            }
        return this
    }
    ,
    Da.visitAfter = function(e) {
        var t, n = [], r = [];
        for (this._root && n.push(new La(this._root,this._x0,this._x1)); t = n.pop(); ) {
            var i = t.node;
            if (i.length) {
                var o, a = t.x0, s = t.x1, c = (a + s) / 2;
                (o = i[0]) && n.push(new La(o,a,c)),
                (o = i[1]) && n.push(new La(o,c,s))
            }
            r.push(t)
        }
        for (; t = r.pop(); )
            e(t.node, t.x0, t.x1);
        return this
    }
    ,
    Da.x = function(e) {
        return arguments.length ? (this._x = e,
        this) : this._x
    }
    ;
    var Ua = za.prototype = Fa.prototype;
    function Ha(e, t, n, r, i) {
        if (isNaN(t) || isNaN(n) || isNaN(r))
            return e;
        var o, a, s, c, l, u, h, d, p, f, m, g, v = e._root, y = {
            data: i
        }, b = e._x0, x = e._y0, _ = e._z0, w = e._x1, M = e._y1, E = e._z1;
        if (!v)
            return e._root = y,
            e;
        for (; v.length; )
            if ((d = t >= (a = (b + w) / 2)) ? b = a : w = a,
            (p = n >= (s = (x + M) / 2)) ? x = s : M = s,
            (f = r >= (c = (_ + E) / 2)) ? _ = c : E = c,
            o = v,
            !(v = v[m = f << 2 | p << 1 | d]))
                return o[m] = y,
                e;
        if (l = +e._x.call(null, v.data),
        u = +e._y.call(null, v.data),
        h = +e._z.call(null, v.data),
        t === l && n === u && r === h)
            return y.next = v,
            o ? o[m] = y : e._root = y,
            e;
        do {
            o = o ? o[m] = new Array(8) : e._root = new Array(8),
            (d = t >= (a = (b + w) / 2)) ? b = a : w = a,
            (p = n >= (s = (x + M) / 2)) ? x = s : M = s,
            (f = r >= (c = (_ + E) / 2)) ? _ = c : E = c
        } while ((m = f << 2 | p << 1 | d) == (g = (h >= c) << 2 | (u >= s) << 1 | l >= a));
        return o[g] = v,
        o[m] = y,
        e
    }
    function ja(e, t, n, r, i, o, a) {
        this.node = e,
        this.x0 = t,
        this.y0 = n,
        this.z0 = r,
        this.x1 = i,
        this.y1 = o,
        this.z1 = a
    }
    function Ga(e) {
        return e[0]
    }
    function Va(e) {
        return e[1]
    }
    function Wa(e) {
        return e[2]
    }
    function qa(e, t, n, r) {
        var i = new Xa(null == t ? Ga : t,null == n ? Va : n,null == r ? Wa : r,NaN,NaN,NaN,NaN,NaN,NaN);
        return null == e ? i : i.addAll(e)
    }
    function Xa(e, t, n, r, i, o, a, s, c) {
        this._x = e,
        this._y = t,
        this._z = n,
        this._x0 = r,
        this._y0 = i,
        this._z0 = o,
        this._x1 = a,
        this._y1 = s,
        this._z1 = c,
        this._root = void 0
    }
    function Ya(e) {
        for (var t = {
            data: e.data
        }, n = t; e = e.next; )
            n = n.next = {
                data: e.data
            };
        return t
    }
    Ua.copy = function() {
        var e, t, n = new Fa(this._x,this._y,this._x0,this._y0,this._x1,this._y1), r = this._root;
        if (!r)
            return n;
        if (!r.length)
            return n._root = Ba(r),
            n;
        for (e = [{
            source: r,
            target: n._root = new Array(4)
        }]; r = e.pop(); )
            for (var i = 0; i < 4; ++i)
                (t = r.source[i]) && (t.length ? e.push({
                    source: t,
                    target: r.target[i] = new Array(4)
                }) : r.target[i] = Ba(t));
        return n
    }
    ,
    Ua.add = function(e) {
        const t = +this._x.call(null, e)
          , n = +this._y.call(null, e);
        return Oa(this.cover(t, n), t, n, e)
    }
    ,
    Ua.addAll = function(e) {
        var t, n, r, i, o = e.length, a = new Array(o), s = new Array(o), c = 1 / 0, l = 1 / 0, u = -1 / 0, h = -1 / 0;
        for (n = 0; n < o; ++n)
            isNaN(r = +this._x.call(null, t = e[n])) || isNaN(i = +this._y.call(null, t)) || (a[n] = r,
            s[n] = i,
            r < c && (c = r),
            r > u && (u = r),
            i < l && (l = i),
            i > h && (h = i));
        if (c > u || l > h)
            return this;
        for (this.cover(c, l).cover(u, h),
        n = 0; n < o; ++n)
            Oa(this, a[n], s[n], e[n]);
        return this
    }
    ,
    Ua.cover = function(e, t) {
        if (isNaN(e = +e) || isNaN(t = +t))
            return this;
        var n = this._x0
          , r = this._y0
          , i = this._x1
          , o = this._y1;
        if (isNaN(n))
            i = (n = Math.floor(e)) + 1,
            o = (r = Math.floor(t)) + 1;
        else {
            for (var a, s, c = i - n || 1, l = this._root; n > e || e >= i || r > t || t >= o; )
                switch (s = (t < r) << 1 | e < n,
                (a = new Array(4))[s] = l,
                l = a,
                c *= 2,
                s) {
                case 0:
                    i = n + c,
                    o = r + c;
                    break;
                case 1:
                    n = i - c,
                    o = r + c;
                    break;
                case 2:
                    i = n + c,
                    r = o - c;
                    break;
                case 3:
                    n = i - c,
                    r = o - c
                }
            this._root && this._root.length && (this._root = l)
        }
        return this._x0 = n,
        this._y0 = r,
        this._x1 = i,
        this._y1 = o,
        this
    }
    ,
    Ua.data = function() {
        var e = [];
        return this.visit((function(t) {
            if (!t.length)
                do {
                    e.push(t.data)
                } while (t = t.next)
        }
        )),
        e
    }
    ,
    Ua.extent = function(e) {
        return arguments.length ? this.cover(+e[0][0], +e[0][1]).cover(+e[1][0], +e[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]]
    }
    ,
    Ua.find = function(e, t, n) {
        var r, i, o, a, s, c, l, u = this._x0, h = this._y0, d = this._x1, p = this._y1, f = [], m = this._root;
        for (m && f.push(new Na(m,u,h,d,p)),
        null == n ? n = 1 / 0 : (u = e - n,
        h = t - n,
        d = e + n,
        p = t + n,
        n *= n); c = f.pop(); )
            if (!(!(m = c.node) || (i = c.x0) > d || (o = c.y0) > p || (a = c.x1) < u || (s = c.y1) < h))
                if (m.length) {
                    var g = (i + a) / 2
                      , v = (o + s) / 2;
                    f.push(new Na(m[3],g,v,a,s), new Na(m[2],i,v,g,s), new Na(m[1],g,o,a,v), new Na(m[0],i,o,g,v)),
                    (l = (t >= v) << 1 | e >= g) && (c = f[f.length - 1],
                    f[f.length - 1] = f[f.length - 1 - l],
                    f[f.length - 1 - l] = c)
                } else {
                    var y = e - +this._x.call(null, m.data)
                      , b = t - +this._y.call(null, m.data)
                      , x = y * y + b * b;
                    if (x < n) {
                        var _ = Math.sqrt(n = x);
                        u = e - _,
                        h = t - _,
                        d = e + _,
                        p = t + _,
                        r = m.data
                    }
                }
        return r
    }
    ,
    Ua.remove = function(e) {
        if (isNaN(o = +this._x.call(null, e)) || isNaN(a = +this._y.call(null, e)))
            return this;
        var t, n, r, i, o, a, s, c, l, u, h, d, p = this._root, f = this._x0, m = this._y0, g = this._x1, v = this._y1;
        if (!p)
            return this;
        if (p.length)
            for (; ; ) {
                if ((l = o >= (s = (f + g) / 2)) ? f = s : g = s,
                (u = a >= (c = (m + v) / 2)) ? m = c : v = c,
                t = p,
                !(p = p[h = u << 1 | l]))
                    return this;
                if (!p.length)
                    break;
                (t[h + 1 & 3] || t[h + 2 & 3] || t[h + 3 & 3]) && (n = t,
                d = h)
            }
        for (; p.data !== e; )
            if (r = p,
            !(p = p.next))
                return this;
        return (i = p.next) && delete p.next,
        r ? (i ? r.next = i : delete r.next,
        this) : t ? (i ? t[h] = i : delete t[h],
        (p = t[0] || t[1] || t[2] || t[3]) && p === (t[3] || t[2] || t[1] || t[0]) && !p.length && (n ? n[d] = p : this._root = p),
        this) : (this._root = i,
        this)
    }
    ,
    Ua.removeAll = function(e) {
        for (var t = 0, n = e.length; t < n; ++t)
            this.remove(e[t]);
        return this
    }
    ,
    Ua.root = function() {
        return this._root
    }
    ,
    Ua.size = function() {
        var e = 0;
        return this.visit((function(t) {
            if (!t.length)
                do {
                    ++e
                } while (t = t.next)
        }
        )),
        e
    }
    ,
    Ua.visit = function(e) {
        var t, n, r, i, o, a, s = [], c = this._root;
        for (c && s.push(new Na(c,this._x0,this._y0,this._x1,this._y1)); t = s.pop(); )
            if (!e(c = t.node, r = t.x0, i = t.y0, o = t.x1, a = t.y1) && c.length) {
                var l = (r + o) / 2
                  , u = (i + a) / 2;
                (n = c[3]) && s.push(new Na(n,l,u,o,a)),
                (n = c[2]) && s.push(new Na(n,r,u,l,a)),
                (n = c[1]) && s.push(new Na(n,l,i,o,u)),
                (n = c[0]) && s.push(new Na(n,r,i,l,u))
            }
        return this
    }
    ,
    Ua.visitAfter = function(e) {
        var t, n = [], r = [];
        for (this._root && n.push(new Na(this._root,this._x0,this._y0,this._x1,this._y1)); t = n.pop(); ) {
            var i = t.node;
            if (i.length) {
                var o, a = t.x0, s = t.y0, c = t.x1, l = t.y1, u = (a + c) / 2, h = (s + l) / 2;
                (o = i[0]) && n.push(new Na(o,a,s,u,h)),
                (o = i[1]) && n.push(new Na(o,u,s,c,h)),
                (o = i[2]) && n.push(new Na(o,a,h,u,l)),
                (o = i[3]) && n.push(new Na(o,u,h,c,l))
            }
            r.push(t)
        }
        for (; t = r.pop(); )
            e(t.node, t.x0, t.y0, t.x1, t.y1);
        return this
    }
    ,
    Ua.x = function(e) {
        return arguments.length ? (this._x = e,
        this) : this._x
    }
    ,
    Ua.y = function(e) {
        return arguments.length ? (this._y = e,
        this) : this._y
    }
    ;
    var Za = qa.prototype = Xa.prototype;
    function $a(e) {
        return function() {
            return e
        }
    }
    function Ja(e) {
        return 1e-6 * (e() - .5)
    }
    function Qa(e) {
        return e.index
    }
    function Ka(e, t) {
        var n = e.get(t);
        if (!n)
            throw new Error("node not found: " + t);
        return n
    }
    function es(e) {
        var t, n, r, i, o, a, s, c = Qa, l = function(e) {
            return 1 / Math.min(o[e.source.index], o[e.target.index])
        }, u = $a(30), h = 1;
        function d(r) {
            for (var o = 0, c = e.length; o < h; ++o)
                for (var l, u, d, p, f, m = 0, g = 0, v = 0, y = 0; m < c; ++m)
                    u = (l = e[m]).source,
                    g = (d = l.target).x + d.vx - u.x - u.vx || Ja(s),
                    i > 1 && (v = d.y + d.vy - u.y - u.vy || Ja(s)),
                    i > 2 && (y = d.z + d.vz - u.z - u.vz || Ja(s)),
                    g *= p = ((p = Math.sqrt(g * g + v * v + y * y)) - n[m]) / p * r * t[m],
                    v *= p,
                    y *= p,
                    d.vx -= g * (f = a[m]),
                    i > 1 && (d.vy -= v * f),
                    i > 2 && (d.vz -= y * f),
                    u.vx += g * (f = 1 - f),
                    i > 1 && (u.vy += v * f),
                    i > 2 && (u.vz += y * f)
        }
        function p() {
            if (r) {
                var i, s, l = r.length, u = e.length, h = new Map(r.map(((e,t)=>[c(e, t, r), e])));
                for (i = 0,
                o = new Array(l); i < u; ++i)
                    (s = e[i]).index = i,
                    "object" != typeof s.source && (s.source = Ka(h, s.source)),
                    "object" != typeof s.target && (s.target = Ka(h, s.target)),
                    o[s.source.index] = (o[s.source.index] || 0) + 1,
                    o[s.target.index] = (o[s.target.index] || 0) + 1;
                for (i = 0,
                a = new Array(u); i < u; ++i)
                    s = e[i],
                    a[i] = o[s.source.index] / (o[s.source.index] + o[s.target.index]);
                t = new Array(u),
                f(),
                n = new Array(u),
                m()
            }
        }
        function f() {
            if (r)
                for (var n = 0, i = e.length; n < i; ++n)
                    t[n] = +l(e[n], n, e)
        }
        function m() {
            if (r)
                for (var t = 0, i = e.length; t < i; ++t)
                    n[t] = +u(e[t], t, e)
        }
        return null == e && (e = []),
        d.initialize = function(e, ...t) {
            r = e,
            s = t.find((e=>"function" == typeof e)) || Math.random,
            i = t.find((e=>[1, 2, 3].includes(e))) || 2,
            p()
        }
        ,
        d.links = function(t) {
            return arguments.length ? (e = t,
            p(),
            d) : e
        }
        ,
        d.id = function(e) {
            return arguments.length ? (c = e,
            d) : c
        }
        ,
        d.iterations = function(e) {
            return arguments.length ? (h = +e,
            d) : h
        }
        ,
        d.strength = function(e) {
            return arguments.length ? (l = "function" == typeof e ? e : $a(+e),
            f(),
            d) : l
        }
        ,
        d.distance = function(e) {
            return arguments.length ? (u = "function" == typeof e ? e : $a(+e),
            m(),
            d) : u
        }
        ,
        d
    }
    Za.copy = function() {
        var e, t, n = new Xa(this._x,this._y,this._z,this._x0,this._y0,this._z0,this._x1,this._y1,this._z1), r = this._root;
        if (!r)
            return n;
        if (!r.length)
            return n._root = Ya(r),
            n;
        for (e = [{
            source: r,
            target: n._root = new Array(8)
        }]; r = e.pop(); )
            for (var i = 0; i < 8; ++i)
                (t = r.source[i]) && (t.length ? e.push({
                    source: t,
                    target: r.target[i] = new Array(8)
                }) : r.target[i] = Ya(t));
        return n
    }
    ,
    Za.add = function(e) {
        var t = +this._x.call(null, e)
          , n = +this._y.call(null, e)
          , r = +this._z.call(null, e);
        return Ha(this.cover(t, n, r), t, n, r, e)
    }
    ,
    Za.addAll = function(e) {
        var t, n, r, i, o, a = e.length, s = new Array(a), c = new Array(a), l = new Array(a), u = 1 / 0, h = 1 / 0, d = 1 / 0, p = -1 / 0, f = -1 / 0, m = -1 / 0;
        for (n = 0; n < a; ++n)
            isNaN(r = +this._x.call(null, t = e[n])) || isNaN(i = +this._y.call(null, t)) || isNaN(o = +this._z.call(null, t)) || (s[n] = r,
            c[n] = i,
            l[n] = o,
            r < u && (u = r),
            r > p && (p = r),
            i < h && (h = i),
            i > f && (f = i),
            o < d && (d = o),
            o > m && (m = o));
        if (u > p || h > f || d > m)
            return this;
        for (this.cover(u, h, d).cover(p, f, m),
        n = 0; n < a; ++n)
            Ha(this, s[n], c[n], l[n], e[n]);
        return this
    }
    ,
    Za.cover = function(e, t, n) {
        if (isNaN(e = +e) || isNaN(t = +t) || isNaN(n = +n))
            return this;
        var r = this._x0
          , i = this._y0
          , o = this._z0
          , a = this._x1
          , s = this._y1
          , c = this._z1;
        if (isNaN(r))
            a = (r = Math.floor(e)) + 1,
            s = (i = Math.floor(t)) + 1,
            c = (o = Math.floor(n)) + 1;
        else {
            for (var l, u, h = a - r || 1, d = this._root; r > e || e >= a || i > t || t >= s || o > n || n >= c; )
                switch (u = (n < o) << 2 | (t < i) << 1 | e < r,
                (l = new Array(8))[u] = d,
                d = l,
                h *= 2,
                u) {
                case 0:
                    a = r + h,
                    s = i + h,
                    c = o + h;
                    break;
                case 1:
                    r = a - h,
                    s = i + h,
                    c = o + h;
                    break;
                case 2:
                    a = r + h,
                    i = s - h,
                    c = o + h;
                    break;
                case 3:
                    r = a - h,
                    i = s - h,
                    c = o + h;
                    break;
                case 4:
                    a = r + h,
                    s = i + h,
                    o = c - h;
                    break;
                case 5:
                    r = a - h,
                    s = i + h,
                    o = c - h;
                    break;
                case 6:
                    a = r + h,
                    i = s - h,
                    o = c - h;
                    break;
                case 7:
                    r = a - h,
                    i = s - h,
                    o = c - h
                }
            this._root && this._root.length && (this._root = d)
        }
        return this._x0 = r,
        this._y0 = i,
        this._z0 = o,
        this._x1 = a,
        this._y1 = s,
        this._z1 = c,
        this
    }
    ,
    Za.data = function() {
        var e = [];
        return this.visit((function(t) {
            if (!t.length)
                do {
                    e.push(t.data)
                } while (t = t.next)
        }
        )),
        e
    }
    ,
    Za.extent = function(e) {
        return arguments.length ? this.cover(+e[0][0], +e[0][1], +e[0][2]).cover(+e[1][0], +e[1][1], +e[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]]
    }
    ,
    Za.find = function(e, t, n, r) {
        var i, o, a, s, c, l, u, h, d, p = this._x0, f = this._y0, m = this._z0, g = this._x1, v = this._y1, y = this._z1, b = [], x = this._root;
        for (x && b.push(new ja(x,p,f,m,g,v,y)),
        null == r ? r = 1 / 0 : (p = e - r,
        f = t - r,
        m = n - r,
        g = e + r,
        v = t + r,
        y = n + r,
        r *= r); h = b.pop(); )
            if (!(!(x = h.node) || (o = h.x0) > g || (a = h.y0) > v || (s = h.z0) > y || (c = h.x1) < p || (l = h.y1) < f || (u = h.z1) < m))
                if (x.length) {
                    var _ = (o + c) / 2
                      , w = (a + l) / 2
                      , M = (s + u) / 2;
                    b.push(new ja(x[7],_,w,M,c,l,u), new ja(x[6],o,w,M,_,l,u), new ja(x[5],_,a,M,c,w,u), new ja(x[4],o,a,M,_,w,u), new ja(x[3],_,w,s,c,l,M), new ja(x[2],o,w,s,_,l,M), new ja(x[1],_,a,s,c,w,M), new ja(x[0],o,a,s,_,w,M)),
                    (d = (n >= M) << 2 | (t >= w) << 1 | e >= _) && (h = b[b.length - 1],
                    b[b.length - 1] = b[b.length - 1 - d],
                    b[b.length - 1 - d] = h)
                } else {
                    var E = e - +this._x.call(null, x.data)
                      , S = t - +this._y.call(null, x.data)
                      , T = n - +this._z.call(null, x.data)
                      , L = E * E + S * S + T * T;
                    if (L < r) {
                        var A = Math.sqrt(r = L);
                        p = e - A,
                        f = t - A,
                        m = n - A,
                        g = e + A,
                        v = t + A,
                        y = n + A,
                        i = x.data
                    }
                }
        return i
    }
    ,
    Za.remove = function(e) {
        if (isNaN(o = +this._x.call(null, e)) || isNaN(a = +this._y.call(null, e)) || isNaN(s = +this._z.call(null, e)))
            return this;
        var t, n, r, i, o, a, s, c, l, u, h, d, p, f, m, g = this._root, v = this._x0, y = this._y0, b = this._z0, x = this._x1, _ = this._y1, w = this._z1;
        if (!g)
            return this;
        if (g.length)
            for (; ; ) {
                if ((h = o >= (c = (v + x) / 2)) ? v = c : x = c,
                (d = a >= (l = (y + _) / 2)) ? y = l : _ = l,
                (p = s >= (u = (b + w) / 2)) ? b = u : w = u,
                t = g,
                !(g = g[f = p << 2 | d << 1 | h]))
                    return this;
                if (!g.length)
                    break;
                (t[f + 1 & 7] || t[f + 2 & 7] || t[f + 3 & 7] || t[f + 4 & 7] || t[f + 5 & 7] || t[f + 6 & 7] || t[f + 7 & 7]) && (n = t,
                m = f)
            }
        for (; g.data !== e; )
            if (r = g,
            !(g = g.next))
                return this;
        return (i = g.next) && delete g.next,
        r ? (i ? r.next = i : delete r.next,
        this) : t ? (i ? t[f] = i : delete t[f],
        (g = t[0] || t[1] || t[2] || t[3] || t[4] || t[5] || t[6] || t[7]) && g === (t[7] || t[6] || t[5] || t[4] || t[3] || t[2] || t[1] || t[0]) && !g.length && (n ? n[m] = g : this._root = g),
        this) : (this._root = i,
        this)
    }
    ,
    Za.removeAll = function(e) {
        for (var t = 0, n = e.length; t < n; ++t)
            this.remove(e[t]);
        return this
    }
    ,
    Za.root = function() {
        return this._root
    }
    ,
    Za.size = function() {
        var e = 0;
        return this.visit((function(t) {
            if (!t.length)
                do {
                    ++e
                } while (t = t.next)
        }
        )),
        e
    }
    ,
    Za.visit = function(e) {
        var t, n, r, i, o, a, s, c, l = [], u = this._root;
        for (u && l.push(new ja(u,this._x0,this._y0,this._z0,this._x1,this._y1,this._z1)); t = l.pop(); )
            if (!e(u = t.node, r = t.x0, i = t.y0, o = t.z0, a = t.x1, s = t.y1, c = t.z1) && u.length) {
                var h = (r + a) / 2
                  , d = (i + s) / 2
                  , p = (o + c) / 2;
                (n = u[7]) && l.push(new ja(n,h,d,p,a,s,c)),
                (n = u[6]) && l.push(new ja(n,r,d,p,h,s,c)),
                (n = u[5]) && l.push(new ja(n,h,i,p,a,d,c)),
                (n = u[4]) && l.push(new ja(n,r,i,p,h,d,c)),
                (n = u[3]) && l.push(new ja(n,h,d,o,a,s,p)),
                (n = u[2]) && l.push(new ja(n,r,d,o,h,s,p)),
                (n = u[1]) && l.push(new ja(n,h,i,o,a,d,p)),
                (n = u[0]) && l.push(new ja(n,r,i,o,h,d,p))
            }
        return this
    }
    ,
    Za.visitAfter = function(e) {
        var t, n = [], r = [];
        for (this._root && n.push(new ja(this._root,this._x0,this._y0,this._z0,this._x1,this._y1,this._z1)); t = n.pop(); ) {
            var i = t.node;
            if (i.length) {
                var o, a = t.x0, s = t.y0, c = t.z0, l = t.x1, u = t.y1, h = t.z1, d = (a + l) / 2, p = (s + u) / 2, f = (c + h) / 2;
                (o = i[0]) && n.push(new ja(o,a,s,c,d,p,f)),
                (o = i[1]) && n.push(new ja(o,d,s,c,l,p,f)),
                (o = i[2]) && n.push(new ja(o,a,p,c,d,u,f)),
                (o = i[3]) && n.push(new ja(o,d,p,c,l,u,f)),
                (o = i[4]) && n.push(new ja(o,a,s,f,d,p,h)),
                (o = i[5]) && n.push(new ja(o,d,s,f,l,p,h)),
                (o = i[6]) && n.push(new ja(o,a,p,f,d,u,h)),
                (o = i[7]) && n.push(new ja(o,d,p,f,l,u,h))
            }
            r.push(t)
        }
        for (; t = r.pop(); )
            e(t.node, t.x0, t.y0, t.z0, t.x1, t.y1, t.z1);
        return this
    }
    ,
    Za.x = function(e) {
        return arguments.length ? (this._x = e,
        this) : this._x
    }
    ,
    Za.y = function(e) {
        return arguments.length ? (this._y = e,
        this) : this._y
    }
    ,
    Za.z = function(e) {
        return arguments.length ? (this._z = e,
        this) : this._z
    }
    ;
    var ts = {
        value: ()=>{}
    };
    function ns() {
        for (var e, t = 0, n = arguments.length, r = {}; t < n; ++t) {
            if (!(e = arguments[t] + "") || e in r || /[\s.]/.test(e))
                throw new Error("illegal type: " + e);
            r[e] = []
        }
        return new rs(r)
    }
    function rs(e) {
        this._ = e
    }
    function is(e, t) {
        return e.trim().split(/^|\s+/).map((function(e) {
            var n = ""
              , r = e.indexOf(".");
            if (r >= 0 && (n = e.slice(r + 1),
            e = e.slice(0, r)),
            e && !t.hasOwnProperty(e))
                throw new Error("unknown type: " + e);
            return {
                type: e,
                name: n
            }
        }
        ))
    }
    function os(e, t) {
        for (var n, r = 0, i = e.length; r < i; ++r)
            if ((n = e[r]).name === t)
                return n.value
    }
    function as(e, t, n) {
        for (var r = 0, i = e.length; r < i; ++r)
            if (e[r].name === t) {
                e[r] = ts,
                e = e.slice(0, r).concat(e.slice(r + 1));
                break
            }
        return null != n && e.push({
            name: t,
            value: n
        }),
        e
    }
    rs.prototype = ns.prototype = {
        constructor: rs,
        on: function(e, t) {
            var n, r = this._, i = is(e + "", r), o = -1, a = i.length;
            if (!(arguments.length < 2)) {
                if (null != t && "function" != typeof t)
                    throw new Error("invalid callback: " + t);
                for (; ++o < a; )
                    if (n = (e = i[o]).type)
                        r[n] = as(r[n], e.name, t);
                    else if (null == t)
                        for (n in r)
                            r[n] = as(r[n], e.name, null);
                return this
            }
            for (; ++o < a; )
                if ((n = (e = i[o]).type) && (n = os(r[n], e.name)))
                    return n
        },
        copy: function() {
            var e = {}
              , t = this._;
            for (var n in t)
                e[n] = t[n].slice();
            return new rs(e)
        },
        call: function(e, t) {
            if ((n = arguments.length - 2) > 0)
                for (var n, r, i = new Array(n), o = 0; o < n; ++o)
                    i[o] = arguments[o + 2];
            if (!this._.hasOwnProperty(e))
                throw new Error("unknown type: " + e);
            for (o = 0,
            n = (r = this._[e]).length; o < n; ++o)
                r[o].value.apply(t, i)
        },
        apply: function(e, t, n) {
            if (!this._.hasOwnProperty(e))
                throw new Error("unknown type: " + e);
            for (var r = this._[e], i = 0, o = r.length; i < o; ++i)
                r[i].value.apply(t, n)
        }
    };
    var ss, cs, ls = 0, us = 0, hs = 0, ds = 0, ps = 0, fs = 0, ms = "object" == typeof performance && performance.now ? performance : Date, gs = "object" == typeof window && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
        setTimeout(e, 17)
    }
    ;
    function vs() {
        return ps || (gs(ys),
        ps = ms.now() + fs)
    }
    function ys() {
        ps = 0
    }
    function bs() {
        this._call = this._time = this._next = null
    }
    function xs(e, t, n) {
        var r = new bs;
        return r.restart(e, t, n),
        r
    }
    function _s() {
        ps = (ds = ms.now()) + fs,
        ls = us = 0;
        try {
            !function() {
                vs(),
                ++ls;
                for (var e, t = ss; t; )
                    (e = ps - t._time) >= 0 && t._call.call(null, e),
                    t = t._next;
                --ls
            }()
        } finally {
            ls = 0,
            function() {
                var e, t, n = ss, r = 1 / 0;
                for (; n; )
                    n._call ? (r > n._time && (r = n._time),
                    e = n,
                    n = n._next) : (t = n._next,
                    n._next = null,
                    n = e ? e._next = t : ss = t);
                cs = e,
                Ms(r)
            }(),
            ps = 0
        }
    }
    function ws() {
        var e = ms.now()
          , t = e - ds;
        t > 1e3 && (fs -= t,
        ds = e)
    }
    function Ms(e) {
        ls || (us && (us = clearTimeout(us)),
        e - ps > 24 ? (e < 1 / 0 && (us = setTimeout(_s, e - ms.now() - fs)),
        hs && (hs = clearInterval(hs))) : (hs || (ds = ms.now(),
        hs = setInterval(ws, 1e3)),
        ls = 1,
        gs(_s)))
    }
    bs.prototype = xs.prototype = {
        constructor: bs,
        restart: function(e, t, n) {
            if ("function" != typeof e)
                throw new TypeError("callback is not a function");
            n = (null == n ? vs() : +n) + (null == t ? 0 : +t),
            this._next || cs === this || (cs ? cs._next = this : ss = this,
            cs = this),
            this._call = e,
            this._time = n,
            Ms()
        },
        stop: function() {
            this._call && (this._call = null,
            this._time = 1 / 0,
            Ms())
        }
    };
    const Es = 4294967296;
    function Ss(e) {
        return e.x
    }
    function Ts(e) {
        return e.y
    }
    function Ls(e) {
        return e.z
    }
    var As = Math.PI * (3 - Math.sqrt(5))
      , Ps = 20 * Math.PI / (9 + Math.sqrt(221));
    function Cs(e, t) {
        t = t || 2;
        var n, r = Math.min(3, Math.max(1, Math.round(t))), i = 1, o = .001, a = 1 - Math.pow(o, 1 / 300), s = 0, c = .6, l = new Map, u = xs(p), h = ns("tick", "end"), d = function() {
            let e = 1;
            return ()=>(e = (1664525 * e + 1013904223) % Es) / Es
        }();
        function p() {
            f(),
            h.call("tick", n),
            i < o && (u.stop(),
            h.call("end", n))
        }
        function f(t) {
            var o, u, h = e.length;
            void 0 === t && (t = 1);
            for (var d = 0; d < t; ++d)
                for (i += (s - i) * a,
                l.forEach((function(e) {
                    e(i)
                }
                )),
                o = 0; o < h; ++o)
                    null == (u = e[o]).fx ? u.x += u.vx *= c : (u.x = u.fx,
                    u.vx = 0),
                    r > 1 && (null == u.fy ? u.y += u.vy *= c : (u.y = u.fy,
                    u.vy = 0)),
                    r > 2 && (null == u.fz ? u.z += u.vz *= c : (u.z = u.fz,
                    u.vz = 0));
            return n
        }
        function m() {
            for (var t, n = 0, i = e.length; n < i; ++n) {
                if ((t = e[n]).index = n,
                null != t.fx && (t.x = t.fx),
                null != t.fy && (t.y = t.fy),
                null != t.fz && (t.z = t.fz),
                isNaN(t.x) || r > 1 && isNaN(t.y) || r > 2 && isNaN(t.z)) {
                    var o = 10 * (r > 2 ? Math.cbrt(.5 + n) : r > 1 ? Math.sqrt(.5 + n) : n)
                      , a = n * As
                      , s = n * Ps;
                    1 === r ? t.x = o : 2 === r ? (t.x = o * Math.cos(a),
                    t.y = o * Math.sin(a)) : (t.x = o * Math.sin(a) * Math.cos(s),
                    t.y = o * Math.cos(a),
                    t.z = o * Math.sin(a) * Math.sin(s))
                }
                (isNaN(t.vx) || r > 1 && isNaN(t.vy) || r > 2 && isNaN(t.vz)) && (t.vx = 0,
                r > 1 && (t.vy = 0),
                r > 2 && (t.vz = 0))
            }
        }
        function g(t) {
            return t.initialize && t.initialize(e, d, r),
            t
        }
        return null == e && (e = []),
        m(),
        n = {
            tick: f,
            restart: function() {
                return u.restart(p),
                n
            },
            stop: function() {
                return u.stop(),
                n
            },
            numDimensions: function(e) {
                return arguments.length ? (r = Math.min(3, Math.max(1, Math.round(e))),
                l.forEach(g),
                n) : r
            },
            nodes: function(t) {
                return arguments.length ? (e = t,
                m(),
                l.forEach(g),
                n) : e
            },
            alpha: function(e) {
                return arguments.length ? (i = +e,
                n) : i
            },
            alphaMin: function(e) {
                return arguments.length ? (o = +e,
                n) : o
            },
            alphaDecay: function(e) {
                return arguments.length ? (a = +e,
                n) : +a
            },
            alphaTarget: function(e) {
                return arguments.length ? (s = +e,
                n) : s
            },
            velocityDecay: function(e) {
                return arguments.length ? (c = 1 - e,
                n) : 1 - c
            },
            randomSource: function(e) {
                return arguments.length ? (d = e,
                l.forEach(g),
                n) : d
            },
            force: function(e, t) {
                return arguments.length > 1 ? (null == t ? l.delete(e) : l.set(e, g(t)),
                n) : l.get(e)
            },
            find: function() {
                var t, n, i, o, a, s, c = Array.prototype.slice.call(arguments), l = c.shift() || 0, u = (r > 1 ? c.shift() : null) || 0, h = (r > 2 ? c.shift() : null) || 0, d = c.shift() || 1 / 0, p = 0, f = e.length;
                for (d *= d,
                p = 0; p < f; ++p)
                    (o = (t = l - (a = e[p]).x) * t + (n = u - (a.y || 0)) * n + (i = h - (a.z || 0)) * i) < d && (s = a,
                    d = o);
                return s
            },
            on: function(e, t) {
                return arguments.length > 1 ? (h.on(e, t),
                n) : h.on(e)
            }
        }
    }
    function Rs() {
        var e, t, n, r, i, o, a = $a(-30), s = 1, c = 1 / 0, l = .81;
        function u(r) {
            var o, a = e.length, s = (1 === t ? Pa(e, Ss) : 2 === t ? za(e, Ss, Ts) : 3 === t ? qa(e, Ss, Ts, Ls) : null).visitAfter(d);
            for (i = r,
            o = 0; o < a; ++o)
                n = e[o],
                s.visit(p)
        }
        function h() {
            if (e) {
                var t, n, r = e.length;
                for (o = new Array(r),
                t = 0; t < r; ++t)
                    n = e[t],
                    o[n.index] = +a(n, t, e)
            }
        }
        function d(e) {
            var n, r, i, a, s, c, l = 0, u = 0, h = e.length;
            if (h) {
                for (i = a = s = c = 0; c < h; ++c)
                    (n = e[c]) && (r = Math.abs(n.value)) && (l += n.value,
                    u += r,
                    i += r * (n.x || 0),
                    a += r * (n.y || 0),
                    s += r * (n.z || 0));
                l *= Math.sqrt(4 / h),
                e.x = i / u,
                t > 1 && (e.y = a / u),
                t > 2 && (e.z = s / u)
            } else {
                (n = e).x = n.data.x,
                t > 1 && (n.y = n.data.y),
                t > 2 && (n.z = n.data.z);
                do {
                    l += o[n.data.index]
                } while (n = n.next)
            }
            e.value = l
        }
        function p(e, a, u, h, d) {
            if (!e.value)
                return !0;
            var p = [u, h, d][t - 1]
              , f = e.x - n.x
              , m = t > 1 ? e.y - n.y : 0
              , g = t > 2 ? e.z - n.z : 0
              , v = p - a
              , y = f * f + m * m + g * g;
            if (v * v / l < y)
                return y < c && (0 === f && (y += (f = Ja(r)) * f),
                t > 1 && 0 === m && (y += (m = Ja(r)) * m),
                t > 2 && 0 === g && (y += (g = Ja(r)) * g),
                y < s && (y = Math.sqrt(s * y)),
                n.vx += f * e.value * i / y,
                t > 1 && (n.vy += m * e.value * i / y),
                t > 2 && (n.vz += g * e.value * i / y)),
                !0;
            if (!(e.length || y >= c)) {
                (e.data !== n || e.next) && (0 === f && (y += (f = Ja(r)) * f),
                t > 1 && 0 === m && (y += (m = Ja(r)) * m),
                t > 2 && 0 === g && (y += (g = Ja(r)) * g),
                y < s && (y = Math.sqrt(s * y)));
                do {
                    e.data !== n && (v = o[e.data.index] * i / y,
                    n.vx += f * v,
                    t > 1 && (n.vy += m * v),
                    t > 2 && (n.vz += g * v))
                } while (e = e.next)
            }
        }
        return u.initialize = function(n, ...i) {
            e = n,
            r = i.find((e=>"function" == typeof e)) || Math.random,
            t = i.find((e=>[1, 2, 3].includes(e))) || 2,
            h()
        }
        ,
        u.strength = function(e) {
            return arguments.length ? (a = "function" == typeof e ? e : $a(+e),
            h(),
            u) : a
        }
        ,
        u.distanceMin = function(e) {
            return arguments.length ? (s = e * e,
            u) : Math.sqrt(s)
        }
        ,
        u.distanceMax = function(e) {
            return arguments.length ? (c = e * e,
            u) : Math.sqrt(c)
        }
        ,
        u.theta = function(e) {
            return arguments.length ? (l = e * e,
            u) : Math.sqrt(l)
        }
        ,
        u
    }
    var Ds = function(e) {
        !function(e) {
            if (!e)
                throw new Error("Eventify cannot use falsy object as events subject");
            for (var t = ["on", "fire", "off"], n = 0; n < t.length; ++n)
                if (e.hasOwnProperty(t[n]))
                    throw new Error("Subject cannot be eventified, since it already has property '" + t[n] + "'")
        }(e);
        var t = function(e) {
            var t = Object.create(null);
            return {
                on: function(n, r, i) {
                    if ("function" != typeof r)
                        throw new Error("callback is expected to be a function");
                    var o = t[n];
                    return o || (o = t[n] = []),
                    o.push({
                        callback: r,
                        ctx: i
                    }),
                    e
                },
                off: function(n, r) {
                    if (void 0 === n)
                        return t = Object.create(null),
                        e;
                    if (t[n])
                        if ("function" != typeof r)
                            delete t[n];
                        else
                            for (var i = t[n], o = 0; o < i.length; ++o)
                                i[o].callback === r && i.splice(o, 1);
                    return e
                },
                fire: function(n) {
                    var r, i = t[n];
                    if (!i)
                        return e;
                    arguments.length > 1 && (r = Array.prototype.splice.call(arguments, 1));
                    for (var o = 0; o < i.length; ++o) {
                        var a = i[o];
                        a.callback.apply(a.ctx, r)
                    }
                    return e
                }
            }
        }(e);
        return e.on = t.on,
        e.off = t.off,
        e.fire = t.fire,
        e
    };
    var Os = function(e) {
        "uniqueLinkId"in (e = e || {}) && (console.warn("ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\nUse `multigraph` option instead\n", "\n", "Note: there is also change in default behavior: From now on each graph\nis considered to be not a multigraph by default (each edge is unique)."),
        e.multigraph = e.uniqueLinkId);
        void 0 === e.multigraph && (e.multigraph = !1);
        if ("function" != typeof Map)
            throw new Error("ngraph.graph requires `Map` to be defined. Please polyfill it before using ngraph");
        var t = new Map
          , n = []
          , r = {}
          , i = 0
          , o = e.multigraph ? function(e, t, n) {
            var i = Fs(e, t)
              , o = r.hasOwnProperty(i);
            if (o || x(e, t)) {
                o || (r[i] = 0);
                var a = "@" + ++r[i];
                i = Fs(e + a, t + a)
            }
            return new zs(e,t,n,i)
        }
        : function(e, t, n) {
            var r = Fs(e, t);
            return new zs(e,t,n,r)
        }
          , a = []
          , s = _
          , c = _
          , l = _
          , u = _
          , h = {
            addNode: f,
            addLink: function(e, t, r) {
                l();
                var i = m(e) || f(e)
                  , a = m(t) || f(t)
                  , c = o(e, t, r);
                n.push(c),
                ks(i, c),
                e !== t && ks(a, c);
                return s(c, "add"),
                u(),
                c
            },
            removeLink: b,
            removeNode: g,
            getNode: m,
            getNodeCount: v,
            getLinkCount: y,
            getLinksCount: y,
            getNodesCount: v,
            getLinks: function(e) {
                var t = m(e);
                return t ? t.links : null
            },
            forEachNode: E,
            forEachLinkedNode: function(e, n, r) {
                var i = m(e);
                if (i && i.links && "function" == typeof n)
                    return r ? function(e, n, r) {
                        for (var i = 0; i < e.length; ++i) {
                            var o = e[i];
                            if (o.fromId === n && r(t.get(o.toId), o))
                                return !0
                        }
                    }(i.links, e, n) : function(e, n, r) {
                        for (var i = 0; i < e.length; ++i) {
                            var o = e[i]
                              , a = o.fromId === n ? o.toId : o.fromId;
                            if (r(t.get(a), o))
                                return !0
                        }
                    }(i.links, e, n)
            },
            forEachLink: function(e) {
                var t, r;
                if ("function" == typeof e)
                    for (t = 0,
                    r = n.length; t < r; ++t)
                        e(n[t])
            },
            beginUpdate: l,
            endUpdate: u,
            clear: function() {
                l(),
                E((function(e) {
                    g(e.id)
                }
                )),
                u()
            },
            hasLink: x,
            hasNode: m,
            getLink: x
        };
        return Ds(h),
        function() {
            var e = h.on;
            function t() {
                return h.beginUpdate = l = w,
                h.endUpdate = u = M,
                s = d,
                c = p,
                h.on = e,
                e.apply(h, arguments)
            }
            h.on = t
        }(),
        h;
        function d(e, t) {
            a.push({
                link: e,
                changeType: t
            })
        }
        function p(e, t) {
            a.push({
                node: e,
                changeType: t
            })
        }
        function f(e, n) {
            if (void 0 === e)
                throw new Error("Invalid node identifier");
            l();
            var r = m(e);
            return r ? (r.data = n,
            c(r, "update")) : (r = new Is(e,n),
            c(r, "add")),
            t.set(e, r),
            u(),
            r
        }
        function m(e) {
            return t.get(e)
        }
        function g(e) {
            var n = m(e);
            if (!n)
                return !1;
            l();
            var r = n.links;
            if (r) {
                n.links = null;
                for (var i = 0; i < r.length; ++i)
                    b(r[i])
            }
            return t.delete(e),
            c(n, "remove"),
            u(),
            !0
        }
        function v() {
            return t.size
        }
        function y() {
            return n.length
        }
        function b(e) {
            if (!e)
                return !1;
            var t = Ns(e, n);
            if (t < 0)
                return !1;
            l(),
            n.splice(t, 1);
            var r = m(e.fromId)
              , i = m(e.toId);
            return r && (t = Ns(e, r.links)) >= 0 && r.links.splice(t, 1),
            i && (t = Ns(e, i.links)) >= 0 && i.links.splice(t, 1),
            s(e, "remove"),
            u(),
            !0
        }
        function x(e, t) {
            var n, r = m(e);
            if (!r || !r.links)
                return null;
            for (n = 0; n < r.links.length; ++n) {
                var i = r.links[n];
                if (i.fromId === e && i.toId === t)
                    return i
            }
            return null
        }
        function _() {}
        function w() {
            i += 1
        }
        function M() {
            0 === (i -= 1) && a.length > 0 && (h.fire("changed", a),
            a.length = 0)
        }
        function E(e) {
            if ("function" != typeof e)
                throw new Error("Function is expected to iterate over graph nodes. You passed " + e);
            for (var n = t.values(), r = n.next(); !r.done; ) {
                if (e(r.value))
                    return !0;
                r = n.next()
            }
        }
    };
    function Ns(e, t) {
        if (!t)
            return -1;
        if (t.indexOf)
            return t.indexOf(e);
        var n, r = t.length;
        for (n = 0; n < r; n += 1)
            if (t[n] === e)
                return n;
        return -1
    }
    function Is(e, t) {
        this.id = e,
        this.links = null,
        this.data = t
    }
    function ks(e, t) {
        e.links ? e.links.push(t) : e.links = [t]
    }
    function zs(e, t, n, r) {
        this.fromId = e,
        this.toId = t,
        this.data = n,
        this.id = r
    }
    function Fs(e, t) {
        return e.toString() + "👉 " + t.toString()
    }
    var Bs = function(e) {
        return 0 === e ? "x" : 1 === e ? "y" : 2 === e ? "z" : "c" + (e + 1)
    }
      , Us = function(e) {
        return function(t, n) {
            let r = n && n.indent || 0
              , i = n && void 0 !== n.join ? n.join : "\n"
              , o = Array(r + 1).join(" ")
              , a = [];
            for (let n = 0; n < e; ++n) {
                let e = Bs(n)
                  , r = 0 === n ? "" : o;
                a.push(r + t.replace(/{var}/g, e))
            }
            return a.join(i)
        }
    }
      , Hs = function(e, t) {
        let n = Gs(e, t)
          , {Body: r} = new Function(n)();
        return r
    }
      , js = Gs;
    function Gs(e, t) {
        let n = Us(e)
          , r = n("{var}", {
            join: ", "
        })
          , i = "";
        return t && (i = `${n("\n   var v{var};\nObject.defineProperty(this, '{var}', {\n  set: function(v) { \n    if (!Number.isFinite(v)) throw new Error('Cannot set non-numbers to {var}');\n    v{var} = v; \n  },\n  get: function() { return v{var}; }\n});")}`),
        `\nfunction Vector(${r}) {\n${i}\n  if (typeof arguments[0] === 'object') {\n    // could be another vector\n    let v = arguments[0];\n    ${n('if (!Number.isFinite(v.{var})) throw new Error("Expected value is not a finite number at Vector constructor ({var})");', {
            indent: 4
        })}\n    ${n("this.{var} = v.{var};", {
            indent: 4
        })}\n  } else {\n    ${n('this.{var} = typeof {var} === "number" ? {var} : 0;', {
            indent: 4
        })}\n  }\n}\n\nVector.prototype.reset = function () {\n  ${n("this.{var} = ", {
            join: ""
        })}0;\n};\n\nfunction Body(${r}) {\n  this.isPinned = false;\n  this.pos = new Vector(${r});\n  this.force = new Vector();\n  this.velocity = new Vector();\n  this.mass = 1;\n\n  this.springCount = 0;\n  this.springLength = 0;\n}\n\nBody.prototype.reset = function() {\n  this.force.reset();\n  this.springCount = 0;\n  this.springLength = 0;\n}\n\nBody.prototype.setPosition = function (${r}) {\n  ${n("this.pos.{var} = {var} || 0;", {
            indent: 2
        })}\n};\n\nreturn {Body: Body, Vector: Vector};\n`
    }
    Hs.generateCreateBodyFunctionBody = js;
    var Vs = function(e) {
        let t = qs(e);
        return new Function(t)()
    }
      , Ws = qs;
    function qs(e) {
        let t = Us(e)
          , n = Math.pow(2, e);
        return `\n\n/**\n * Our implementation of QuadTree is non-recursive to avoid GC hit\n * This data structure represent stack of elements\n * which we are trying to insert into quad tree.\n */\nfunction InsertStack () {\n    this.stack = [];\n    this.popIdx = 0;\n}\n\nInsertStack.prototype = {\n    isEmpty: function() {\n        return this.popIdx === 0;\n    },\n    push: function (node, body) {\n        var item = this.stack[this.popIdx];\n        if (!item) {\n            // we are trying to avoid memory pressure: create new element\n            // only when absolutely necessary\n            this.stack[this.popIdx] = new InsertStackElement(node, body);\n        } else {\n            item.node = node;\n            item.body = body;\n        }\n        ++this.popIdx;\n    },\n    pop: function () {\n        if (this.popIdx > 0) {\n            return this.stack[--this.popIdx];\n        }\n    },\n    reset: function () {\n        this.popIdx = 0;\n    }\n};\n\nfunction InsertStackElement(node, body) {\n    this.node = node; // QuadTree node\n    this.body = body; // physical body which needs to be inserted to node\n}\n\n\nfunction QuadNode() {\n  // body stored inside this node. In quad tree only leaf nodes (by construction)\n  // contain bodies:\n  this.body = null;\n\n  // Child nodes are stored in quads. Each quad is presented by number:\n  // 0 | 1\n  // -----\n  // 2 | 3\n${r("  this.")}\n\n  // Total mass of current node\n  this.mass = 0;\n\n  // Center of mass coordinates\n  ${t("this.mass_{var} = 0;", {
            indent: 2
        })}\n\n  // bounding box coordinates\n  ${t("this.min_{var} = 0;", {
            indent: 2
        })}\n  ${t("this.max_{var} = 0;", {
            indent: 2
        })}\n}\n\n\nfunction createQuadTree(options, random) {\n  options = options || {};\n  options.gravity = typeof options.gravity === 'number' ? options.gravity : -1;\n  options.theta = typeof options.theta === 'number' ? options.theta : 0.8;\n\n  var gravity = options.gravity;\n  var updateQueue = [];\n  var insertStack = new InsertStack();\n  var theta = options.theta;\n\n  var nodesCache = [];\n  var currentInCache = 0;\n  var root = newNode();\n\n  return {\n    insertBodies: insertBodies,\n\n    /**\n     * Gets root node if it is present\n     */\n    getRoot: function() {\n      return root;\n    },\n\n    updateBodyForce: update,\n\n    options: function(newOptions) {\n      if (newOptions) {\n        if (typeof newOptions.gravity === 'number') {\n          gravity = newOptions.gravity;\n        }\n        if (typeof newOptions.theta === 'number') {\n          theta = newOptions.theta;\n        }\n\n        return this;\n      }\n\n      return {\n        gravity: gravity,\n        theta: theta\n      };\n    }\n  };\n\n  function newNode() {\n    // To avoid pressure on GC we reuse nodes.\n    var node = nodesCache[currentInCache];\n    if (node) {\n${r("      node.")}\n      node.body = null;\n      node.mass = ${t("node.mass_{var} = ", {
            join: ""
        })}0;\n      ${t("node.min_{var} = node.max_{var} = ", {
            join: ""
        })}0;\n    } else {\n      node = new QuadNode();\n      nodesCache[currentInCache] = node;\n    }\n\n    ++currentInCache;\n    return node;\n  }\n\n  function update(sourceBody) {\n    var queue = updateQueue;\n    var v;\n    ${t("var d{var};", {
            indent: 4
        })}\n    var r; \n    ${t("var f{var} = 0;", {
            indent: 4
        })}\n    var queueLength = 1;\n    var shiftIdx = 0;\n    var pushIdx = 1;\n\n    queue[0] = root;\n\n    while (queueLength) {\n      var node = queue[shiftIdx];\n      var body = node.body;\n\n      queueLength -= 1;\n      shiftIdx += 1;\n      var differentBody = (body !== sourceBody);\n      if (body && differentBody) {\n        // If the current node is a leaf node (and it is not source body),\n        // calculate the force exerted by the current node on body, and add this\n        // amount to body's net force.\n        ${t("d{var} = body.pos.{var} - sourceBody.pos.{var};", {
            indent: 8
        })}\n        r = Math.sqrt(${t("d{var} * d{var}", {
            join: " + "
        })});\n\n        if (r === 0) {\n          // Poor man's protection against zero distance.\n          ${t("d{var} = (random.nextDouble() - 0.5) / 50;", {
            indent: 10
        })}\n          r = Math.sqrt(${t("d{var} * d{var}", {
            join: " + "
        })});\n        }\n\n        // This is standard gravitation force calculation but we divide\n        // by r^3 to save two operations when normalizing force vector.\n        v = gravity * body.mass * sourceBody.mass / (r * r * r);\n        ${t("f{var} += v * d{var};", {
            indent: 8
        })}\n      } else if (differentBody) {\n        // Otherwise, calculate the ratio s / r,  where s is the width of the region\n        // represented by the internal node, and r is the distance between the body\n        // and the node's center-of-mass\n        ${t("d{var} = node.mass_{var} / node.mass - sourceBody.pos.{var};", {
            indent: 8
        })}\n        r = Math.sqrt(${t("d{var} * d{var}", {
            join: " + "
        })});\n\n        if (r === 0) {\n          // Sorry about code duplication. I don't want to create many functions\n          // right away. Just want to see performance first.\n          ${t("d{var} = (random.nextDouble() - 0.5) / 50;", {
            indent: 10
        })}\n          r = Math.sqrt(${t("d{var} * d{var}", {
            join: " + "
        })});\n        }\n        // If s / r < θ, treat this internal node as a single body, and calculate the\n        // force it exerts on sourceBody, and add this amount to sourceBody's net force.\n        if ((node.max_${Bs(0)} - node.min_${Bs(0)}) / r < theta) {\n          // in the if statement above we consider node's width only\n          // because the region was made into square during tree creation.\n          // Thus there is no difference between using width or height.\n          v = gravity * node.mass * sourceBody.mass / (r * r * r);\n          ${t("f{var} += v * d{var};", {
            indent: 10
        })}\n        } else {\n          // Otherwise, run the procedure recursively on each of the current node's children.\n\n          // I intentionally unfolded this loop, to save several CPU cycles.\n${function() {
            let e = Array(11).join(" ")
              , t = [];
            for (let r = 0; r < n; ++r)
                t.push(e + `if (node.quad${r}) {`),
                t.push(e + `  queue[pushIdx] = node.quad${r};`),
                t.push(e + "  queueLength += 1;"),
                t.push(e + "  pushIdx += 1;"),
                t.push(e + "}");
            return t.join("\n")
        }()}\n        }\n      }\n    }\n\n    ${t("sourceBody.force.{var} += f{var};", {
            indent: 4
        })}\n  }\n\n  function insertBodies(bodies) {\n    ${t("var {var}min = Number.MAX_VALUE;", {
            indent: 4
        })}\n    ${t("var {var}max = Number.MIN_VALUE;", {
            indent: 4
        })}\n    var i = bodies.length;\n\n    // To reduce quad tree depth we are looking for exact bounding box of all particles.\n    while (i--) {\n      var pos = bodies[i].pos;\n      ${t("if (pos.{var} < {var}min) {var}min = pos.{var};", {
            indent: 6
        })}\n      ${t("if (pos.{var} > {var}max) {var}max = pos.{var};", {
            indent: 6
        })}\n    }\n\n    // Makes the bounds square.\n    var maxSideLength = -Infinity;\n    ${t("if ({var}max - {var}min > maxSideLength) maxSideLength = {var}max - {var}min ;", {
            indent: 4
        })}\n\n    currentInCache = 0;\n    root = newNode();\n    ${t("root.min_{var} = {var}min;", {
            indent: 4
        })}\n    ${t("root.max_{var} = {var}min + maxSideLength;", {
            indent: 4
        })}\n\n    i = bodies.length - 1;\n    if (i >= 0) {\n      root.body = bodies[i];\n    }\n    while (i--) {\n      insert(bodies[i], root);\n    }\n  }\n\n  function insert(newBody) {\n    insertStack.reset();\n    insertStack.push(root, newBody);\n\n    while (!insertStack.isEmpty()) {\n      var stackItem = insertStack.pop();\n      var node = stackItem.node;\n      var body = stackItem.body;\n\n      if (!node.body) {\n        // This is internal node. Update the total mass of the node and center-of-mass.\n        ${t("var {var} = body.pos.{var};", {
            indent: 8
        })}\n        node.mass += body.mass;\n        ${t("node.mass_{var} += body.mass * {var};", {
            indent: 8
        })}\n\n        // Recursively insert the body in the appropriate quadrant.\n        // But first find the appropriate quadrant.\n        var quadIdx = 0; // Assume we are in the 0's quad.\n        ${t("var min_{var} = node.min_{var};", {
            indent: 8
        })}\n        ${t("var max_{var} = (min_{var} + node.max_{var}) / 2;", {
            indent: 8
        })}\n\n${function(t) {
            let n = []
              , r = Array(t + 1).join(" ");
            for (let t = 0; t < e; ++t)
                n.push(r + `if (${Bs(t)} > max_${Bs(t)}) {`),
                n.push(r + `  quadIdx = quadIdx + ${Math.pow(2, t)};`),
                n.push(r + `  min_${Bs(t)} = max_${Bs(t)};`),
                n.push(r + `  max_${Bs(t)} = node.max_${Bs(t)};`),
                n.push(r + "}");
            return n.join("\n")
        }(8)}\n\n        var child = getChild(node, quadIdx);\n\n        if (!child) {\n          // The node is internal but this quadrant is not taken. Add\n          // subnode to it.\n          child = newNode();\n          ${t("child.min_{var} = min_{var};", {
            indent: 10
        })}\n          ${t("child.max_{var} = max_{var};", {
            indent: 10
        })}\n          child.body = body;\n\n          setChild(node, quadIdx, child);\n        } else {\n          // continue searching in this quadrant.\n          insertStack.push(child, body);\n        }\n      } else {\n        // We are trying to add to the leaf node.\n        // We have to convert current leaf into internal node\n        // and continue adding two nodes.\n        var oldBody = node.body;\n        node.body = null; // internal nodes do not cary bodies\n\n        if (isSamePosition(oldBody.pos, body.pos)) {\n          // Prevent infinite subdivision by bumping one node\n          // anywhere in this quadrant\n          var retriesCount = 3;\n          do {\n            var offset = random.nextDouble();\n            ${t("var d{var} = (node.max_{var} - node.min_{var}) * offset;", {
            indent: 12
        })}\n\n            ${t("oldBody.pos.{var} = node.min_{var} + d{var};", {
            indent: 12
        })}\n            retriesCount -= 1;\n            // Make sure we don't bump it out of the box. If we do, next iteration should fix it\n          } while (retriesCount > 0 && isSamePosition(oldBody.pos, body.pos));\n\n          if (retriesCount === 0 && isSamePosition(oldBody.pos, body.pos)) {\n            // This is very bad, we ran out of precision.\n            // if we do not return from the method we'll get into\n            // infinite loop here. So we sacrifice correctness of layout, and keep the app running\n            // Next layout iteration should get larger bounding box in the first step and fix this\n            return;\n          }\n        }\n        // Next iteration should subdivide node further.\n        insertStack.push(node, oldBody);\n        insertStack.push(node, body);\n      }\n    }\n  }\n}\n\nfunction getChild(node, idx) {\n${function() {
            let e = [];
            for (let t = 0; t < n; ++t)
                e.push(`  if (idx === ${t}) return node.quad${t};`);
            return e.join("\n")
        }()}\n  return null;\n}\n\nfunction setChild(node, idx, child) {\n${function() {
            let e = [];
            for (let t = 0; t < n; ++t) {
                let n = 0 === t ? "  " : "  else ";
                e.push(`${n}if (idx === ${t}) node.quad${t} = child;`)
            }
            return e.join("\n")
        }()}\n}\n\nfunction isSamePosition(point1, point2) {\n  ${t("var d{var} = Math.abs(point1.{var} - point2.{var});", {
            indent: 2
        })}\n\n  return ${t("d{var} < 1e-8", {
            join: " && "
        })};\n}\n\nreturn createQuadTree;\n\n`;
        function r(e) {
            let t = [];
            for (let r = 0; r < n; ++r)
                t.push(`${e}quad${r} = null;`);
            return t.join("\n")
        }
    }
    Vs.generateQuadTreeFunctionBody = Ws;
    var Xs = function(e) {
        let t = Zs(e);
        return new Function("bodies","settings","random",t)
    }
      , Ys = Zs;
    function Zs(e) {
        let t = Us(e);
        return `\n  var boundingBox = {\n    ${t("min_{var}: 0, max_{var}: 0,", {
            indent: 4
        })}\n  };\n\n  return {\n    box: boundingBox,\n\n    update: updateBoundingBox,\n\n    reset: resetBoundingBox,\n\n    getBestNewPosition: function (neighbors) {\n      var ${t("base_{var} = 0", {
            join: ", "
        })};\n\n      if (neighbors.length) {\n        for (var i = 0; i < neighbors.length; ++i) {\n          let neighborPos = neighbors[i].pos;\n          ${t("base_{var} += neighborPos.{var};", {
            indent: 10
        })}\n        }\n\n        ${t("base_{var} /= neighbors.length;", {
            indent: 8
        })}\n      } else {\n        ${t("base_{var} = (boundingBox.min_{var} + boundingBox.max_{var}) / 2;", {
            indent: 8
        })}\n      }\n\n      var springLength = settings.springLength;\n      return {\n        ${t("{var}: base_{var} + (random.nextDouble() - 0.5) * springLength,", {
            indent: 8
        })}\n      };\n    }\n  };\n\n  function updateBoundingBox() {\n    var i = bodies.length;\n    if (i === 0) return; // No bodies - no borders.\n\n    ${t("var max_{var} = -Infinity;", {
            indent: 4
        })}\n    ${t("var min_{var} = Infinity;", {
            indent: 4
        })}\n\n    while(i--) {\n      // this is O(n), it could be done faster with quadtree, if we check the root node bounds\n      var bodyPos = bodies[i].pos;\n      ${t("if (bodyPos.{var} < min_{var}) min_{var} = bodyPos.{var};", {
            indent: 6
        })}\n      ${t("if (bodyPos.{var} > max_{var}) max_{var} = bodyPos.{var};", {
            indent: 6
        })}\n    }\n\n    ${t("boundingBox.min_{var} = min_{var};", {
            indent: 4
        })}\n    ${t("boundingBox.max_{var} = max_{var};", {
            indent: 4
        })}\n  }\n\n  function resetBoundingBox() {\n    ${t("boundingBox.min_{var} = boundingBox.max_{var} = 0;", {
            indent: 4
        })}\n  }\n`
    }
    Xs.generateFunctionBody = Ys;
    var $s = function(e) {
        let t = Qs(e);
        return new Function("options",t)
    }
      , Js = Qs;
    function Qs(e) {
        return `\n  if (!Number.isFinite(options.dragCoefficient)) throw new Error('dragCoefficient is not a finite number');\n\n  return {\n    update: function(body) {\n      ${Us(e)("body.force.{var} -= options.dragCoefficient * body.velocity.{var};", {
            indent: 6
        })}\n    }\n  };\n`
    }
    $s.generateCreateDragForceFunctionBody = Js;
    var Ks = function(e) {
        let t = tc(e);
        return new Function("options","random",t)
    }
      , ec = tc;
    function tc(e) {
        let t = Us(e);
        return `\n  if (!Number.isFinite(options.springCoefficient)) throw new Error('Spring coefficient is not a number');\n  if (!Number.isFinite(options.springLength)) throw new Error('Spring length is not a number');\n\n  return {\n    /**\n     * Updates forces acting on a spring\n     */\n    update: function (spring) {\n      var body1 = spring.from;\n      var body2 = spring.to;\n      var length = spring.length < 0 ? options.springLength : spring.length;\n      ${t("var d{var} = body2.pos.{var} - body1.pos.{var};", {
            indent: 6
        })}\n      var r = Math.sqrt(${t("d{var} * d{var}", {
            join: " + "
        })});\n\n      if (r === 0) {\n        ${t("d{var} = (random.nextDouble() - 0.5) / 50;", {
            indent: 8
        })}\n        r = Math.sqrt(${t("d{var} * d{var}", {
            join: " + "
        })});\n      }\n\n      var d = r - length;\n      var coefficient = ((spring.coefficient > 0) ? spring.coefficient : options.springCoefficient) * d / r;\n\n      ${t("body1.force.{var} += coefficient * d{var}", {
            indent: 6
        })};\n      body1.springCount += 1;\n      body1.springLength += r;\n\n      ${t("body2.force.{var} -= coefficient * d{var}", {
            indent: 6
        })};\n      body2.springCount += 1;\n      body2.springLength += r;\n    }\n  };\n`
    }
    Ks.generateCreateSpringForceFunctionBody = ec;
    var nc = function(e) {
        let t = ic(e);
        return new Function("bodies","timeStep","adaptiveTimeStepWeight",t)
    }
      , rc = ic;
    function ic(e) {
        let t = Us(e);
        return `\n  var length = bodies.length;\n  if (length === 0) return 0;\n\n  ${t("var d{var} = 0, t{var} = 0;", {
            indent: 2
        })}\n\n  for (var i = 0; i < length; ++i) {\n    var body = bodies[i];\n    if (body.isPinned) continue;\n\n    if (adaptiveTimeStepWeight && body.springCount) {\n      timeStep = (adaptiveTimeStepWeight * body.springLength/body.springCount);\n    }\n\n    var coeff = timeStep / body.mass;\n\n    ${t("body.velocity.{var} += coeff * body.force.{var};", {
            indent: 4
        })}\n    ${t("var v{var} = body.velocity.{var};", {
            indent: 4
        })}\n    var v = Math.sqrt(${t("v{var} * v{var}", {
            join: " + "
        })});\n\n    if (v > 1) {\n      // We normalize it so that we move within timeStep range. \n      // for the case when v <= 1 - we let velocity to fade out.\n      ${t("body.velocity.{var} = v{var} / v;", {
            indent: 6
        })}\n    }\n\n    ${t("d{var} = timeStep * body.velocity.{var};", {
            indent: 4
        })}\n\n    ${t("body.pos.{var} += d{var};", {
            indent: 4
        })}\n\n    ${t("t{var} += Math.abs(d{var});", {
            indent: 4
        })}\n  }\n\n  return (${t("t{var} * t{var}", {
            join: " + "
        })})/length;\n`
    }
    nc.generateIntegratorFunctionBody = rc;
    var oc = function(e, t, n, r) {
        this.from = e,
        this.to = t,
        this.length = n,
        this.coefficient = r
    };
    var ac = function e(t, n) {
        var r;
        t || (t = {});
        if (n)
            for (r in n)
                if (n.hasOwnProperty(r)) {
                    var i = t.hasOwnProperty(r)
                      , o = typeof n[r];
                    !i || typeof t[r] !== o ? t[r] = n[r] : "object" === o && (t[r] = e(t[r], n[r]))
                }
        return t
    };
    function sc(e) {
        var t = {
            exports: {}
        };
        return e(t, t.exports),
        t.exports
    }
    var cc = sc((function(e) {
        function t(e) {
            return new n("number" == typeof e ? e : +new Date)
        }
        function n(e) {
            this.seed = e
        }
        function r(e) {
            return Math.sqrt(2 * Math.PI / e) * Math.pow(1 / Math.E * (e + 1 / (12 * e - 1 / (10 * e))), e)
        }
        function i() {
            var e = this.seed;
            return e = 4294967295 & (3042594569 ^ (e = (e = 4294967295 & ((e = (e = 4294967295 & (3345072700 ^ (e = e + 2127912214 + (e << 12) & 4294967295) ^ e >>> 19)) + 374761393 + (e << 5) & 4294967295) + 3550635116 ^ e << 9)) + 4251993797 + (e << 3) & 4294967295) ^ e >>> 16),
            this.seed = e,
            (268435455 & e) / 268435456
        }
        e.exports = t,
        e.exports.random = t,
        e.exports.randomIterator = function(e, n) {
            var r = n || t();
            if ("function" != typeof r.next)
                throw new Error("customRandom does not match expected API: next() function is missing");
            return {
                forEach: function(t) {
                    var n, i, o;
                    for (n = e.length - 1; n > 0; --n)
                        i = r.next(n + 1),
                        o = e[i],
                        e[i] = e[n],
                        e[n] = o,
                        t(o);
                    e.length && t(e[0])
                },
                shuffle: function() {
                    var t, n, i;
                    for (t = e.length - 1; t > 0; --t)
                        n = r.next(t + 1),
                        i = e[n],
                        e[n] = e[t],
                        e[t] = i;
                    return e
                }
            }
        }
        ,
        n.prototype.next = function(e) {
            return Math.floor(this.nextDouble() * e)
        }
        ,
        n.prototype.nextDouble = i,
        n.prototype.uniform = i,
        n.prototype.gaussian = function() {
            var e, t, n;
            do {
                t = 2 * this.nextDouble() - 1,
                n = 2 * this.nextDouble() - 1,
                e = t * t + n * n
            } while (e >= 1 || 0 === e);
            return t * Math.sqrt(-2 * Math.log(e) / e)
        }
        ,
        n.prototype.levy = function() {
            var e = 1.5
              , t = Math.pow(r(2.5) * Math.sin(Math.PI * e / 2) / (r(1.25) * e * Math.pow(2, .25)), 1 / e);
            return this.gaussian() * t / Math.pow(Math.abs(this.gaussian()), 1 / e)
        }
    }
    ))
      , lc = function(e) {
        var t = oc
          , n = ac
          , r = Ds;
        if (e) {
            if (void 0 !== e.springCoeff)
                throw new Error("springCoeff was renamed to springCoefficient");
            if (void 0 !== e.dragCoeff)
                throw new Error("dragCoeff was renamed to dragCoefficient")
        }
        e = n(e, {
            springLength: 10,
            springCoefficient: .8,
            gravity: -12,
            theta: .8,
            dragCoefficient: .9,
            timeStep: .5,
            adaptiveTimeStepWeight: 0,
            dimensions: 2,
            debug: !1
        });
        var i = uc[e.dimensions];
        if (!i) {
            var o = e.dimensions;
            i = {
                Body: Hs(o, e.debug),
                createQuadTree: Vs(o),
                createBounds: Xs(o),
                createDragForce: $s(o),
                createSpringForce: Ks(o),
                integrate: nc(o)
            },
            uc[o] = i
        }
        var a = i.Body
          , s = i.createQuadTree
          , c = i.createBounds
          , l = i.createDragForce
          , u = i.createSpringForce
          , h = i.integrate
          , d = cc.random(42)
          , p = []
          , f = []
          , m = s(e, d)
          , g = c(p, e, d)
          , v = u(e, d)
          , y = l(e)
          , b = []
          , x = new Map
          , _ = 0;
        E("nbody", (function() {
            if (0 === p.length)
                return;
            m.insertBodies(p);
            var e = p.length;
            for (; e--; ) {
                var t = p[e];
                t.isPinned || (t.reset(),
                m.updateBodyForce(t),
                y.update(t))
            }
        }
        )),
        E("spring", (function() {
            var e = f.length;
            for (; e--; )
                v.update(f[e])
        }
        ));
        var w = {
            bodies: p,
            quadTree: m,
            springs: f,
            settings: e,
            addForce: E,
            removeForce: function(e) {
                var t = b.indexOf(x.get(e));
                if (t < 0)
                    return;
                b.splice(t, 1),
                x.delete(e)
            },
            getForces: function() {
                return x
            },
            step: function() {
                for (var t = 0; t < b.length; ++t)
                    b[t](_);
                var n = h(p, e.timeStep, e.adaptiveTimeStepWeight);
                return _ += 1,
                n
            },
            addBody: function(e) {
                if (!e)
                    throw new Error("Body is required");
                return p.push(e),
                e
            },
            addBodyAt: function(e) {
                if (!e)
                    throw new Error("Body position is required");
                var t = (e=>new a(e))(e);
                return p.push(t),
                t
            },
            removeBody: function(e) {
                if (e) {
                    var t = p.indexOf(e);
                    if (!(t < 0))
                        return p.splice(t, 1),
                        0 === p.length && g.reset(),
                        !0
                }
            },
            addSpring: function(e, n, r, i) {
                if (!e || !n)
                    throw new Error("Cannot add null spring to force simulator");
                "number" != typeof r && (r = -1);
                var o = new t(e,n,r,i >= 0 ? i : -1);
                return f.push(o),
                o
            },
            getTotalMovement: function() {
                return 0
            },
            removeSpring: function(e) {
                if (e) {
                    var t = f.indexOf(e);
                    return t > -1 ? (f.splice(t, 1),
                    !0) : void 0
                }
            },
            getBestNewBodyPosition: function(e) {
                return g.getBestNewPosition(e)
            },
            getBBox: M,
            getBoundingBox: M,
            invalidateBBox: function() {
                console.warn("invalidateBBox() is deprecated, bounds always recomputed on `getBBox()` call")
            },
            gravity: function(t) {
                return void 0 !== t ? (e.gravity = t,
                m.options({
                    gravity: t
                }),
                this) : e.gravity
            },
            theta: function(t) {
                return void 0 !== t ? (e.theta = t,
                m.options({
                    theta: t
                }),
                this) : e.theta
            },
            random: d
        };
        return function(e, t) {
            for (var n in e)
                hc(e, t, n)
        }(e, w),
        r(w),
        w;
        function M() {
            return g.update(),
            g.box
        }
        function E(e, t) {
            if (x.has(e))
                throw new Error("Force " + e + " is already added");
            x.set(e, t),
            b.push(t)
        }
    }
      , uc = {};
    function hc(e, t, n) {
        if (e.hasOwnProperty(n) && "function" != typeof t[n]) {
            var r = Number.isFinite(e[n]);
            t[n] = r ? function(r) {
                if (void 0 !== r) {
                    if (!Number.isFinite(r))
                        throw new Error("Value of " + n + " should be a valid number.");
                    return e[n] = r,
                    t
                }
                return e[n]
            }
            : function(r) {
                return void 0 !== r ? (e[n] = r,
                t) : e[n]
            }
        }
    }
    var dc = function(e, t) {
        if (!e)
            throw new Error("Graph structure cannot be undefined");
        var n = (t && t.createSimulator || lc)(t);
        if (Array.isArray(t))
            throw new Error("Physics settings is expected to be an object");
        var r = function(t) {
            var n = e.getLinks(t);
            return n ? 1 + n.length / 3 : 1
        };
        t && "function" == typeof t.nodeMass && (r = t.nodeMass);
        var i = new Map
          , o = {}
          , a = 0
          , s = n.settings.springTransform || fc;
        a = 0,
        e.forEachNode((function(e) {
            p(e.id),
            a += 1
        }
        )),
        e.forEachLink(m),
        e.on("changed", d);
        var c = !1
          , l = {
            step: function() {
                if (0 === a)
                    return u(!0),
                    !0;
                var e = n.step();
                l.lastMove = e,
                l.fire("step");
                var t = e / a <= .01;
                return u(t),
                t
            },
            getNodePosition: function(e) {
                return y(e).pos
            },
            setNodePosition: function(e) {
                var t = y(e);
                t.setPosition.apply(t, Array.prototype.slice.call(arguments, 1))
            },
            getLinkPosition: function(e) {
                var t = o[e];
                if (t)
                    return {
                        from: t.from.pos,
                        to: t.to.pos
                    }
            },
            getGraphRect: function() {
                return n.getBBox()
            },
            forEachBody: h,
            pinNode: function(e, t) {
                y(e.id).isPinned = !!t
            },
            isNodePinned: function(e) {
                return y(e.id).isPinned
            },
            dispose: function() {
                e.off("changed", d),
                l.fire("disposed")
            },
            getBody: function(e) {
                return i.get(e)
            },
            getSpring: function(t, n) {
                var r;
                if (void 0 === n)
                    r = "object" != typeof t ? t : t.id;
                else {
                    var i = e.hasLink(t, n);
                    if (!i)
                        return;
                    r = i.id
                }
                return o[r]
            },
            getForceVectorLength: function() {
                var e = 0
                  , t = 0;
                return h((function(n) {
                    e += Math.abs(n.force.x),
                    t += Math.abs(n.force.y)
                }
                )),
                Math.sqrt(e * e + t * t)
            },
            simulator: n,
            graph: e,
            lastMove: 0
        };
        return Ds(l),
        l;
        function u(e) {
            var t;
            c !== e && (c = e,
            t = e,
            l.fire("stable", t))
        }
        function h(e) {
            i.forEach(e)
        }
        function d(t) {
            for (var n = 0; n < t.length; ++n) {
                var r = t[n];
                "add" === r.changeType ? (r.node && p(r.node.id),
                r.link && m(r.link)) : "remove" === r.changeType && (r.node && f(r.node),
                r.link && g(r.link))
            }
            a = e.getNodesCount()
        }
        function p(t) {
            var r = i.get(t);
            if (!r) {
                var o = e.getNode(t);
                if (!o)
                    throw new Error("initBody() was called with unknown node id");
                var a = o.position;
                if (!a) {
                    var s = function(e) {
                        var t = [];
                        if (!e.links)
                            return t;
                        for (var n = Math.min(e.links.length, 2), r = 0; r < n; ++r) {
                            var o = e.links[r]
                              , a = o.fromId !== e.id ? i.get(o.fromId) : i.get(o.toId);
                            a && a.pos && t.push(a)
                        }
                        return t
                    }(o);
                    a = n.getBestNewBodyPosition(s)
                }
                (r = n.addBodyAt(a)).id = t,
                i.set(t, r),
                v(t),
                function(e) {
                    return e && (e.isPinned || e.data && e.data.isPinned)
                }(o) && (r.isPinned = !0)
            }
        }
        function f(e) {
            var t = e.id
              , r = i.get(t);
            r && (i.delete(t),
            n.removeBody(r))
        }
        function m(e) {
            v(e.fromId),
            v(e.toId);
            var t = i.get(e.fromId)
              , r = i.get(e.toId)
              , a = n.addSpring(t, r, e.length);
            s(e, a),
            o[e.id] = a
        }
        function g(t) {
            var r = o[t.id];
            if (r) {
                var i = e.getNode(t.fromId)
                  , a = e.getNode(t.toId);
                i && v(i.id),
                a && v(a.id),
                delete o[t.id],
                n.removeSpring(r)
            }
        }
        function v(e) {
            var t = i.get(e);
            if (t.mass = r(e),
            Number.isNaN(t.mass))
                throw new Error("Node mass should be a number")
        }
        function y(e) {
            var t = i.get(e);
            return t || (p(e),
            t = i.get(e)),
            t
        }
    }
      , pc = lc;
    function fc() {}
    function mc(e, t, n) {
        var r, i, o, a, s;
        function c() {
            var l = Date.now() - a;
            l < t && l >= 0 ? r = setTimeout(c, t - l) : (r = null,
            n || (s = e.apply(o, i),
            o = i = null))
        }
        null == t && (t = 100);
        var l = function() {
            o = this,
            i = arguments,
            a = Date.now();
            var l = n && !r;
            return r || (r = setTimeout(c, t)),
            l && (s = e.apply(o, i),
            o = i = null),
            s
        };
        return l.clear = function() {
            r && (clearTimeout(r),
            r = null)
        }
        ,
        l.flush = function() {
            r && (s = e.apply(o, i),
            o = i = null,
            clearTimeout(r),
            r = null)
        }
        ,
        l
    }
    dc.simulator = pc,
    mc.debounce = mc;
    var gc = mc;
    function vc(e, t) {
        return function(e) {
            if (Array.isArray(e))
                return e
        }(e) || function(e, t) {
            if (!(Symbol.iterator in Object(e)) && "[object Arguments]" !== Object.prototype.toString.call(e))
                return;
            var n = []
              , r = !0
              , i = !1
              , o = void 0;
            try {
                for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value),
                !t || n.length !== t); r = !0)
                    ;
            } catch (e) {
                i = !0,
                o = e
            } finally {
                try {
                    r || null == s.return || s.return()
                } finally {
                    if (i)
                        throw o
                }
            }
            return n
        }(e, t) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }()
    }
    var yc = function e(t, n) {
        var r = n.default
          , i = void 0 === r ? null : r
          , o = n.triggerUpdate
          , a = void 0 === o || o
          , s = n.onChange
          , c = void 0 === s ? function(e, t) {}
        : s;
        !function(e, t) {
            if (!(e instanceof t))
                throw new TypeError("Cannot call a class as a function")
        }(this, e),
        this.name = t,
        this.defaultVal = i,
        this.triggerUpdate = a,
        this.onChange = c
    };
    function bc(e) {
        var t = e.stateInit
          , n = void 0 === t ? function() {
            return {}
        }
        : t
          , r = e.props
          , i = void 0 === r ? {} : r
          , o = e.methods
          , a = void 0 === o ? {} : o
          , s = e.aliases
          , c = void 0 === s ? {} : s
          , l = e.init
          , u = void 0 === l ? function() {}
        : l
          , h = e.update
          , d = void 0 === h ? function() {}
        : h
          , p = Object.keys(i).map((function(e) {
            return new yc(e,i[e])
        }
        ));
        return function() {
            var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}
              , t = Object.assign({}, n instanceof Function ? n(e) : n, {
                initialised: !1
            })
              , r = {};
            function i(t) {
                return o(t, e),
                s(),
                i
            }
            var o = function(e, n) {
                u.call(i, e, t, n),
                t.initialised = !0
            }
              , s = gc((function() {
                t.initialised && (d.call(i, t, r),
                r = {})
            }
            ), 1);
            return p.forEach((function(e) {
                i[e.name] = function(e) {
                    var n = e.name
                      , o = e.triggerUpdate
                      , a = void 0 !== o && o
                      , c = e.onChange
                      , l = void 0 === c ? function(e, t) {}
                    : c
                      , u = e.defaultVal
                      , h = void 0 === u ? null : u;
                    return function(e) {
                        var o = t[n];
                        if (!arguments.length)
                            return o;
                        var c = void 0 === e ? h : e;
                        return t[n] = c,
                        l.call(i, c, t, o),
                        !r.hasOwnProperty(n) && (r[n] = o),
                        a && s(),
                        i
                    }
                }(e)
            }
            )),
            Object.keys(a).forEach((function(e) {
                i[e] = function() {
                    for (var n, r = arguments.length, o = new Array(r), s = 0; s < r; s++)
                        o[s] = arguments[s];
                    return (n = a[e]).call.apply(n, [i, t].concat(o))
                }
            }
            )),
            Object.entries(c).forEach((function(e) {
                var t = vc(e, 2)
                  , n = t[0]
                  , r = t[1];
                return i[n] = i[r]
            }
            )),
            i.resetProps = function() {
                return p.forEach((function(e) {
                    i[e.name](e.defaultVal)
                }
                )),
                i
            }
            ,
            i.resetProps(),
            t._rerender = s,
            i
        }
    }
    var xc = function(e) {
        return e instanceof Function ? e : "string" == typeof e ? function(t) {
            return t[e]
        }
        : function(t) {
            return e
        }
    };
    function _c(e, t) {
        let n;
        if (void 0 === t)
            for (const t of e)
                null != t && (n < t || void 0 === n && t >= t) && (n = t);
        else {
            let r = -1;
            for (let i of e)
                null != (i = t(i, ++r, e)) && (n < i || void 0 === n && i >= i) && (n = i)
        }
        return n
    }
    function wc(e, t) {
        let n;
        if (void 0 === t)
            for (const t of e)
                null != t && (n > t || void 0 === n && t >= t) && (n = t);
        else {
            let r = -1;
            for (let i of e)
                null != (i = t(i, ++r, e)) && (n > i || void 0 === n && i >= i) && (n = i)
        }
        return n
    }
    function Mc(e, t) {
        if (null == e)
            return {};
        var n, r, i = function(e, t) {
            if (null == e)
                return {};
            var n, r, i = {}, o = Object.keys(e);
            for (r = 0; r < o.length; r++)
                n = o[r],
                t.indexOf(n) >= 0 || (i[n] = e[n]);
            return i
        }(e, t);
        if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            for (r = 0; r < o.length; r++)
                n = o[r],
                t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n])
        }
        return i
    }
    function Ec(e, t) {
        return function(e) {
            if (Array.isArray(e))
                return e
        }(e) || function(e, t) {
            if (!(Symbol.iterator in Object(e)) && "[object Arguments]" !== Object.prototype.toString.call(e))
                return;
            var n = []
              , r = !0
              , i = !1
              , o = void 0;
            try {
                for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value),
                !t || n.length !== t); r = !0)
                    ;
            } catch (e) {
                i = !0,
                o = e
            } finally {
                try {
                    r || null == s.return || s.return()
                } finally {
                    if (i)
                        throw o
                }
            }
            return n
        }(e, t) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }()
    }
    function Sc(e) {
        return function(e) {
            if (Array.isArray(e)) {
                for (var t = 0, n = new Array(e.length); t < e.length; t++)
                    n[t] = e[t];
                return n
            }
        }(e) || function(e) {
            if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e))
                return Array.from(e)
        }(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance")
        }()
    }
    function Tc(e) {
        var t = function(e, t) {
            if ("object" != typeof e || null === e)
                return e;
            var n = e[Symbol.toPrimitive];
            if (void 0 !== n) {
                var r = n.call(e, t || "default");
                if ("object" != typeof r)
                    return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return ("string" === t ? String : Number)(e)
        }(e, "string");
        return "symbol" == typeof t ? t : String(t)
    }
    var Lc = function() {
        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : []
          , t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : []
          , n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2]
          , r = arguments.length > 3 && void 0 !== arguments[3] && arguments[3]
          , i = (t instanceof Array ? t.length ? t : [void 0] : [t]).map((function(e) {
            return {
                keyAccessor: e,
                isProp: !(e instanceof Function)
            }
        }
        ))
          , o = e.reduce((function(e, t) {
            var r = e
              , o = t;
            return i.forEach((function(e, t) {
                var a, s = e.keyAccessor;
                if (e.isProp) {
                    var c = o
                      , l = c[s]
                      , u = Mc(c, [s].map(Tc));
                    a = l,
                    o = u
                } else
                    a = s(o, t);
                t + 1 < i.length ? (r.hasOwnProperty(a) || (r[a] = {}),
                r = r[a]) : n ? (r.hasOwnProperty(a) || (r[a] = []),
                r[a].push(o)) : r[a] = o
            }
            )),
            e
        }
        ), {});
        n instanceof Function && function e(t) {
            var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            r === i.length ? Object.keys(t).forEach((function(e) {
                return t[e] = n(t[e])
            }
            )) : Object.values(t).forEach((function(t) {
                return e(t, r + 1)
            }
            ))
        }(o);
        var a = o;
        return r && (a = [],
        function e(t) {
            var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
            n.length === i.length ? a.push({
                keys: n,
                vals: t
            }) : Object.entries(t).forEach((function(t) {
                var r = Ec(t, 2)
                  , i = r[0]
                  , o = r[1];
                return e(o, [].concat(Sc(n), [i]))
            }
            ))
        }(o),
        t instanceof Array && 0 === t.length && 1 === a.length && (a[0].keys = [])),
        a
    };
    function Ac(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n,
        e
    }
    function Pc(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            }
            ))),
            n.push.apply(n, r)
        }
        return n
    }
    function Cc(e, t) {
        if (null == e)
            return {};
        var n, r, i = function(e, t) {
            if (null == e)
                return {};
            var n, r, i = {}, o = Object.keys(e);
            for (r = 0; r < o.length; r++)
                n = o[r],
                t.indexOf(n) >= 0 || (i[n] = e[n]);
            return i
        }(e, t);
        if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            for (r = 0; r < o.length; r++)
                n = o[r],
                t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n])
        }
        return i
    }
    function Rc(e, t) {
        return function(e) {
            if (Array.isArray(e))
                return e
        }(e) || function(e, t) {
            if (!(Symbol.iterator in Object(e)) && "[object Arguments]" !== Object.prototype.toString.call(e))
                return;
            var n = []
              , r = !0
              , i = !1
              , o = void 0;
            try {
                for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value),
                !t || n.length !== t); r = !0)
                    ;
            } catch (e) {
                i = !0,
                o = e
            } finally {
                try {
                    r || null == s.return || s.return()
                } finally {
                    if (i)
                        throw o
                }
            }
            return n
        }(e, t) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance")
        }()
    }
    function Dc(e) {
        return function(e) {
            if (Array.isArray(e)) {
                for (var t = 0, n = new Array(e.length); t < e.length; t++)
                    n[t] = e[t];
                return n
            }
        }(e) || function(e) {
            if (Symbol.iterator in Object(e) || "[object Arguments]" === Object.prototype.toString.call(e))
                return Array.from(e)
        }(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance")
        }()
    }
    function Oc(e, t, n) {
        var r = n.objBindAttr
          , i = void 0 === r ? "__obj" : r
          , o = n.dataBindAttr
          , a = void 0 === o ? "__data" : o
          , s = n.idAccessor
          , c = n.purge
          , l = void 0 !== c && c
          , u = function(e) {
            return e.hasOwnProperty(a)
        }
          , h = t.filter((function(e) {
            return !u(e)
        }
        ))
          , d = t.filter(u).map((function(e) {
            return e[a]
        }
        ))
          , p = l ? {
            enter: e,
            exit: d,
            update: []
        } : function(e, t, n) {
            var r = {
                enter: [],
                update: [],
                exit: []
            };
            if (n) {
                var i = Lc(e, n, !1)
                  , o = Lc(t, n, !1)
                  , a = Object.assign({}, i, o);
                Object.entries(a).forEach((function(e) {
                    var t = Rc(e, 2)
                      , n = t[0]
                      , a = t[1]
                      , s = i.hasOwnProperty(n) ? o.hasOwnProperty(n) ? "update" : "exit" : "enter";
                    r[s].push("update" === s ? [i[n], o[n]] : a)
                }
                ))
            } else {
                var s = new Set(e)
                  , c = new Set(t);
                new Set([].concat(Dc(s), Dc(c))).forEach((function(e) {
                    var t = s.has(e) ? c.has(e) ? "update" : "exit" : "enter";
                    r[t].push("update" === t ? [e, e] : e)
                }
                ))
            }
            return r
        }(d, e, s);
        return p.update = p.update.map((function(e) {
            var t = Rc(e, 2)
              , n = t[0]
              , r = t[1];
            return n !== r && (r[i] = n[i],
            r[i][a] = r),
            r
        }
        )),
        p.exit = p.exit.concat(h.map((function(e) {
            return Ac({}, i, e)
        }
        ))),
        p
    }
    function Nc(e, t, n, r, i) {
        var o = i.createObj
          , a = void 0 === o ? function(e) {
            return {}
        }
        : o
          , s = i.updateObj
          , c = void 0 === s ? function(e, t) {}
        : s
          , l = i.exitObj
          , u = void 0 === l ? function(e) {}
        : l
          , h = i.objBindAttr
          , d = void 0 === h ? "__obj" : h
          , p = i.dataBindAttr
          , f = void 0 === p ? "__data" : p
          , m = Cc(i, ["createObj", "updateObj", "exitObj", "objBindAttr", "dataBindAttr"])
          , g = Oc(e, t, function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = null != arguments[t] ? arguments[t] : {};
                t % 2 ? Pc(Object(n), !0).forEach((function(t) {
                    Ac(e, t, n[t])
                }
                )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Pc(Object(n)).forEach((function(t) {
                    Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
                }
                ))
            }
            return e
        }({
            objBindAttr: d,
            dataBindAttr: f
        }, m))
          , v = g.enter
          , y = g.update;
        g.exit.forEach((function(e) {
            var t = e[d];
            delete e[d],
            u(t),
            r(t)
        }
        ));
        var b = function(e) {
            var t = [];
            return e.forEach((function(e) {
                var n = a(e);
                n && (n[f] = e,
                e[d] = n,
                t.push(n))
            }
            )),
            t
        }(v);
        !function(e) {
            e.forEach((function(e) {
                var t = e[d];
                t && (t[f] = e,
                c(t, e))
            }
            ))
        }([].concat(Dc(v), Dc(y))),
        b.forEach(n)
    }
    function Ic(e, t) {
        switch (arguments.length) {
        case 0:
            break;
        case 1:
            this.range(e);
            break;
        default:
            this.range(t).domain(e)
        }
        return this
    }
    const kc = Symbol("implicit");
    var zc = function(e) {
        for (var t = e.length / 6 | 0, n = new Array(t), r = 0; r < t; )
            n[r] = "#" + e.slice(6 * r, 6 * ++r);
        return n
    }("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928")
      , Fc = sc((function(e) {
        !function(t) {
            var n = /^\s+/
              , r = /\s+$/
              , i = 0
              , o = t.round
              , a = t.min
              , s = t.max
              , c = t.random;
            function l(e, c) {
                if (c = c || {},
                (e = e || "")instanceof l)
                    return e;
                if (!(this instanceof l))
                    return new l(e,c);
                var u = function(e) {
                    var i = {
                        r: 0,
                        g: 0,
                        b: 0
                    }
                      , o = 1
                      , c = null
                      , l = null
                      , u = null
                      , h = !1
                      , d = !1;
                    "string" == typeof e && (e = function(e) {
                        e = e.replace(n, "").replace(r, "").toLowerCase();
                        var t, i = !1;
                        if (L[e])
                            e = L[e],
                            i = !0;
                        else if ("transparent" == e)
                            return {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 0,
                                format: "name"
                            };
                        if (t = U.rgb.exec(e))
                            return {
                                r: t[1],
                                g: t[2],
                                b: t[3]
                            };
                        if (t = U.rgba.exec(e))
                            return {
                                r: t[1],
                                g: t[2],
                                b: t[3],
                                a: t[4]
                            };
                        if (t = U.hsl.exec(e))
                            return {
                                h: t[1],
                                s: t[2],
                                l: t[3]
                            };
                        if (t = U.hsla.exec(e))
                            return {
                                h: t[1],
                                s: t[2],
                                l: t[3],
                                a: t[4]
                            };
                        if (t = U.hsv.exec(e))
                            return {
                                h: t[1],
                                s: t[2],
                                v: t[3]
                            };
                        if (t = U.hsva.exec(e))
                            return {
                                h: t[1],
                                s: t[2],
                                v: t[3],
                                a: t[4]
                            };
                        if (t = U.hex8.exec(e))
                            return {
                                r: D(t[1]),
                                g: D(t[2]),
                                b: D(t[3]),
                                a: k(t[4]),
                                format: i ? "name" : "hex8"
                            };
                        if (t = U.hex6.exec(e))
                            return {
                                r: D(t[1]),
                                g: D(t[2]),
                                b: D(t[3]),
                                format: i ? "name" : "hex"
                            };
                        if (t = U.hex4.exec(e))
                            return {
                                r: D(t[1] + "" + t[1]),
                                g: D(t[2] + "" + t[2]),
                                b: D(t[3] + "" + t[3]),
                                a: k(t[4] + "" + t[4]),
                                format: i ? "name" : "hex8"
                            };
                        if (t = U.hex3.exec(e))
                            return {
                                r: D(t[1] + "" + t[1]),
                                g: D(t[2] + "" + t[2]),
                                b: D(t[3] + "" + t[3]),
                                format: i ? "name" : "hex"
                            };
                        return !1
                    }(e));
                    "object" == typeof e && (H(e.r) && H(e.g) && H(e.b) ? (p = e.r,
                    f = e.g,
                    m = e.b,
                    i = {
                        r: 255 * C(p, 255),
                        g: 255 * C(f, 255),
                        b: 255 * C(m, 255)
                    },
                    h = !0,
                    d = "%" === String(e.r).substr(-1) ? "prgb" : "rgb") : H(e.h) && H(e.s) && H(e.v) ? (c = N(e.s),
                    l = N(e.v),
                    i = function(e, n, r) {
                        e = 6 * C(e, 360),
                        n = C(n, 100),
                        r = C(r, 100);
                        var i = t.floor(e)
                          , o = e - i
                          , a = r * (1 - n)
                          , s = r * (1 - o * n)
                          , c = r * (1 - (1 - o) * n)
                          , l = i % 6;
                        return {
                            r: 255 * [r, s, a, a, c, r][l],
                            g: 255 * [c, r, r, s, a, a][l],
                            b: 255 * [a, a, c, r, r, s][l]
                        }
                    }(e.h, c, l),
                    h = !0,
                    d = "hsv") : H(e.h) && H(e.s) && H(e.l) && (c = N(e.s),
                    u = N(e.l),
                    i = function(e, t, n) {
                        var r, i, o;
                        function a(e, t, n) {
                            return n < 0 && (n += 1),
                            n > 1 && (n -= 1),
                            n < 1 / 6 ? e + 6 * (t - e) * n : n < .5 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e
                        }
                        if (e = C(e, 360),
                        t = C(t, 100),
                        n = C(n, 100),
                        0 === t)
                            r = i = o = n;
                        else {
                            var s = n < .5 ? n * (1 + t) : n + t - n * t
                              , c = 2 * n - s;
                            r = a(c, s, e + 1 / 3),
                            i = a(c, s, e),
                            o = a(c, s, e - 1 / 3)
                        }
                        return {
                            r: 255 * r,
                            g: 255 * i,
                            b: 255 * o
                        }
                    }(e.h, c, u),
                    h = !0,
                    d = "hsl"),
                    e.hasOwnProperty("a") && (o = e.a));
                    var p, f, m;
                    return o = P(o),
                    {
                        ok: h,
                        format: e.format || d,
                        r: a(255, s(i.r, 0)),
                        g: a(255, s(i.g, 0)),
                        b: a(255, s(i.b, 0)),
                        a: o
                    }
                }(e);
                this._originalInput = e,
                this._r = u.r,
                this._g = u.g,
                this._b = u.b,
                this._a = u.a,
                this._roundA = o(100 * this._a) / 100,
                this._format = c.format || u.format,
                this._gradientType = c.gradientType,
                this._r < 1 && (this._r = o(this._r)),
                this._g < 1 && (this._g = o(this._g)),
                this._b < 1 && (this._b = o(this._b)),
                this._ok = u.ok,
                this._tc_id = i++
            }
            function u(e, t, n) {
                e = C(e, 255),
                t = C(t, 255),
                n = C(n, 255);
                var r, i, o = s(e, t, n), c = a(e, t, n), l = (o + c) / 2;
                if (o == c)
                    r = i = 0;
                else {
                    var u = o - c;
                    switch (i = l > .5 ? u / (2 - o - c) : u / (o + c),
                    o) {
                    case e:
                        r = (t - n) / u + (t < n ? 6 : 0);
                        break;
                    case t:
                        r = (n - e) / u + 2;
                        break;
                    case n:
                        r = (e - t) / u + 4
                    }
                    r /= 6
                }
                return {
                    h: r,
                    s: i,
                    l: l
                }
            }
            function h(e, t, n) {
                e = C(e, 255),
                t = C(t, 255),
                n = C(n, 255);
                var r, i, o = s(e, t, n), c = a(e, t, n), l = o, u = o - c;
                if (i = 0 === o ? 0 : u / o,
                o == c)
                    r = 0;
                else {
                    switch (o) {
                    case e:
                        r = (t - n) / u + (t < n ? 6 : 0);
                        break;
                    case t:
                        r = (n - e) / u + 2;
                        break;
                    case n:
                        r = (e - t) / u + 4
                    }
                    r /= 6
                }
                return {
                    h: r,
                    s: i,
                    v: l
                }
            }
            function d(e, t, n, r) {
                var i = [O(o(e).toString(16)), O(o(t).toString(16)), O(o(n).toString(16))];
                return r && i[0].charAt(0) == i[0].charAt(1) && i[1].charAt(0) == i[1].charAt(1) && i[2].charAt(0) == i[2].charAt(1) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("")
            }
            function p(e, t, n, r) {
                return [O(I(r)), O(o(e).toString(16)), O(o(t).toString(16)), O(o(n).toString(16))].join("")
            }
            function f(e, t) {
                t = 0 === t ? 0 : t || 10;
                var n = l(e).toHsl();
                return n.s -= t / 100,
                n.s = R(n.s),
                l(n)
            }
            function m(e, t) {
                t = 0 === t ? 0 : t || 10;
                var n = l(e).toHsl();
                return n.s += t / 100,
                n.s = R(n.s),
                l(n)
            }
            function g(e) {
                return l(e).desaturate(100)
            }
            function v(e, t) {
                t = 0 === t ? 0 : t || 10;
                var n = l(e).toHsl();
                return n.l += t / 100,
                n.l = R(n.l),
                l(n)
            }
            function y(e, t) {
                t = 0 === t ? 0 : t || 10;
                var n = l(e).toRgb();
                return n.r = s(0, a(255, n.r - o(-t / 100 * 255))),
                n.g = s(0, a(255, n.g - o(-t / 100 * 255))),
                n.b = s(0, a(255, n.b - o(-t / 100 * 255))),
                l(n)
            }
            function b(e, t) {
                t = 0 === t ? 0 : t || 10;
                var n = l(e).toHsl();
                return n.l -= t / 100,
                n.l = R(n.l),
                l(n)
            }
            function x(e, t) {
                var n = l(e).toHsl()
                  , r = (n.h + t) % 360;
                return n.h = r < 0 ? 360 + r : r,
                l(n)
            }
            function _(e) {
                var t = l(e).toHsl();
                return t.h = (t.h + 180) % 360,
                l(t)
            }
            function w(e) {
                var t = l(e).toHsl()
                  , n = t.h;
                return [l(e), l({
                    h: (n + 120) % 360,
                    s: t.s,
                    l: t.l
                }), l({
                    h: (n + 240) % 360,
                    s: t.s,
                    l: t.l
                })]
            }
            function M(e) {
                var t = l(e).toHsl()
                  , n = t.h;
                return [l(e), l({
                    h: (n + 90) % 360,
                    s: t.s,
                    l: t.l
                }), l({
                    h: (n + 180) % 360,
                    s: t.s,
                    l: t.l
                }), l({
                    h: (n + 270) % 360,
                    s: t.s,
                    l: t.l
                })]
            }
            function E(e) {
                var t = l(e).toHsl()
                  , n = t.h;
                return [l(e), l({
                    h: (n + 72) % 360,
                    s: t.s,
                    l: t.l
                }), l({
                    h: (n + 216) % 360,
                    s: t.s,
                    l: t.l
                })]
            }
            function S(e, t, n) {
                t = t || 6,
                n = n || 30;
                var r = l(e).toHsl()
                  , i = 360 / n
                  , o = [l(e)];
                for (r.h = (r.h - (i * t >> 1) + 720) % 360; --t; )
                    r.h = (r.h + i) % 360,
                    o.push(l(r));
                return o
            }
            function T(e, t) {
                t = t || 6;
                for (var n = l(e).toHsv(), r = n.h, i = n.s, o = n.v, a = [], s = 1 / t; t--; )
                    a.push(l({
                        h: r,
                        s: i,
                        v: o
                    })),
                    o = (o + s) % 1;
                return a
            }
            l.prototype = {
                isDark: function() {
                    return this.getBrightness() < 128
                },
                isLight: function() {
                    return !this.isDark()
                },
                isValid: function() {
                    return this._ok
                },
                getOriginalInput: function() {
                    return this._originalInput
                },
                getFormat: function() {
                    return this._format
                },
                getAlpha: function() {
                    return this._a
                },
                getBrightness: function() {
                    var e = this.toRgb();
                    return (299 * e.r + 587 * e.g + 114 * e.b) / 1e3
                },
                getLuminance: function() {
                    var e, n, r, i = this.toRgb();
                    return e = i.r / 255,
                    n = i.g / 255,
                    r = i.b / 255,
                    .2126 * (e <= .03928 ? e / 12.92 : t.pow((e + .055) / 1.055, 2.4)) + .7152 * (n <= .03928 ? n / 12.92 : t.pow((n + .055) / 1.055, 2.4)) + .0722 * (r <= .03928 ? r / 12.92 : t.pow((r + .055) / 1.055, 2.4))
                },
                setAlpha: function(e) {
                    return this._a = P(e),
                    this._roundA = o(100 * this._a) / 100,
                    this
                },
                toHsv: function() {
                    var e = h(this._r, this._g, this._b);
                    return {
                        h: 360 * e.h,
                        s: e.s,
                        v: e.v,
                        a: this._a
                    }
                },
                toHsvString: function() {
                    var e = h(this._r, this._g, this._b)
                      , t = o(360 * e.h)
                      , n = o(100 * e.s)
                      , r = o(100 * e.v);
                    return 1 == this._a ? "hsv(" + t + ", " + n + "%, " + r + "%)" : "hsva(" + t + ", " + n + "%, " + r + "%, " + this._roundA + ")"
                },
                toHsl: function() {
                    var e = u(this._r, this._g, this._b);
                    return {
                        h: 360 * e.h,
                        s: e.s,
                        l: e.l,
                        a: this._a
                    }
                },
                toHslString: function() {
                    var e = u(this._r, this._g, this._b)
                      , t = o(360 * e.h)
                      , n = o(100 * e.s)
                      , r = o(100 * e.l);
                    return 1 == this._a ? "hsl(" + t + ", " + n + "%, " + r + "%)" : "hsla(" + t + ", " + n + "%, " + r + "%, " + this._roundA + ")"
                },
                toHex: function(e) {
                    return d(this._r, this._g, this._b, e)
                },
                toHexString: function(e) {
                    return "#" + this.toHex(e)
                },
                toHex8: function(e) {
                    return function(e, t, n, r, i) {
                        var a = [O(o(e).toString(16)), O(o(t).toString(16)), O(o(n).toString(16)), O(I(r))];
                        if (i && a[0].charAt(0) == a[0].charAt(1) && a[1].charAt(0) == a[1].charAt(1) && a[2].charAt(0) == a[2].charAt(1) && a[3].charAt(0) == a[3].charAt(1))
                            return a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) + a[3].charAt(0);
                        return a.join("")
                    }(this._r, this._g, this._b, this._a, e)
                },
                toHex8String: function(e) {
                    return "#" + this.toHex8(e)
                },
                toRgb: function() {
                    return {
                        r: o(this._r),
                        g: o(this._g),
                        b: o(this._b),
                        a: this._a
                    }
                },
                toRgbString: function() {
                    return 1 == this._a ? "rgb(" + o(this._r) + ", " + o(this._g) + ", " + o(this._b) + ")" : "rgba(" + o(this._r) + ", " + o(this._g) + ", " + o(this._b) + ", " + this._roundA + ")"
                },
                toPercentageRgb: function() {
                    return {
                        r: o(100 * C(this._r, 255)) + "%",
                        g: o(100 * C(this._g, 255)) + "%",
                        b: o(100 * C(this._b, 255)) + "%",
                        a: this._a
                    }
                },
                toPercentageRgbString: function() {
                    return 1 == this._a ? "rgb(" + o(100 * C(this._r, 255)) + "%, " + o(100 * C(this._g, 255)) + "%, " + o(100 * C(this._b, 255)) + "%)" : "rgba(" + o(100 * C(this._r, 255)) + "%, " + o(100 * C(this._g, 255)) + "%, " + o(100 * C(this._b, 255)) + "%, " + this._roundA + ")"
                },
                toName: function() {
                    return 0 === this._a ? "transparent" : !(this._a < 1) && (A[d(this._r, this._g, this._b, !0)] || !1)
                },
                toFilter: function(e) {
                    var t = "#" + p(this._r, this._g, this._b, this._a)
                      , n = t
                      , r = this._gradientType ? "GradientType = 1, " : "";
                    if (e) {
                        var i = l(e);
                        n = "#" + p(i._r, i._g, i._b, i._a)
                    }
                    return "progid:DXImageTransform.Microsoft.gradient(" + r + "startColorstr=" + t + ",endColorstr=" + n + ")"
                },
                toString: function(e) {
                    var t = !!e;
                    e = e || this._format;
                    var n = !1
                      , r = this._a < 1 && this._a >= 0;
                    return t || !r || "hex" !== e && "hex6" !== e && "hex3" !== e && "hex4" !== e && "hex8" !== e && "name" !== e ? ("rgb" === e && (n = this.toRgbString()),
                    "prgb" === e && (n = this.toPercentageRgbString()),
                    "hex" !== e && "hex6" !== e || (n = this.toHexString()),
                    "hex3" === e && (n = this.toHexString(!0)),
                    "hex4" === e && (n = this.toHex8String(!0)),
                    "hex8" === e && (n = this.toHex8String()),
                    "name" === e && (n = this.toName()),
                    "hsl" === e && (n = this.toHslString()),
                    "hsv" === e && (n = this.toHsvString()),
                    n || this.toHexString()) : "name" === e && 0 === this._a ? this.toName() : this.toRgbString()
                },
                clone: function() {
                    return l(this.toString())
                },
                _applyModification: function(e, t) {
                    var n = e.apply(null, [this].concat([].slice.call(t)));
                    return this._r = n._r,
                    this._g = n._g,
                    this._b = n._b,
                    this.setAlpha(n._a),
                    this
                },
                lighten: function() {
                    return this._applyModification(v, arguments)
                },
                brighten: function() {
                    return this._applyModification(y, arguments)
                },
                darken: function() {
                    return this._applyModification(b, arguments)
                },
                desaturate: function() {
                    return this._applyModification(f, arguments)
                },
                saturate: function() {
                    return this._applyModification(m, arguments)
                },
                greyscale: function() {
                    return this._applyModification(g, arguments)
                },
                spin: function() {
                    return this._applyModification(x, arguments)
                },
                _applyCombination: function(e, t) {
                    return e.apply(null, [this].concat([].slice.call(t)))
                },
                analogous: function() {
                    return this._applyCombination(S, arguments)
                },
                complement: function() {
                    return this._applyCombination(_, arguments)
                },
                monochromatic: function() {
                    return this._applyCombination(T, arguments)
                },
                splitcomplement: function() {
                    return this._applyCombination(E, arguments)
                },
                triad: function() {
                    return this._applyCombination(w, arguments)
                },
                tetrad: function() {
                    return this._applyCombination(M, arguments)
                }
            },
            l.fromRatio = function(e, t) {
                if ("object" == typeof e) {
                    var n = {};
                    for (var r in e)
                        e.hasOwnProperty(r) && (n[r] = "a" === r ? e[r] : N(e[r]));
                    e = n
                }
                return l(e, t)
            }
            ,
            l.equals = function(e, t) {
                return !(!e || !t) && l(e).toRgbString() == l(t).toRgbString()
            }
            ,
            l.random = function() {
                return l.fromRatio({
                    r: c(),
                    g: c(),
                    b: c()
                })
            }
            ,
            l.mix = function(e, t, n) {
                n = 0 === n ? 0 : n || 50;
                var r = l(e).toRgb()
                  , i = l(t).toRgb()
                  , o = n / 100;
                return l({
                    r: (i.r - r.r) * o + r.r,
                    g: (i.g - r.g) * o + r.g,
                    b: (i.b - r.b) * o + r.b,
                    a: (i.a - r.a) * o + r.a
                })
            }
            ,
            // <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)
            // Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
            l.readability = function(e, n) {
                var r = l(e)
                  , i = l(n);
                return (t.max(r.getLuminance(), i.getLuminance()) + .05) / (t.min(r.getLuminance(), i.getLuminance()) + .05)
            }
            ,
            l.isReadable = function(e, t, n) {
                var r, i, o = l.readability(e, t);
                switch (i = !1,
                (r = function(e) {
                    var t, n;
                    t = ((e = e || {
                        level: "AA",
                        size: "small"
                    }).level || "AA").toUpperCase(),
                    n = (e.size || "small").toLowerCase(),
                    "AA" !== t && "AAA" !== t && (t = "AA");
                    "small" !== n && "large" !== n && (n = "small");
                    return {
                        level: t,
                        size: n
                    }
                }(n)).level + r.size) {
                case "AAsmall":
                case "AAAlarge":
                    i = o >= 4.5;
                    break;
                case "AAlarge":
                    i = o >= 3;
                    break;
                case "AAAsmall":
                    i = o >= 7
                }
                return i
            }
            ,
            l.mostReadable = function(e, t, n) {
                var r, i, o, a, s = null, c = 0;
                i = (n = n || {}).includeFallbackColors,
                o = n.level,
                a = n.size;
                for (var u = 0; u < t.length; u++)
                    (r = l.readability(e, t[u])) > c && (c = r,
                    s = l(t[u]));
                return l.isReadable(e, s, {
                    level: o,
                    size: a
                }) || !i ? s : (n.includeFallbackColors = !1,
                l.mostReadable(e, ["#fff", "#000"], n))
            }
            ;
            var L = l.names = {
                aliceblue: "f0f8ff",
                antiquewhite: "faebd7",
                aqua: "0ff",
                aquamarine: "7fffd4",
                azure: "f0ffff",
                beige: "f5f5dc",
                bisque: "ffe4c4",
                black: "000",
                blanchedalmond: "ffebcd",
                blue: "00f",
                blueviolet: "8a2be2",
                brown: "a52a2a",
                burlywood: "deb887",
                burntsienna: "ea7e5d",
                cadetblue: "5f9ea0",
                chartreuse: "7fff00",
                chocolate: "d2691e",
                coral: "ff7f50",
                cornflowerblue: "6495ed",
                cornsilk: "fff8dc",
                crimson: "dc143c",
                cyan: "0ff",
                darkblue: "00008b",
                darkcyan: "008b8b",
                darkgoldenrod: "b8860b",
                darkgray: "a9a9a9",
                darkgreen: "006400",
                darkgrey: "a9a9a9",
                darkkhaki: "bdb76b",
                darkmagenta: "8b008b",
                darkolivegreen: "556b2f",
                darkorange: "ff8c00",
                darkorchid: "9932cc",
                darkred: "8b0000",
                darksalmon: "e9967a",
                darkseagreen: "8fbc8f",
                darkslateblue: "483d8b",
                darkslategray: "2f4f4f",
                darkslategrey: "2f4f4f",
                darkturquoise: "00ced1",
                darkviolet: "9400d3",
                deeppink: "ff1493",
                deepskyblue: "00bfff",
                dimgray: "696969",
                dimgrey: "696969",
                dodgerblue: "1e90ff",
                firebrick: "b22222",
                floralwhite: "fffaf0",
                forestgreen: "228b22",
                fuchsia: "f0f",
                gainsboro: "dcdcdc",
                ghostwhite: "f8f8ff",
                gold: "ffd700",
                goldenrod: "daa520",
                gray: "808080",
                green: "008000",
                greenyellow: "adff2f",
                grey: "808080",
                honeydew: "f0fff0",
                hotpink: "ff69b4",
                indianred: "cd5c5c",
                indigo: "4b0082",
                ivory: "fffff0",
                khaki: "f0e68c",
                lavender: "e6e6fa",
                lavenderblush: "fff0f5",
                lawngreen: "7cfc00",
                lemonchiffon: "fffacd",
                lightblue: "add8e6",
                lightcoral: "f08080",
                lightcyan: "e0ffff",
                lightgoldenrodyellow: "fafad2",
                lightgray: "d3d3d3",
                lightgreen: "90ee90",
                lightgrey: "d3d3d3",
                lightpink: "ffb6c1",
                lightsalmon: "ffa07a",
                lightseagreen: "20b2aa",
                lightskyblue: "87cefa",
                lightslategray: "789",
                lightslategrey: "789",
                lightsteelblue: "b0c4de",
                lightyellow: "ffffe0",
                lime: "0f0",
                limegreen: "32cd32",
                linen: "faf0e6",
                magenta: "f0f",
                maroon: "800000",
                mediumaquamarine: "66cdaa",
                mediumblue: "0000cd",
                mediumorchid: "ba55d3",
                mediumpurple: "9370db",
                mediumseagreen: "3cb371",
                mediumslateblue: "7b68ee",
                mediumspringgreen: "00fa9a",
                mediumturquoise: "48d1cc",
                mediumvioletred: "c71585",
                midnightblue: "191970",
                mintcream: "f5fffa",
                mistyrose: "ffe4e1",
                moccasin: "ffe4b5",
                navajowhite: "ffdead",
                navy: "000080",
                oldlace: "fdf5e6",
                olive: "808000",
                olivedrab: "6b8e23",
                orange: "ffa500",
                orangered: "ff4500",
                orchid: "da70d6",
                palegoldenrod: "eee8aa",
                palegreen: "98fb98",
                paleturquoise: "afeeee",
                palevioletred: "db7093",
                papayawhip: "ffefd5",
                peachpuff: "ffdab9",
                peru: "cd853f",
                pink: "ffc0cb",
                plum: "dda0dd",
                powderblue: "b0e0e6",
                purple: "800080",
                rebeccapurple: "663399",
                red: "f00",
                rosybrown: "bc8f8f",
                royalblue: "4169e1",
                saddlebrown: "8b4513",
                salmon: "fa8072",
                sandybrown: "f4a460",
                seagreen: "2e8b57",
                seashell: "fff5ee",
                sienna: "a0522d",
                silver: "c0c0c0",
                skyblue: "87ceeb",
                slateblue: "6a5acd",
                slategray: "708090",
                slategrey: "708090",
                snow: "fffafa",
                springgreen: "00ff7f",
                steelblue: "4682b4",
                tan: "d2b48c",
                teal: "008080",
                thistle: "d8bfd8",
                tomato: "ff6347",
                turquoise: "40e0d0",
                violet: "ee82ee",
                wheat: "f5deb3",
                white: "fff",
                whitesmoke: "f5f5f5",
                yellow: "ff0",
                yellowgreen: "9acd32"
            }
              , A = l.hexNames = function(e) {
                var t = {};
                for (var n in e)
                    e.hasOwnProperty(n) && (t[e[n]] = n);
                return t
            }(L);
            function P(e) {
                return e = parseFloat(e),
                (isNaN(e) || e < 0 || e > 1) && (e = 1),
                e
            }
            function C(e, n) {
                (function(e) {
                    return "string" == typeof e && -1 != e.indexOf(".") && 1 === parseFloat(e)
                }
                )(e) && (e = "100%");
                var r = function(e) {
                    return "string" == typeof e && -1 != e.indexOf("%")
                }(e);
                return e = a(n, s(0, parseFloat(e))),
                r && (e = parseInt(e * n, 10) / 100),
                t.abs(e - n) < 1e-6 ? 1 : e % n / parseFloat(n)
            }
            function R(e) {
                return a(1, s(0, e))
            }
            function D(e) {
                return parseInt(e, 16)
            }
            function O(e) {
                return 1 == e.length ? "0" + e : "" + e
            }
            function N(e) {
                return e <= 1 && (e = 100 * e + "%"),
                e
            }
            function I(e) {
                return t.round(255 * parseFloat(e)).toString(16)
            }
            function k(e) {
                return D(e) / 255
            }
            var z, F, B, U = (F = "[\\s|\\(]+(" + (z = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)") + ")[,|\\s]+(" + z + ")[,|\\s]+(" + z + ")\\s*\\)?",
            B = "[\\s|\\(]+(" + z + ")[,|\\s]+(" + z + ")[,|\\s]+(" + z + ")[,|\\s]+(" + z + ")\\s*\\)?",
            {
                CSS_UNIT: new RegExp(z),
                rgb: new RegExp("rgb" + F),
                rgba: new RegExp("rgba" + B),
                hsl: new RegExp("hsl" + F),
                hsla: new RegExp("hsla" + B),
                hsv: new RegExp("hsv" + F),
                hsva: new RegExp("hsva" + B),
                hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
                hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
            });
            function H(e) {
                return !!U.CSS_UNIT.exec(e)
            }
            e.exports ? e.exports = l : window.tinycolor = l
        }(Math)
    }
    ));
    function Bc(e) {
        return (Bc = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
        }
        : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
        }
        )(e)
    }
    function Uc(e, t) {
        if (!(e instanceof t))
            throw new TypeError("Cannot call a class as a function")
    }
    function Hc(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n,
        e
    }
    function jc(e, t) {
        var n = Object.keys(e);
        if (Object.getOwnPropertySymbols) {
            var r = Object.getOwnPropertySymbols(e);
            t && (r = r.filter((function(t) {
                return Object.getOwnPropertyDescriptor(e, t).enumerable
            }
            ))),
            n.push.apply(n, r)
        }
        return n
    }
    function Gc(e) {
        for (var t = 1; t < arguments.length; t++) {
            var n = null != arguments[t] ? arguments[t] : {};
            t % 2 ? jc(Object(n), !0).forEach((function(t) {
                Hc(e, t, n[t])
            }
            )) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jc(Object(n)).forEach((function(t) {
                Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(n, t))
            }
            ))
        }
        return e
    }
    function Vc(e, t) {
        if ("function" != typeof t && null !== t)
            throw new TypeError("Super expression must either be null or a function");
        e.prototype = Object.create(t && t.prototype, {
            constructor: {
                value: e,
                writable: !0,
                configurable: !0
            }
        }),
        t && qc(e, t)
    }
    function Wc(e) {
        return (Wc = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        }
        )(e)
    }
    function qc(e, t) {
        return (qc = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t,
            e
        }
        )(e, t)
    }
    function Xc() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
            return !1;
        if (Reflect.construct.sham)
            return !1;
        if ("function" == typeof Proxy)
            return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
            ))),
            !0
        } catch (e) {
            return !1
        }
    }
    function Yc(e, t, n) {
        return (Yc = Xc() ? Reflect.construct : function(e, t, n) {
            var r = [null];
            r.push.apply(r, t);
            var i = new (Function.bind.apply(e, r));
            return n && qc(i, n.prototype),
            i
        }
        ).apply(null, arguments)
    }
    function Zc(e, t) {
        if (null == e)
            return {};
        var n, r, i = function(e, t) {
            if (null == e)
                return {};
            var n, r, i = {}, o = Object.keys(e);
            for (r = 0; r < o.length; r++)
                n = o[r],
                t.indexOf(n) >= 0 || (i[n] = e[n]);
            return i
        }(e, t);
        if (Object.getOwnPropertySymbols) {
            var o = Object.getOwnPropertySymbols(e);
            for (r = 0; r < o.length; r++)
                n = o[r],
                t.indexOf(n) >= 0 || Object.prototype.propertyIsEnumerable.call(e, n) && (i[n] = e[n])
        }
        return i
    }
    function $c(e) {
        if (void 0 === e)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }
    function Jc(e, t) {
        return !t || "object" != typeof t && "function" != typeof t ? $c(e) : t
    }
    function Qc(e) {
        var t = Xc();
        return function() {
            var n, r = Wc(e);
            if (t) {
                var i = Wc(this).constructor;
                n = Reflect.construct(r, arguments, i)
            } else
                n = r.apply(this, arguments);
            return Jc(this, n)
        }
    }
    function Kc(e, t) {
        return function(e) {
            if (Array.isArray(e))
                return e
        }(e) || function(e, t) {
            if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(e)))
                return;
            var n = []
              , r = !0
              , i = !1
              , o = void 0;
            try {
                for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value),
                !t || n.length !== t); r = !0)
                    ;
            } catch (e) {
                i = !0,
                o = e
            } finally {
                try {
                    r || null == s.return || s.return()
                } finally {
                    if (i)
                        throw o
                }
            }
            return n
        }(e, t) || tl(e, t) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function el(e) {
        return function(e) {
            if (Array.isArray(e))
                return nl(e)
        }(e) || function(e) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e))
                return Array.from(e)
        }(e) || tl(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function tl(e, t) {
        if (e) {
            if ("string" == typeof e)
                return nl(e, t);
            var n = Object.prototype.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name),
            "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? nl(e, t) : void 0
        }
    }
    function nl(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, r = new Array(t); n < t; n++)
            r[n] = e[n];
        return r
    }
    var rl = function e(t) {
        t instanceof Array ? t.forEach(e) : (t.map && t.map.dispose(),
        t.dispose())
    }
      , il = function e(t) {
        t.geometry && t.geometry.dispose(),
        t.material && rl(t.material),
        t.texture && t.texture.dispose(),
        t.children && t.children.forEach(e)
    }
      , ol = function(e) {
        for (; e.children.length; ) {
            var t = e.children[0];
            e.remove(t),
            il(t)
        }
    };
    function al(e, t) {
        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
          , r = n.objFilter
          , i = void 0 === r ? function() {
            return !0
        }
        : r
          , o = Zc(n, ["objFilter"]);
        return Nc(e, t.children.filter(i), (function(e) {
            return t.add(e)
        }
        ), (function(e) {
            t.remove(e),
            ol(e)
        }
        ), Gc({
            objBindAttr: "__threeObj"
        }, o))
    }
    var sl = function(e) {
        return isNaN(e) ? parseInt(Fc(e).toHex(), 16) : e
    }
      , cl = function(e) {
        return isNaN(e) ? Fc(e).getAlpha() : 1
    }
      , ll = function e() {
        var t = new Map
          , n = []
          , r = []
          , i = kc;
        function o(e) {
            var o = e + ""
              , a = t.get(o);
            if (!a) {
                if (i !== kc)
                    return i;
                t.set(o, a = n.push(e))
            }
            return r[(a - 1) % r.length]
        }
        return o.domain = function(e) {
            if (!arguments.length)
                return n.slice();
            n = [],
            t = new Map;
            for (const r of e) {
                const e = r + "";
                t.has(e) || t.set(e, n.push(r))
            }
            return o
        }
        ,
        o.range = function(e) {
            return arguments.length ? (r = Array.from(e),
            o) : r.slice()
        }
        ,
        o.unknown = function(e) {
            return arguments.length ? (i = e,
            o) : i
        }
        ,
        o.copy = function() {
            return e(n, r).unknown(i)
        }
        ,
        Ic.apply(o, arguments),
        o
    }(zc);
    function ul(e, t, n) {
        t && "string" == typeof n && e.filter((function(e) {
            return !e[n]
        }
        )).forEach((function(e) {
            e[n] = ll(t(e))
        }
        ))
    }
    var hl = window.THREE ? window.THREE : {
        Group: Di,
        Mesh: an,
        MeshLambertMaterial: Mo,
        Color: yt,
        BufferGeometry: Ht,
        BufferAttribute: wt,
        Matrix4: Me,
        Vector3: q,
        SphereBufferGeometry: xo,
        CylinderBufferGeometry: yo,
        TubeBufferGeometry: class extends Ht {
            constructor(e, t=64, n=1, r=8, i=!1) {
                super(),
                this.type = "TubeGeometry",
                this.parameters = {
                    path: e,
                    tubularSegments: t,
                    radius: n,
                    radialSegments: r,
                    closed: i
                };
                const o = e.computeFrenetFrames(t, i);
                this.tangents = o.tangents,
                this.normals = o.normals,
                this.binormals = o.binormals;
                const a = new q
                  , s = new q
                  , c = new k;
                let l = new q;
                const u = []
                  , h = []
                  , d = []
                  , p = [];
                function f(i) {
                    l = e.getPointAt(i / t, l);
                    const c = o.normals[i]
                      , d = o.binormals[i];
                    for (let e = 0; e <= r; e++) {
                        const t = e / r * Math.PI * 2
                          , i = Math.sin(t)
                          , o = -Math.cos(t);
                        s.x = o * c.x + i * d.x,
                        s.y = o * c.y + i * d.y,
                        s.z = o * c.z + i * d.z,
                        s.normalize(),
                        h.push(s.x, s.y, s.z),
                        a.x = l.x + n * s.x,
                        a.y = l.y + n * s.y,
                        a.z = l.z + n * s.z,
                        u.push(a.x, a.y, a.z)
                    }
                }
                !function() {
                    for (let e = 0; e < t; e++)
                        f(e);
                    f(!1 === i ? t : 0),
                    function() {
                        for (let e = 0; e <= t; e++)
                            for (let n = 0; n <= r; n++)
                                c.x = e / t,
                                c.y = n / r,
                                d.push(c.x, c.y)
                    }(),
                    function() {
                        for (let e = 1; e <= t; e++)
                            for (let t = 1; t <= r; t++) {
                                const n = (r + 1) * (e - 1) + (t - 1)
                                  , i = (r + 1) * e + (t - 1)
                                  , o = (r + 1) * e + t
                                  , a = (r + 1) * (e - 1) + t;
                                p.push(n, i, a),
                                p.push(i, o, a)
                            }
                    }()
                }(),
                this.setIndex(p),
                this.setAttribute("position", new Rt(u,3)),
                this.setAttribute("normal", new Rt(h,3)),
                this.setAttribute("uv", new Rt(d,2))
            }
            toJSON() {
                const e = Ht.prototype.toJSON.call(this);
                return e.path = this.parameters.path.toJSON(),
                e
            }
        }
        ,
        ConeBufferGeometry: class extends yo {
            constructor(e=1, t=1, n=8, r=1, i=!1, o=0, a=2 * Math.PI) {
                super(0, e, t, n, r, i, o, a),
                this.type = "ConeGeometry",
                this.parameters = {
                    radius: e,
                    height: t,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: i,
                    thetaStart: o,
                    thetaLength: a
                }
            }
        }
        ,
        Line: oo,
        LineBasicMaterial: Ki,
        QuadraticBezierCurve3: Go,
        CubicBezierCurve3: jo,
        Box3: Z
    }
      , dl = {
        graph: Os,
        forcelayout: dc
    }
      , pl = (new hl.BufferGeometry).setAttribute ? "setAttribute" : "addAttribute"
      , fl = (new hl.BufferGeometry).applyMatrix4 ? "applyMatrix4" : "applyMatrix";
    var ml = function(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Object
          , n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2]
          , r = function(t) {
            Vc(i, t);
            var r = Qc(i);
            function i() {
                var t;
                Uc(this, i);
                for (var o = arguments.length, a = new Array(o), s = 0; s < o; s++)
                    a[s] = arguments[s];
                return (t = r.call.apply(r, [this].concat(a))).__kapsuleInstance = e().apply(void 0, [].concat(el(n ? [$c(t)] : []), a)),
                t
            }
            return i
        }(t);
        return Object.keys(e()).forEach((function(e) {
            return r.prototype[e] = function() {
                var t, n = (t = this.__kapsuleInstance)[e].apply(t, arguments);
                return n === this.__kapsuleInstance ? this : n
            }
        }
        )),
        r
    }(bc({
        props: {
            jsonUrl: {
                onChange: function(e, t) {
                    var n = this;
                    e && !t.fetchingJson && (t.fetchingJson = !0,
                    t.onLoading(),
                    fetch(e).then((function(e) {
                        return e.json()
                    }
                    )).then((function(e) {
                        t.fetchingJson = !1,
                        t.onFinishLoading(e),
                        n.graphData(e)
                    }
                    )))
                },
                triggerUpdate: !1
            },
            graphData: {
                default: {
                    nodes: [],
                    links: []
                },
                onChange: function(e, t) {
                    (e.nodes.length || e.links.length) && console.info("force-graph loading", e.nodes.length + " nodes", e.links.length + " links"),
                    t.engineRunning = !1
                }
            },
            numDimensions: {
                default: 3,
                onChange: function(e, t) {
                    var n = t.d3ForceLayout.force("charge");
                    function r(e, t) {
                        e.forEach((function(e) {
                            delete e[t],
                            delete e["v".concat(t)]
                        }
                        ))
                    }
                    n && n.strength(e > 2 ? -60 : -30),
                    e < 3 && r(t.graphData.nodes, "z"),
                    e < 2 && r(t.graphData.nodes, "y")
                }
            },
            dagMode: {
                onChange: function(e, t) {
                    !e && "d3" === t.forceEngine && (t.graphData.nodes || []).forEach((function(e) {
                        return e.fx = e.fy = e.fz = void 0
                    }
                    ))
                }
            },
            dagLevelDistance: {},
            dagNodeFilter: {
                default: function(e) {
                    return !0
                }
            },
            onDagError: {
                triggerUpdate: !1
            },
            nodeRelSize: {
                default: 4
            },
            nodeId: {
                default: "id"
            },
            nodeVal: {
                default: "val"
            },
            nodeResolution: {
                default: 8
            },
            nodeColor: {
                default: "color"
            },
            nodeAutoColorBy: {},
            nodeOpacity: {
                default: .75
            },
            nodeVisibility: {
                default: !0
            },
            nodeThreeObject: {},
            nodeThreeObjectExtend: {
                default: !1
            },
            linkSource: {
                default: "source"
            },
            linkTarget: {
                default: "target"
            },
            linkVisibility: {
                default: !0
            },
            linkColor: {
                default: "color"
            },
            linkAutoColorBy: {},
            linkOpacity: {
                default: .2
            },
            linkWidth: {},
            linkResolution: {
                default: 6
            },
            linkCurvature: {
                default: 0,
                triggerUpdate: !1
            },
            linkCurveRotation: {
                default: 0,
                triggerUpdate: !1
            },
            linkMaterial: {},
            linkThreeObject: {},
            linkThreeObjectExtend: {
                default: !1
            },
            linkPositionUpdate: {
                triggerUpdate: !1
            },
            linkDirectionalArrowLength: {
                default: 0
            },
            linkDirectionalArrowColor: {},
            linkDirectionalArrowRelPos: {
                default: .5,
                triggerUpdate: !1
            },
            linkDirectionalArrowResolution: {
                default: 8
            },
            linkDirectionalParticles: {
                default: 0
            },
            linkDirectionalParticleSpeed: {
                default: .01,
                triggerUpdate: !1
            },
            linkDirectionalParticleWidth: {
                default: .5
            },
            linkDirectionalParticleColor: {},
            linkDirectionalParticleResolution: {
                default: 4
            },
            forceEngine: {
                default: "d3"
            },
            d3AlphaMin: {
                default: 0,
                triggerUpdate: !1
            },
            d3AlphaDecay: {
                default: .0228,
                triggerUpdate: !1,
                onChange: function(e, t) {
                    t.d3ForceLayout.alphaDecay(e)
                }
            },
            d3AlphaTarget: {
                default: 0,
                triggerUpdate: !1,
                onChange: function(e, t) {
                    t.d3ForceLayout.alphaTarget(e)
                }
            },
            d3VelocityDecay: {
                default: .4,
                triggerUpdate: !1,
                onChange: function(e, t) {
                    t.d3ForceLayout.velocityDecay(e)
                }
            },
            ngraphPhysics: {
                default: {
                    timeStep: 20,
                    gravity: -1.2,
                    theta: .8,
                    springLength: 30,
                    springCoefficient: 8e-4,
                    dragCoefficient: .02
                }
            },
            warmupTicks: {
                default: 0,
                triggerUpdate: !1
            },
            cooldownTicks: {
                default: 1 / 0,
                triggerUpdate: !1
            },
            cooldownTime: {
                default: 15e3,
                triggerUpdate: !1
            },
            onLoading: {
                default: function() {},
                triggerUpdate: !1
            },
            onFinishLoading: {
                default: function() {},
                triggerUpdate: !1
            },
            onUpdate: {
                default: function() {},
                triggerUpdate: !1
            },
            onFinishUpdate: {
                default: function() {},
                triggerUpdate: !1
            },
            onEngineTick: {
                default: function() {},
                triggerUpdate: !1
            },
            onEngineStop: {
                default: function() {},
                triggerUpdate: !1
            }
        },
        methods: {
            refresh: function(e) {
                return e._flushObjects = !0,
                e._rerender(),
                this
            },
            d3Force: function(e, t, n) {
                return void 0 === n ? e.d3ForceLayout.force(t) : (e.d3ForceLayout.force(t, n),
                this)
            },
            d3ReheatSimulation: function(e) {
                return e.d3ForceLayout.alpha(1),
                this.resetCountdown(),
                this
            },
            resetCountdown: function(e) {
                return e.cntTicks = 0,
                e.startTickTime = new Date,
                e.engineRunning = !0,
                this
            },
            tickFrame: function(e) {
                var t, n, r, i, o = "ngraph" !== e.forceEngine;
                return e.engineRunning && function() {
                    ++e.cntTicks > e.cooldownTicks || new Date - e.startTickTime > e.cooldownTime || o && e.d3AlphaMin > 0 && e.d3ForceLayout.alpha() < e.d3AlphaMin ? (e.engineRunning = !1,
                    e.onEngineStop()) : (e.layout[o ? "tick" : "step"](),
                    e.onEngineTick());
                    e.graphData.nodes.forEach((function(t) {
                        var n = t.__threeObj;
                        if (n) {
                            var r = o ? t : e.layout.getNodePosition(t[e.nodeId]);
                            n.position.x = r.x,
                            n.position.y = r.y || 0,
                            n.position.z = r.z || 0
                        }
                    }
                    ));
                    var t = xc(e.linkWidth)
                      , n = xc(e.linkCurvature)
                      , r = xc(e.linkCurveRotation)
                      , i = xc(e.linkThreeObjectExtend);
                    function a(t) {
                        var i = o ? t : e.layout.getLinkPosition(e.layout.graph.getLink(t.source, t.target).id)
                          , a = i[o ? "source" : "from"]
                          , s = i[o ? "target" : "to"];
                        if (a && s && a.hasOwnProperty("x") && s.hasOwnProperty("x")) {
                            var c = n(t);
                            if (c) {
                                var l, u = new hl.Vector3(a.x,a.y || 0,a.z || 0), h = new hl.Vector3(s.x,s.y || 0,s.z || 0), d = u.distanceTo(h), p = r(t);
                                if (d > 0) {
                                    var f = s.x - a.x
                                      , m = s.y - a.y || 0
                                      , g = (new hl.Vector3).subVectors(h, u)
                                      , v = g.clone().multiplyScalar(c).cross(0 !== f || 0 !== m ? new hl.Vector3(0,0,1) : new hl.Vector3(0,1,0)).applyAxisAngle(g.normalize(), p).add((new hl.Vector3).addVectors(u, h).divideScalar(2));
                                    l = new hl.QuadraticBezierCurve3(u,v,h)
                                } else {
                                    var y = 70 * c
                                      , b = -p
                                      , x = b + Math.PI / 2;
                                    l = new hl.CubicBezierCurve3(u,new hl.Vector3(y * Math.cos(x),y * Math.sin(x),0).add(u),new hl.Vector3(y * Math.cos(b),y * Math.sin(b),0).add(u),h)
                                }
                                t.__curve = l
                            } else
                                t.__curve = null
                        }
                    }
                    e.graphData.links.forEach((function(n) {
                        var r = n.__lineObj;
                        if (r) {
                            var s = o ? n : e.layout.getLinkPosition(e.layout.graph.getLink(n.source, n.target).id)
                              , c = s[o ? "source" : "from"]
                              , l = s[o ? "target" : "to"];
                            if (c && l && c.hasOwnProperty("x") && l.hasOwnProperty("x")) {
                                a(n);
                                var u = i(n);
                                if (!e.linkPositionUpdate || !e.linkPositionUpdate(u ? r.children[1] : r, {
                                    start: {
                                        x: c.x,
                                        y: c.y,
                                        z: c.z
                                    },
                                    end: {
                                        x: l.x,
                                        y: l.y,
                                        z: l.z
                                    }
                                }, n) || u) {
                                    var h = 30
                                      , d = n.__curve
                                      , p = r.children.length ? r.children[0] : r;
                                    if ("Line" === p.type) {
                                        if (d)
                                            p.geometry.setFromPoints(d.getPoints(h));
                                        else {
                                            var f = p.geometry.getAttribute("position");
                                            f && f.array && 6 === f.array.length || p.geometry[pl]("position", f = new hl.BufferAttribute(new Float32Array(6),3)),
                                            f.array[0] = c.x,
                                            f.array[1] = c.y || 0,
                                            f.array[2] = c.z || 0,
                                            f.array[3] = l.x,
                                            f.array[4] = l.y || 0,
                                            f.array[5] = l.z || 0,
                                            f.needsUpdate = !0
                                        }
                                        p.geometry.computeBoundingSphere()
                                    } else if ("Mesh" === p.type)
                                        if (d) {
                                            p.geometry.type.match(/^Tube(Buffer)?Geometry$/) || (p.position.set(0, 0, 0),
                                            p.rotation.set(0, 0, 0),
                                            p.scale.set(1, 1, 1));
                                            var m = Math.ceil(10 * t(n)) / 10 / 2
                                              , g = new hl.TubeBufferGeometry(d,h,m,e.linkResolution,!1);
                                            p.geometry.dispose(),
                                            p.geometry = g
                                        } else {
                                            if (!p.geometry.type.match(/^Cylinder(Buffer)?Geometry$/)) {
                                                var v = Math.ceil(10 * t(n)) / 10 / 2
                                                  , y = new hl.CylinderBufferGeometry(v,v,1,e.linkResolution,1,!1);
                                                y[fl]((new hl.Matrix4).makeTranslation(0, .5, 0)),
                                                y[fl]((new hl.Matrix4).makeRotationX(Math.PI / 2)),
                                                p.geometry.dispose(),
                                                p.geometry = y
                                            }
                                            var b = new hl.Vector3(c.x,c.y || 0,c.z || 0)
                                              , x = new hl.Vector3(l.x,l.y || 0,l.z || 0)
                                              , _ = b.distanceTo(x);
                                            p.position.x = b.x,
                                            p.position.y = b.y,
                                            p.position.z = b.z,
                                            p.scale.z = _,
                                            p.parent.localToWorld(x),
                                            p.lookAt(x)
                                        }
                                }
                            }
                        }
                    }
                    ))
                }(),
                t = xc(e.linkDirectionalArrowRelPos),
                n = xc(e.linkDirectionalArrowLength),
                r = xc(e.nodeVal),
                e.graphData.links.forEach((function(i) {
                    var a = i.__arrowObj;
                    if (a) {
                        var s = o ? i : e.layout.getLinkPosition(e.layout.graph.getLink(i.source, i.target).id)
                          , c = s[o ? "source" : "from"]
                          , l = s[o ? "target" : "to"];
                        if (c && l && c.hasOwnProperty("x") && l.hasOwnProperty("x")) {
                            var u = Math.sqrt(Math.max(0, r(c) || 1)) * e.nodeRelSize
                              , h = Math.sqrt(Math.max(0, r(l) || 1)) * e.nodeRelSize
                              , d = n(i)
                              , p = t(i)
                              , f = i.__curve ? function(e) {
                                return i.__curve.getPoint(e)
                            }
                            : function(e) {
                                var t = function(e, t, n, r) {
                                    return t[e] + (n[e] - t[e]) * r || 0
                                };
                                return {
                                    x: t("x", c, l, e),
                                    y: t("y", c, l, e),
                                    z: t("z", c, l, e)
                                }
                            }
                              , m = i.__curve ? i.__curve.getLength() : Math.sqrt(["x", "y", "z"].map((function(e) {
                                return Math.pow((l[e] || 0) - (c[e] || 0), 2)
                            }
                            )).reduce((function(e, t) {
                                return e + t
                            }
                            ), 0))
                              , g = u + d + (m - u - h - d) * p
                              , v = f(g / m)
                              , y = f((g - d) / m);
                            ["x", "y", "z"].forEach((function(e) {
                                return a.position[e] = y[e]
                            }
                            ));
                            var b = Yc(hl.Vector3, el(["x", "y", "z"].map((function(e) {
                                return v[e]
                            }
                            ))));
                            a.parent.localToWorld(b),
                            a.lookAt(b)
                        }
                    }
                }
                )),
                i = xc(e.linkDirectionalParticleSpeed),
                e.graphData.links.forEach((function(t) {
                    var n = t.__photonsObj && t.__photonsObj.children
                      , r = t.__singleHopPhotonsObj && t.__singleHopPhotonsObj.children;
                    if (r && r.length || n && n.length) {
                        var a = o ? t : e.layout.getLinkPosition(e.layout.graph.getLink(t.source, t.target).id)
                          , s = a[o ? "source" : "from"]
                          , c = a[o ? "target" : "to"];
                        if (s && c && s.hasOwnProperty("x") && c.hasOwnProperty("x")) {
                            var l = i(t)
                              , u = t.__curve ? function(e) {
                                return t.__curve.getPoint(e)
                            }
                            : function(e) {
                                var t = function(e, t, n, r) {
                                    return t[e] + (n[e] - t[e]) * r || 0
                                };
                                return {
                                    x: t("x", s, c, e),
                                    y: t("y", s, c, e),
                                    z: t("z", s, c, e)
                                }
                            }
                            ;
                            [].concat(el(n || []), el(r || [])).forEach((function(e, t) {
                                var r = "singleHopPhotons" === e.parent.__linkThreeObjType;
                                if (e.hasOwnProperty("__progressRatio") || (e.__progressRatio = r ? 0 : t / n.length),
                                e.__progressRatio += l,
                                e.__progressRatio >= 1) {
                                    if (r)
                                        return e.parent.remove(e),
                                        void ol(e);
                                    e.__progressRatio = e.__progressRatio % 1
                                }
                                var i = e.__progressRatio
                                  , o = u(i);
                                ["x", "y", "z"].forEach((function(t) {
                                    return e.position[t] = o[t]
                                }
                                ))
                            }
                            ))
                        }
                    }
                }
                )),
                this
            },
            emitParticle: function(e, t) {
                if (t) {
                    if (!t.__singleHopPhotonsObj) {
                        var n = new hl.Group;
                        n.__linkThreeObjType = "singleHopPhotons",
                        t.__singleHopPhotonsObj = n,
                        e.graphScene.add(n)
                    }
                    var r = xc(e.linkDirectionalParticleWidth)
                      , i = Math.ceil(10 * r(t)) / 10 / 2
                      , o = e.linkDirectionalParticleResolution
                      , a = new hl.SphereBufferGeometry(i,o,o)
                      , s = xc(e.linkColor)
                      , c = xc(e.linkDirectionalParticleColor)(t) || s(t) || "#f0f0f0"
                      , l = new hl.Color(sl(c))
                      , u = 3 * e.linkOpacity
                      , h = new hl.MeshLambertMaterial({
                        color: l,
                        transparent: !0,
                        opacity: u
                    });
                    t.__singleHopPhotonsObj.add(new hl.Mesh(a,h))
                }
                return this
            },
            getGraphBbox: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function() {
                    return !0
                }
                ;
                if (!e.initialised)
                    return null;
                var n = function e(n) {
                    var r = [];
                    if (n.geometry) {
                        n.geometry.computeBoundingBox();
                        var i = new hl.Box3;
                        i.copy(n.geometry.boundingBox).applyMatrix4(n.matrixWorld),
                        r.push(i)
                    }
                    return r.concat.apply(r, el((n.children || []).filter((function(e) {
                        return !e.hasOwnProperty("__graphObjType") || "node" === e.__graphObjType && t(e.__data)
                    }
                    )).map(e)))
                }(e.graphScene);
                return n.length ? Object.assign.apply(Object, el(["x", "y", "z"].map((function(e) {
                    return Hc({}, e, [wc(n, (function(t) {
                        return t.min[e]
                    }
                    )), _c(n, (function(t) {
                        return t.max[e]
                    }
                    ))])
                }
                )))) : null
            }
        },
        stateInit: function() {
            return {
                d3ForceLayout: Cs().force("link", es()).force("charge", Rs()).force("center", Sa()).force("dagRadial", null).stop(),
                engineRunning: !1
            }
        },
        init: function(e, t) {
            t.graphScene = e
        },
        update: function(e, t) {
            var n = function(e) {
                return e.some((function(e) {
                    return t.hasOwnProperty(e)
                }
                ))
            };
            if (e.engineRunning = !1,
            e.onUpdate(),
            null !== e.nodeAutoColorBy && n(["nodeAutoColorBy", "graphData", "nodeColor"]) && ul(e.graphData.nodes, xc(e.nodeAutoColorBy), e.nodeColor),
            null !== e.linkAutoColorBy && n(["linkAutoColorBy", "graphData", "linkColor"]) && ul(e.graphData.links, xc(e.linkAutoColorBy), e.linkColor),
            e._flushObjects || n(["graphData", "nodeThreeObject", "nodeThreeObjectExtend", "nodeVal", "nodeColor", "nodeVisibility", "nodeRelSize", "nodeResolution", "nodeOpacity"])) {
                var r = xc(e.nodeThreeObject)
                  , i = xc(e.nodeThreeObjectExtend)
                  , o = xc(e.nodeVal)
                  , a = xc(e.nodeColor)
                  , s = xc(e.nodeVisibility)
                  , c = {}
                  , l = {};
                al(e.graphData.nodes.filter(s), e.graphScene, {
                    purge: e._flushObjects || n(["nodeThreeObject", "nodeThreeObjectExtend"]),
                    objFilter: function(e) {
                        return "node" === e.__graphObjType
                    },
                    createObj: function(t) {
                        var n, o = r(t), a = i(t);
                        return o && e.nodeThreeObject === o && (o = o.clone()),
                        o && !a ? n = o : ((n = new hl.Mesh).__graphDefaultObj = !0,
                        o && a && n.add(o)),
                        n.__graphObjType = "node",
                        n
                    },
                    updateObj: function(t, n) {
                        if (t.__graphDefaultObj) {
                            var r = o(n) || 1
                              , i = Math.cbrt(r) * e.nodeRelSize
                              , s = e.nodeResolution;
                            t.geometry.type.match(/^Sphere(Buffer)?Geometry$/) && t.geometry.parameters.radius === i && t.geometry.parameters.widthSegments === s || (c.hasOwnProperty(r) || (c[r] = new hl.SphereBufferGeometry(i,s,s)),
                            t.geometry.dispose(),
                            t.geometry = c[r]);
                            var u = a(n)
                              , h = new hl.Color(sl(u || "#ffffaa"))
                              , d = e.nodeOpacity * cl(u);
                            "MeshLambertMaterial" === t.material.type && t.material.color.equals(h) && t.material.opacity === d || (l.hasOwnProperty(u) || (l[u] = new hl.MeshLambertMaterial({
                                color: h,
                                transparent: !0,
                                opacity: d
                            })),
                            t.material.dispose(),
                            t.material = l[u])
                        }
                    }
                })
            }
            if (e._flushObjects || n(["graphData", "linkThreeObject", "linkThreeObjectExtend", "linkMaterial", "linkColor", "linkWidth", "linkVisibility", "linkResolution", "linkOpacity", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution"])) {
                var u = xc(e.linkThreeObject)
                  , h = xc(e.linkThreeObjectExtend)
                  , d = xc(e.linkMaterial)
                  , p = xc(e.linkVisibility)
                  , f = xc(e.linkColor)
                  , m = xc(e.linkWidth)
                  , g = {}
                  , v = {}
                  , y = {}
                  , b = e.graphData.links.filter(p);
                if (al(b, e.graphScene, {
                    objBindAttr: "__lineObj",
                    purge: e._flushObjects || n(["linkThreeObject", "linkThreeObjectExtend", "linkWidth"]),
                    objFilter: function(e) {
                        return "link" === e.__graphObjType
                    },
                    createObj: function(t) {
                        var n, r, i = u(t), o = h(t);
                        if (i && e.linkThreeObject === i && (i = i.clone()),
                        !i || o)
                            if (!!m(t))
                                n = new hl.Mesh;
                            else {
                                var a = new hl.BufferGeometry;
                                a[pl]("position", new hl.BufferAttribute(new Float32Array(6),3)),
                                n = new hl.Line(a)
                            }
                        return i ? o ? ((r = new hl.Group).__graphDefaultObj = !0,
                        r.add(n),
                        r.add(i)) : r = i : (r = n).__graphDefaultObj = !0,
                        r.renderOrder = 10,
                        r.__graphObjType = "link",
                        r
                    },
                    updateObj: function(t, n) {
                        if (t.__graphDefaultObj) {
                            var r = t.children.length ? t.children[0] : t
                              , i = Math.ceil(10 * m(n)) / 10
                              , o = !!i;
                            if (o) {
                                var a = i / 2
                                  , s = e.linkResolution;
                                if (!r.geometry.type.match(/^Cylinder(Buffer)?Geometry$/) || r.geometry.parameters.radiusTop !== a || r.geometry.parameters.radialSegments !== s) {
                                    if (!g.hasOwnProperty(i)) {
                                        var c = new hl.CylinderBufferGeometry(a,a,1,s,1,!1);
                                        c[fl]((new hl.Matrix4).makeTranslation(0, .5, 0)),
                                        c[fl]((new hl.Matrix4).makeRotationX(Math.PI / 2)),
                                        g[i] = c
                                    }
                                    r.geometry.dispose(),
                                    r.geometry = g[i]
                                }
                            }
                            var l = d(n);
                            if (l)
                                r.material = l;
                            else {
                                var u = f(n)
                                  , h = new hl.Color(sl(u || "#f0f0f0"))
                                  , p = e.linkOpacity * cl(u)
                                  , b = o ? "MeshLambertMaterial" : "LineBasicMaterial";
                                if (r.material.type !== b || !r.material.color.equals(h) || r.material.opacity !== p) {
                                    var x = o ? v : y;
                                    x.hasOwnProperty(u) || (x[u] = new hl[b]({
                                        color: h,
                                        transparent: p < 1,
                                        opacity: p,
                                        depthWrite: p >= 1
                                    })),
                                    r.material.dispose(),
                                    r.material = x[u]
                                }
                            }
                        }
                    }
                }),
                e.linkDirectionalArrowLength || t.hasOwnProperty("linkDirectionalArrowLength")) {
                    var x = xc(e.linkDirectionalArrowLength)
                      , _ = xc(e.linkDirectionalArrowColor);
                    al(b.filter(x), e.graphScene, {
                        objBindAttr: "__arrowObj",
                        objFilter: function(e) {
                            return "arrow" === e.__linkThreeObjType
                        },
                        createObj: function() {
                            var e = new hl.Mesh(void 0,new hl.MeshLambertMaterial({
                                transparent: !0
                            }));
                            return e.__linkThreeObjType = "arrow",
                            e
                        },
                        updateObj: function(t, n) {
                            var r = x(n)
                              , i = e.linkDirectionalArrowResolution;
                            if (!t.geometry.type.match(/^Cone(Buffer)?Geometry$/) || t.geometry.parameters.height !== r || t.geometry.parameters.radialSegments !== i) {
                                var o = new hl.ConeBufferGeometry(.25 * r,r,i);
                                o.translate(0, r / 2, 0),
                                o.rotateX(Math.PI / 2),
                                t.geometry.dispose(),
                                t.geometry = o
                            }
                            t.material.color = new hl.Color(_(n) || f(n) || "#f0f0f0"),
                            t.material.opacity = 3 * e.linkOpacity
                        }
                    })
                }
                if (e.linkDirectionalParticles || t.hasOwnProperty("linkDirectionalParticles")) {
                    var w = xc(e.linkDirectionalParticles)
                      , M = xc(e.linkDirectionalParticleWidth)
                      , E = xc(e.linkDirectionalParticleColor)
                      , S = {}
                      , T = {};
                    al(b.filter(w), e.graphScene, {
                        objBindAttr: "__photonsObj",
                        objFilter: function(e) {
                            return "photons" === e.__linkThreeObjType
                        },
                        createObj: function() {
                            var e = new hl.Group;
                            return e.__linkThreeObjType = "photons",
                            e
                        },
                        updateObj: function(t, n) {
                            var r, i = Math.round(Math.abs(w(n))), o = !!t.children.length && t.children[0], a = Math.ceil(10 * M(n)) / 10 / 2, s = e.linkDirectionalParticleResolution;
                            o && o.geometry.parameters.radius === a && o.geometry.parameters.widthSegments === s ? r = o.geometry : (T.hasOwnProperty(a) || (T[a] = new hl.SphereBufferGeometry(a,s,s)),
                            r = T[a],
                            o && o.geometry.dispose());
                            var c, l = E(n) || f(n) || "#f0f0f0", u = new hl.Color(sl(l)), h = 3 * e.linkOpacity;
                            o && o.material.color.equals(u) && o.material.opacity === h ? c = o.material : (S.hasOwnProperty(l) || (S[l] = new hl.MeshLambertMaterial({
                                color: u,
                                transparent: !0,
                                opacity: h
                            })),
                            c = S[l],
                            o && o.material.dispose()),
                            al(el(new Array(i)).map((function(e, t) {
                                return {
                                    idx: t
                                }
                            }
                            )), t, {
                                idAccessor: function(e) {
                                    return e.idx
                                },
                                createObj: function() {
                                    return new hl.Mesh(r,c)
                                },
                                updateObj: function(e) {
                                    e.geometry = r,
                                    e.material = c
                                }
                            })
                        }
                    })
                }
            }
            if (e._flushObjects = !1,
            n(["graphData", "nodeId", "linkSource", "linkTarget", "numDimensions", "forceEngine", "dagMode", "dagNodeFilter", "dagLevelDistance"])) {
                e.engineRunning = !1,
                e.graphData.links.forEach((function(t) {
                    t.source = t[e.linkSource],
                    t.target = t[e.linkTarget]
                }
                ));
                var L, A = "ngraph" !== e.forceEngine;
                if (A) {
                    (L = e.d3ForceLayout).stop().alpha(1).numDimensions(e.numDimensions).nodes(e.graphData.nodes);
                    var P = e.d3ForceLayout.force("link");
                    P && P.id((function(t) {
                        return t[e.nodeId]
                    }
                    )).links(e.graphData.links);
                    var C = e.dagMode && function(e, t) {
                        var n = e.nodes
                          , r = e.links
                          , i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
                          , o = i.nodeFilter
                          , a = void 0 === o ? function() {
                            return !0
                        }
                        : o
                          , s = i.onLoopError
                          , c = void 0 === s ? function(e) {
                            throw "Invalid DAG structure! Found cycle in node path: ".concat(e.join(" -> "), ".")
                        }
                        : s
                          , l = {};
                        n.forEach((function(e) {
                            return l[t(e)] = {
                                data: e,
                                out: [],
                                depth: -1,
                                skip: !a(e)
                            }
                        }
                        )),
                        r.forEach((function(e) {
                            var n = e.source
                              , r = e.target
                              , i = c(n)
                              , o = c(r);
                            if (!l.hasOwnProperty(i))
                                throw "Missing source node with id: ".concat(i);
                            if (!l.hasOwnProperty(o))
                                throw "Missing target node with id: ".concat(o);
                            var a = l[i]
                              , s = l[o];
                            function c(e) {
                                return "object" === Bc(e) ? t(e) : e
                            }
                            a.out.push(s)
                        }
                        ));
                        var u = [];
                        return h(Object.values(l)),
                        Object.assign.apply(Object, [{}].concat(el(Object.entries(l).filter((function(e) {
                            return !Kc(e, 2)[1].skip
                        }
                        )).map((function(e) {
                            var t = Kc(e, 2);
                            return Hc({}, t[0], t[1].depth)
                        }
                        )))));
                        function h(e) {
                            for (var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, i = 0, o = e.length; i < o; i++) {
                                var a = e[i];
                                if (-1 !== n.indexOf(a))
                                    if ("continue" === function() {
                                        var e = [].concat(el(n.slice(n.indexOf(a))), [a]).map((function(e) {
                                            return t(e.data)
                                        }
                                        ));
                                        return u.some((function(t) {
                                            return t.length === e.length && t.every((function(t, n) {
                                                return t === e[n]
                                            }
                                            ))
                                        }
                                        )) || (u.push(e),
                                        c(e)),
                                        "continue"
                                    }())
                                        continue;
                                r > a.depth && (a.depth = r,
                                h(a.out, [].concat(el(n), [a]), r + (a.skip ? 0 : 1)))
                            }
                        }
                    }(e.graphData, (function(t) {
                        return t[e.nodeId]
                    }
                    ), {
                        nodeFilter: e.dagNodeFilter,
                        onLoopError: e.onDagError || void 0
                    })
                      , R = Math.max.apply(Math, el(Object.values(C || [])))
                      , D = e.dagLevelDistance || e.graphData.nodes.length / (R || 1) * 2 * (-1 !== ["radialin", "radialout"].indexOf(e.dagMode) ? .7 : 1);
                    if (e.dagMode) {
                        var O = function(t, n) {
                            return function(r) {
                                return t ? (C[r[e.nodeId]] - R / 2) * D * (n ? -1 : 1) : void 0
                            }
                        }
                          , N = O(-1 !== ["lr", "rl"].indexOf(e.dagMode), "rl" === e.dagMode)
                          , I = O(-1 !== ["td", "bu"].indexOf(e.dagMode), "td" === e.dagMode)
                          , k = O(-1 !== ["zin", "zout"].indexOf(e.dagMode), "zout" === e.dagMode);
                        e.graphData.nodes.filter(e.dagNodeFilter).forEach((function(e) {
                            e.fx = N(e),
                            e.fy = I(e),
                            e.fz = k(e)
                        }
                        ))
                    }
                    e.d3ForceLayout.force("dagRadial", -1 !== ["radialin", "radialout"].indexOf(e.dagMode) ? function(e, t, n, r) {
                        var i, o, a, s, c = $a(.1);
                        function l(e) {
                            for (var c = 0, l = i.length; c < l; ++c) {
                                var u = i[c]
                                  , h = u.x - t || 1e-6
                                  , d = (u.y || 0) - n || 1e-6
                                  , p = (u.z || 0) - r || 1e-6
                                  , f = Math.sqrt(h * h + d * d + p * p)
                                  , m = (s[c] - f) * a[c] * e / f;
                                u.vx += h * m,
                                o > 1 && (u.vy += d * m),
                                o > 2 && (u.vz += p * m)
                            }
                        }
                        function u() {
                            if (i) {
                                var t, n = i.length;
                                for (a = new Array(n),
                                s = new Array(n),
                                t = 0; t < n; ++t)
                                    s[t] = +e(i[t], t, i),
                                    a[t] = isNaN(s[t]) ? 0 : +c(i[t], t, i)
                            }
                        }
                        return "function" != typeof e && (e = $a(+e)),
                        null == t && (t = 0),
                        null == n && (n = 0),
                        null == r && (r = 0),
                        l.initialize = function(e, ...t) {
                            i = e,
                            o = t.find((e=>[1, 2, 3].includes(e))) || 2,
                            u()
                        }
                        ,
                        l.strength = function(e) {
                            return arguments.length ? (c = "function" == typeof e ? e : $a(+e),
                            u(),
                            l) : c
                        }
                        ,
                        l.radius = function(t) {
                            return arguments.length ? (e = "function" == typeof t ? t : $a(+t),
                            u(),
                            l) : e
                        }
                        ,
                        l.x = function(e) {
                            return arguments.length ? (t = +e,
                            l) : t
                        }
                        ,
                        l.y = function(e) {
                            return arguments.length ? (n = +e,
                            l) : n
                        }
                        ,
                        l.z = function(e) {
                            return arguments.length ? (r = +e,
                            l) : r
                        }
                        ,
                        l
                    }((function(t) {
                        var n = C[t[e.nodeId]] || -1;
                        return ("radialin" === e.dagMode ? R - n : n) * D
                    }
                    )).strength((function(t) {
                        return e.dagNodeFilter(t) ? 1 : 0
                    }
                    )) : null)
                } else {
                    var z = dl.graph();
                    e.graphData.nodes.forEach((function(t) {
                        z.addNode(t[e.nodeId])
                    }
                    )),
                    e.graphData.links.forEach((function(e) {
                        z.addLink(e.source, e.target)
                    }
                    )),
                    (L = dl.forcelayout(z, Gc({
                        dimensions: e.numDimensions
                    }, e.ngraphPhysics))).graph = z
                }
                for (var F = 0; F < e.warmupTicks && !(A && e.d3AlphaMin > 0 && e.d3ForceLayout.alpha() < e.d3AlphaMin); F++)
                    L[A ? "tick" : "step"]();
                e.layout = L,
                this.resetCountdown()
            }
            e.engineRunning = !0,
            e.onFinishUpdate()
        }
    }), (window.THREE ? window.THREE : {
        Group: Di
    }).Group, !0)
      , gl = function(e, t) {
        void 0 === t && console.warn('THREE.TrackballControls: The second parameter "domElement" is now mandatory.'),
        t === document && console.error('THREE.TrackballControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
        var n = this
          , r = -1
          , i = 0
          , a = 1
          , s = 2
          , c = 3
          , l = 4;
        this.object = e,
        this.domElement = t,
        this.enabled = !0,
        this.screen = {
            left: 0,
            top: 0,
            width: 0,
            height: 0
        },
        this.rotateSpeed = 1,
        this.zoomSpeed = 1.2,
        this.panSpeed = .3,
        this.noRotate = !1,
        this.noZoom = !1,
        this.noPan = !1,
        this.staticMoving = !1,
        this.dynamicDampingFactor = .2,
        this.minDistance = 0,
        this.maxDistance = 1 / 0,
        this.keys = ["KeyA", "KeyS", "KeyD"],
        this.mouseButtons = {
            LEFT: o.ROTATE,
            MIDDLE: o.DOLLY,
            RIGHT: o.PAN
        },
        this.target = new q;
        var u = 1e-6
          , h = new q
          , d = 1
          , p = r
          , f = r
          , m = new q
          , g = new k
          , v = new k
          , y = new q
          , b = 0
          , x = new k
          , _ = new k
          , w = 0
          , M = 0
          , E = new k
          , S = new k;
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.up0 = this.object.up.clone(),
        this.zoom0 = this.object.zoom;
        var T = {
            type: "change"
        }
          , L = {
            type: "start"
        }
          , A = {
            type: "end"
        };
        this.handleResize = function() {
            var e = n.domElement.getBoundingClientRect()
              , t = n.domElement.ownerDocument.documentElement;
            n.screen.left = e.left + window.pageXOffset - t.clientLeft,
            n.screen.top = e.top + window.pageYOffset - t.clientTop,
            n.screen.width = e.width,
            n.screen.height = e.height
        }
        ;
        var P, C, R, D, O, N, I, z, F, B, U, H = (P = new k,
        function(e, t) {
            return P.set((e - n.screen.left) / n.screen.width, (t - n.screen.top) / n.screen.height),
            P
        }
        ), j = function() {
            var e = new k;
            return function(t, r) {
                return e.set((t - .5 * n.screen.width - n.screen.left) / (.5 * n.screen.width), (n.screen.height + 2 * (n.screen.top - r)) / n.screen.width),
                e
            }
        }();
        function G(e) {
            if (!1 !== n.enabled)
                switch (e.pointerType) {
                case "mouse":
                case "pen":
                    !function(e) {
                        if (e.preventDefault(),
                        p === r)
                            switch (e.button) {
                            case n.mouseButtons.LEFT:
                                p = i;
                                break;
                            case n.mouseButtons.MIDDLE:
                                p = a;
                                break;
                            case n.mouseButtons.RIGHT:
                                p = s;
                                break;
                            default:
                                p = r
                            }
                        var t = f !== r ? f : p;
                        t !== i || n.noRotate ? t !== a || n.noZoom ? t !== s || n.noPan || (E.copy(H(e.pageX, e.pageY)),
                        S.copy(E)) : (x.copy(H(e.pageX, e.pageY)),
                        _.copy(x)) : (v.copy(j(e.pageX, e.pageY)),
                        g.copy(v));
                        n.domElement.ownerDocument.addEventListener("pointermove", V),
                        n.domElement.ownerDocument.addEventListener("pointerup", X),
                        n.dispatchEvent(L)
                    }(e)
                }
        }
        function V(e) {
            if (!1 !== n.enabled)
                switch (e.pointerType) {
                case "mouse":
                case "pen":
                    !function(e) {
                        if (!1 === n.enabled)
                            return;
                        e.preventDefault();
                        var t = f !== r ? f : p;
                        t !== i || n.noRotate ? t !== a || n.noZoom ? t !== s || n.noPan || S.copy(H(e.pageX, e.pageY)) : _.copy(H(e.pageX, e.pageY)) : (g.copy(v),
                        v.copy(j(e.pageX, e.pageY)))
                    }(e)
                }
        }
        function X(e) {
            if (!1 !== n.enabled)
                switch (e.pointerType) {
                case "mouse":
                case "pen":
                    !function(e) {
                        if (!1 === n.enabled)
                            return;
                        e.preventDefault(),
                        p = r,
                        n.domElement.ownerDocument.removeEventListener("pointermove", V),
                        n.domElement.ownerDocument.removeEventListener("pointerup", X),
                        n.dispatchEvent(A)
                    }(e)
                }
        }
        function Y(e) {
            !1 !== n.enabled && (window.removeEventListener("keydown", Y),
            f === r && (e.code !== n.keys[i] || n.noRotate ? e.code !== n.keys[a] || n.noZoom ? e.code !== n.keys[s] || n.noPan || (f = s) : f = a : f = i))
        }
        function Z() {
            !1 !== n.enabled && (f = r,
            window.addEventListener("keydown", Y))
        }
        function $(e) {
            if (!1 !== n.enabled && !0 !== n.noZoom) {
                switch (e.preventDefault(),
                e.deltaMode) {
                case 2:
                    x.y -= .025 * e.deltaY;
                    break;
                case 1:
                    x.y -= .01 * e.deltaY;
                    break;
                default:
                    x.y -= 25e-5 * e.deltaY
                }
                n.dispatchEvent(L),
                n.dispatchEvent(A)
            }
        }
        function J(e) {
            if (!1 !== n.enabled) {
                switch (e.preventDefault(),
                e.touches.length) {
                case 1:
                    p = c,
                    v.copy(j(e.touches[0].pageX, e.touches[0].pageY)),
                    g.copy(v);
                    break;
                default:
                    p = l;
                    var t = e.touches[0].pageX - e.touches[1].pageX
                      , r = e.touches[0].pageY - e.touches[1].pageY;
                    M = w = Math.sqrt(t * t + r * r);
                    var i = (e.touches[0].pageX + e.touches[1].pageX) / 2
                      , o = (e.touches[0].pageY + e.touches[1].pageY) / 2;
                    E.copy(H(i, o)),
                    S.copy(E)
                }
                n.dispatchEvent(L)
            }
        }
        function Q(e) {
            if (!1 !== n.enabled)
                switch (e.preventDefault(),
                e.touches.length) {
                case 1:
                    g.copy(v),
                    v.copy(j(e.touches[0].pageX, e.touches[0].pageY));
                    break;
                default:
                    var t = e.touches[0].pageX - e.touches[1].pageX
                      , r = e.touches[0].pageY - e.touches[1].pageY;
                    M = Math.sqrt(t * t + r * r);
                    var i = (e.touches[0].pageX + e.touches[1].pageX) / 2
                      , o = (e.touches[0].pageY + e.touches[1].pageY) / 2;
                    S.copy(H(i, o))
                }
        }
        function K(e) {
            if (!1 !== n.enabled) {
                switch (e.touches.length) {
                case 0:
                    p = r;
                    break;
                case 1:
                    p = c,
                    v.copy(j(e.touches[0].pageX, e.touches[0].pageY)),
                    g.copy(v)
                }
                n.dispatchEvent(A)
            }
        }
        function ee(e) {
            !1 !== n.enabled && e.preventDefault()
        }
        this.rotateCamera = (R = new q,
        D = new W,
        O = new q,
        N = new q,
        I = new q,
        z = new q,
        function() {
            z.set(v.x - g.x, v.y - g.y, 0),
            (C = z.length()) ? (m.copy(n.object.position).sub(n.target),
            O.copy(m).normalize(),
            N.copy(n.object.up).normalize(),
            I.crossVectors(N, O).normalize(),
            N.setLength(v.y - g.y),
            I.setLength(v.x - g.x),
            z.copy(N.add(I)),
            R.crossVectors(z, m).normalize(),
            C *= n.rotateSpeed,
            D.setFromAxisAngle(R, C),
            m.applyQuaternion(D),
            n.object.up.applyQuaternion(D),
            y.copy(R),
            b = C) : !n.staticMoving && b && (b *= Math.sqrt(1 - n.dynamicDampingFactor),
            m.copy(n.object.position).sub(n.target),
            D.setFromAxisAngle(y, b),
            m.applyQuaternion(D),
            n.object.up.applyQuaternion(D)),
            g.copy(v)
        }
        ),
        this.zoomCamera = function() {
            var e;
            p === l ? (e = w / M,
            w = M,
            n.object.isPerspectiveCamera ? m.multiplyScalar(e) : n.object.isOrthographicCamera ? (n.object.zoom *= e,
            n.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")) : (1 !== (e = 1 + (_.y - x.y) * n.zoomSpeed) && e > 0 && (n.object.isPerspectiveCamera ? m.multiplyScalar(e) : n.object.isOrthographicCamera ? (n.object.zoom /= e,
            n.object.updateProjectionMatrix()) : console.warn("THREE.TrackballControls: Unsupported camera type")),
            n.staticMoving ? x.copy(_) : x.y += (_.y - x.y) * this.dynamicDampingFactor)
        }
        ,
        this.panCamera = (F = new k,
        B = new q,
        U = new q,
        function() {
            if (F.copy(S).sub(E),
            F.lengthSq()) {
                if (n.object.isOrthographicCamera) {
                    var e = (n.object.right - n.object.left) / n.object.zoom / n.domElement.clientWidth
                      , t = (n.object.top - n.object.bottom) / n.object.zoom / n.domElement.clientWidth;
                    F.x *= e,
                    F.y *= t
                }
                F.multiplyScalar(m.length() * n.panSpeed),
                U.copy(m).cross(n.object.up).setLength(F.x),
                U.add(B.copy(n.object.up).setLength(F.y)),
                n.object.position.add(U),
                n.target.add(U),
                n.staticMoving ? E.copy(S) : E.add(F.subVectors(S, E).multiplyScalar(n.dynamicDampingFactor))
            }
        }
        ),
        this.checkDistances = function() {
            n.noZoom && n.noPan || (m.lengthSq() > n.maxDistance * n.maxDistance && (n.object.position.addVectors(n.target, m.setLength(n.maxDistance)),
            x.copy(_)),
            m.lengthSq() < n.minDistance * n.minDistance && (n.object.position.addVectors(n.target, m.setLength(n.minDistance)),
            x.copy(_)))
        }
        ,
        this.update = function() {
            m.subVectors(n.object.position, n.target),
            n.noRotate || n.rotateCamera(),
            n.noZoom || n.zoomCamera(),
            n.noPan || n.panCamera(),
            n.object.position.addVectors(n.target, m),
            n.object.isPerspectiveCamera ? (n.checkDistances(),
            n.object.lookAt(n.target),
            h.distanceToSquared(n.object.position) > u && (n.dispatchEvent(T),
            h.copy(n.object.position))) : n.object.isOrthographicCamera ? (n.object.lookAt(n.target),
            (h.distanceToSquared(n.object.position) > u || d !== n.object.zoom) && (n.dispatchEvent(T),
            h.copy(n.object.position),
            d = n.object.zoom)) : console.warn("THREE.TrackballControls: Unsupported camera type")
        }
        ,
        this.reset = function() {
            p = r,
            f = r,
            n.target.copy(n.target0),
            n.object.position.copy(n.position0),
            n.object.up.copy(n.up0),
            n.object.zoom = n.zoom0,
            n.object.updateProjectionMatrix(),
            m.subVectors(n.object.position, n.target),
            n.object.lookAt(n.target),
            n.dispatchEvent(T),
            h.copy(n.object.position),
            d = n.object.zoom
        }
        ,
        this.dispose = function() {
            n.domElement.removeEventListener("contextmenu", ee),
            n.domElement.removeEventListener("pointerdown", G),
            n.domElement.removeEventListener("wheel", $),
            n.domElement.removeEventListener("touchstart", J),
            n.domElement.removeEventListener("touchend", K),
            n.domElement.removeEventListener("touchmove", Q),
            n.domElement.ownerDocument.removeEventListener("pointermove", V),
            n.domElement.ownerDocument.removeEventListener("pointerup", X),
            window.removeEventListener("keydown", Y),
            window.removeEventListener("keyup", Z)
        }
        ,
        this.domElement.addEventListener("contextmenu", ee),
        this.domElement.addEventListener("pointerdown", G),
        this.domElement.addEventListener("wheel", $),
        this.domElement.addEventListener("touchstart", J),
        this.domElement.addEventListener("touchend", K),
        this.domElement.addEventListener("touchmove", Q),
        this.domElement.ownerDocument.addEventListener("pointermove", V),
        this.domElement.ownerDocument.addEventListener("pointerup", X),
        window.addEventListener("keydown", Y),
        window.addEventListener("keyup", Z),
        this.handleResize(),
        this.update()
    };
    gl.prototype = Object.create(D.prototype),
    gl.prototype.constructor = gl;
    var vl = function(e, t) {
        var n, r, i, u, h, d;
        void 0 === t && console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),
        t === document && console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),
        this.object = e,
        this.domElement = t,
        this.enabled = !0,
        this.target = new q,
        this.minDistance = 0,
        this.maxDistance = 1 / 0,
        this.minZoom = 0,
        this.maxZoom = 1 / 0,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -1 / 0,
        this.maxAzimuthAngle = 1 / 0,
        this.enableDamping = !1,
        this.dampingFactor = .05,
        this.enableZoom = !0,
        this.zoomSpeed = 1,
        this.enableRotate = !0,
        this.rotateSpeed = 1,
        this.enablePan = !0,
        this.panSpeed = 1,
        this.screenSpacePanning = !0,
        this.keyPanSpeed = 7,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        },
        this.mouseButtons = {
            LEFT: o.ROTATE,
            MIDDLE: o.DOLLY,
            RIGHT: o.PAN
        },
        this.touches = {
            ONE: a,
            TWO: c
        },
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom,
        this._domElementKeyEvents = null,
        this.getPolarAngle = function() {
            return x.phi
        }
        ,
        this.getAzimuthalAngle = function() {
            return x.theta
        }
        ,
        this.listenToKeyEvents = function(e) {
            e.addEventListener("keydown", ie),
            this._domElementKeyEvents = e
        }
        ,
        this.saveState = function() {
            p.target0.copy(p.target),
            p.position0.copy(p.object.position),
            p.zoom0 = p.object.zoom
        }
        ,
        this.reset = function() {
            p.target.copy(p.target0),
            p.object.position.copy(p.position0),
            p.object.zoom = p.zoom0,
            p.object.updateProjectionMatrix(),
            p.dispatchEvent(f),
            p.update(),
            y = v.NONE
        }
        ,
        this.update = (n = new q,
        r = (new W).setFromUnitVectors(e.up, new q(0,1,0)),
        i = r.clone().invert(),
        u = new q,
        h = new W,
        d = 2 * Math.PI,
        function() {
            var e = p.object.position;
            n.copy(e).sub(p.target),
            n.applyQuaternion(r),
            x.setFromVector3(n),
            p.autoRotate && y === v.NONE && I(2 * Math.PI / 60 / 60 * p.autoRotateSpeed),
            p.enableDamping ? (x.theta += _.theta * p.dampingFactor,
            x.phi += _.phi * p.dampingFactor) : (x.theta += _.theta,
            x.phi += _.phi);
            var t = p.minAzimuthAngle
              , o = p.maxAzimuthAngle;
            return isFinite(t) && isFinite(o) && (t < -Math.PI ? t += d : t > Math.PI && (t -= d),
            o < -Math.PI ? o += d : o > Math.PI && (o -= d),
            x.theta = t <= o ? Math.max(t, Math.min(o, x.theta)) : x.theta > (t + o) / 2 ? Math.max(t, x.theta) : Math.min(o, x.theta)),
            x.phi = Math.max(p.minPolarAngle, Math.min(p.maxPolarAngle, x.phi)),
            x.makeSafe(),
            x.radius *= w,
            x.radius = Math.max(p.minDistance, Math.min(p.maxDistance, x.radius)),
            !0 === p.enableDamping ? p.target.addScaledVector(M, p.dampingFactor) : p.target.add(M),
            n.setFromSpherical(x),
            n.applyQuaternion(i),
            e.copy(p.target).add(n),
            p.object.lookAt(p.target),
            !0 === p.enableDamping ? (_.theta *= 1 - p.dampingFactor,
            _.phi *= 1 - p.dampingFactor,
            M.multiplyScalar(1 - p.dampingFactor)) : (_.set(0, 0, 0),
            M.set(0, 0, 0)),
            w = 1,
            !!(E || u.distanceToSquared(p.object.position) > b || 8 * (1 - h.dot(p.object.quaternion)) > b) && (p.dispatchEvent(f),
            u.copy(p.object.position),
            h.copy(p.object.quaternion),
            E = !1,
            !0)
        }
        ),
        this.dispose = function() {
            p.domElement.removeEventListener("contextmenu", ce),
            p.domElement.removeEventListener("pointerdown", ee),
            p.domElement.removeEventListener("wheel", re),
            p.domElement.removeEventListener("touchstart", oe),
            p.domElement.removeEventListener("touchend", se),
            p.domElement.removeEventListener("touchmove", ae),
            p.domElement.ownerDocument.removeEventListener("pointermove", te),
            p.domElement.ownerDocument.removeEventListener("pointerup", ne),
            null !== p._domElementKeyEvents && p._domElementKeyEvents.removeEventListener("keydown", ie)
        }
        ;
        var p = this
          , f = {
            type: "change"
        }
          , m = {
            type: "start"
        }
          , g = {
            type: "end"
        }
          , v = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_PAN: 4,
            TOUCH_DOLLY_PAN: 5,
            TOUCH_DOLLY_ROTATE: 6
        }
          , y = v.NONE
          , b = 1e-6
          , x = new _a
          , _ = new _a
          , w = 1
          , M = new q
          , E = !1
          , S = new k
          , T = new k
          , L = new k
          , A = new k
          , P = new k
          , C = new k
          , R = new k
          , D = new k
          , O = new k;
        function N() {
            return Math.pow(.95, p.zoomSpeed)
        }
        function I(e) {
            _.theta -= e
        }
        function z(e) {
            _.phi -= e
        }
        var F, B = (F = new q,
        function(e, t) {
            F.setFromMatrixColumn(t, 0),
            F.multiplyScalar(-e),
            M.add(F)
        }
        ), U = function() {
            var e = new q;
            return function(t, n) {
                !0 === p.screenSpacePanning ? e.setFromMatrixColumn(n, 1) : (e.setFromMatrixColumn(n, 0),
                e.crossVectors(p.object.up, e)),
                e.multiplyScalar(t),
                M.add(e)
            }
        }(), H = function() {
            var e = new q;
            return function(t, n) {
                var r = p.domElement;
                if (p.object.isPerspectiveCamera) {
                    var i = p.object.position;
                    e.copy(i).sub(p.target);
                    var o = e.length();
                    o *= Math.tan(p.object.fov / 2 * Math.PI / 180),
                    B(2 * t * o / r.clientHeight, p.object.matrix),
                    U(2 * n * o / r.clientHeight, p.object.matrix)
                } else
                    p.object.isOrthographicCamera ? (B(t * (p.object.right - p.object.left) / p.object.zoom / r.clientWidth, p.object.matrix),
                    U(n * (p.object.top - p.object.bottom) / p.object.zoom / r.clientHeight, p.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
                    p.enablePan = !1)
            }
        }();
        function j(e) {
            p.object.isPerspectiveCamera ? w /= e : p.object.isOrthographicCamera ? (p.object.zoom = Math.max(p.minZoom, Math.min(p.maxZoom, p.object.zoom * e)),
            p.object.updateProjectionMatrix(),
            E = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            p.enableZoom = !1)
        }
        function G(e) {
            p.object.isPerspectiveCamera ? w *= e : p.object.isOrthographicCamera ? (p.object.zoom = Math.max(p.minZoom, Math.min(p.maxZoom, p.object.zoom / e)),
            p.object.updateProjectionMatrix(),
            E = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
            p.enableZoom = !1)
        }
        function V(e) {
            S.set(e.clientX, e.clientY)
        }
        function X(e) {
            A.set(e.clientX, e.clientY)
        }
        function Y(e) {
            if (1 == e.touches.length)
                S.set(e.touches[0].pageX, e.touches[0].pageY);
            else {
                var t = .5 * (e.touches[0].pageX + e.touches[1].pageX)
                  , n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                S.set(t, n)
            }
        }
        function Z(e) {
            if (1 == e.touches.length)
                A.set(e.touches[0].pageX, e.touches[0].pageY);
            else {
                var t = .5 * (e.touches[0].pageX + e.touches[1].pageX)
                  , n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                A.set(t, n)
            }
        }
        function $(e) {
            var t = e.touches[0].pageX - e.touches[1].pageX
              , n = e.touches[0].pageY - e.touches[1].pageY
              , r = Math.sqrt(t * t + n * n);
            R.set(0, r)
        }
        function J(e) {
            if (1 == e.touches.length)
                T.set(e.touches[0].pageX, e.touches[0].pageY);
            else {
                var t = .5 * (e.touches[0].pageX + e.touches[1].pageX)
                  , n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                T.set(t, n)
            }
            L.subVectors(T, S).multiplyScalar(p.rotateSpeed);
            var r = p.domElement;
            I(2 * Math.PI * L.x / r.clientHeight),
            z(2 * Math.PI * L.y / r.clientHeight),
            S.copy(T)
        }
        function Q(e) {
            if (1 == e.touches.length)
                P.set(e.touches[0].pageX, e.touches[0].pageY);
            else {
                var t = .5 * (e.touches[0].pageX + e.touches[1].pageX)
                  , n = .5 * (e.touches[0].pageY + e.touches[1].pageY);
                P.set(t, n)
            }
            C.subVectors(P, A).multiplyScalar(p.panSpeed),
            H(C.x, C.y),
            A.copy(P)
        }
        function K(e) {
            var t = e.touches[0].pageX - e.touches[1].pageX
              , n = e.touches[0].pageY - e.touches[1].pageY
              , r = Math.sqrt(t * t + n * n);
            D.set(0, r),
            O.set(0, Math.pow(D.y / R.y, p.zoomSpeed)),
            j(O.y),
            R.copy(D)
        }
        function ee(e) {
            if (!1 !== p.enabled)
                switch (e.pointerType) {
                case "mouse":
                case "pen":
                    !function(e) {
                        var t;
                        switch (e.preventDefault(),
                        p.domElement.focus ? p.domElement.focus() : window.focus(),
                        e.button) {
                        case 0:
                            t = p.mouseButtons.LEFT;
                            break;
                        case 1:
                            t = p.mouseButtons.MIDDLE;
                            break;
                        case 2:
                            t = p.mouseButtons.RIGHT;
                            break;
                        default:
                            t = -1
                        }
                        switch (t) {
                        case o.DOLLY:
                            if (!1 === p.enableZoom)
                                return;
                            !function(e) {
                                R.set(e.clientX, e.clientY)
                            }(e),
                            y = v.DOLLY;
                            break;
                        case o.ROTATE:
                            if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                if (!1 === p.enablePan)
                                    return;
                                X(e),
                                y = v.PAN
                            } else {
                                if (!1 === p.enableRotate)
                                    return;
                                V(e),
                                y = v.ROTATE
                            }
                            break;
                        case o.PAN:
                            if (e.ctrlKey || e.metaKey || e.shiftKey) {
                                if (!1 === p.enableRotate)
                                    return;
                                V(e),
                                y = v.ROTATE
                            } else {
                                if (!1 === p.enablePan)
                                    return;
                                X(e),
                                y = v.PAN
                            }
                            break;
                        default:
                            y = v.NONE
                        }
                        y !== v.NONE && (p.domElement.ownerDocument.addEventListener("pointermove", te),
                        p.domElement.ownerDocument.addEventListener("pointerup", ne),
                        p.dispatchEvent(m))
                    }(e)
                }
        }
        function te(e) {
            if (!1 !== p.enabled)
                switch (e.pointerType) {
                case "mouse":
                case "pen":
                    !function(e) {
                        if (!1 === p.enabled)
                            return;
                        switch (e.preventDefault(),
                        y) {
                        case v.ROTATE:
                            if (!1 === p.enableRotate)
                                return;
                            !function(e) {
                                T.set(e.clientX, e.clientY),
                                L.subVectors(T, S).multiplyScalar(p.rotateSpeed);
                                var t = p.domElement;
                                I(2 * Math.PI * L.x / t.clientHeight),
                                z(2 * Math.PI * L.y / t.clientHeight),
                                S.copy(T),
                                p.update()
                            }(e);
                            break;
                        case v.DOLLY:
                            if (!1 === p.enableZoom)
                                return;
                            !function(e) {
                                D.set(e.clientX, e.clientY),
                                O.subVectors(D, R),
                                O.y > 0 ? j(N()) : O.y < 0 && G(N()),
                                R.copy(D),
                                p.update()
                            }(e);
                            break;
                        case v.PAN:
                            if (!1 === p.enablePan)
                                return;
                            !function(e) {
                                P.set(e.clientX, e.clientY),
                                C.subVectors(P, A).multiplyScalar(p.panSpeed),
                                H(C.x, C.y),
                                A.copy(P),
                                p.update()
                            }(e)
                        }
                    }(e)
                }
        }
        function ne(e) {
            switch (e.pointerType) {
            case "mouse":
            case "pen":
                !function(e) {
                    if (p.domElement.ownerDocument.removeEventListener("pointermove", te),
                    p.domElement.ownerDocument.removeEventListener("pointerup", ne),
                    !1 === p.enabled)
                        return;
                    p.dispatchEvent(g),
                    y = v.NONE
                }()
            }
        }
        function re(e) {
            !1 === p.enabled || !1 === p.enableZoom || y !== v.NONE && y !== v.ROTATE || (e.preventDefault(),
            p.dispatchEvent(m),
            function(e) {
                e.deltaY < 0 ? G(N()) : e.deltaY > 0 && j(N()),
                p.update()
            }(e),
            p.dispatchEvent(g))
        }
        function ie(e) {
            !1 !== p.enabled && !1 !== p.enablePan && function(e) {
                var t = !1;
                switch (e.code) {
                case p.keys.UP:
                    H(0, p.keyPanSpeed),
                    t = !0;
                    break;
                case p.keys.BOTTOM:
                    H(0, -p.keyPanSpeed),
                    t = !0;
                    break;
                case p.keys.LEFT:
                    H(p.keyPanSpeed, 0),
                    t = !0;
                    break;
                case p.keys.RIGHT:
                    H(-p.keyPanSpeed, 0),
                    t = !0
                }
                t && (e.preventDefault(),
                p.update())
            }(e)
        }
        function oe(e) {
            if (!1 !== p.enabled) {
                switch (e.preventDefault(),
                e.touches.length) {
                case 1:
                    switch (p.touches.ONE) {
                    case a:
                        if (!1 === p.enableRotate)
                            return;
                        Y(e),
                        y = v.TOUCH_ROTATE;
                        break;
                    case s:
                        if (!1 === p.enablePan)
                            return;
                        Z(e),
                        y = v.TOUCH_PAN;
                        break;
                    default:
                        y = v.NONE
                    }
                    break;
                case 2:
                    switch (p.touches.TWO) {
                    case c:
                        if (!1 === p.enableZoom && !1 === p.enablePan)
                            return;
                        !function(e) {
                            p.enableZoom && $(e),
                            p.enablePan && Z(e)
                        }(e),
                        y = v.TOUCH_DOLLY_PAN;
                        break;
                    case l:
                        if (!1 === p.enableZoom && !1 === p.enableRotate)
                            return;
                        !function(e) {
                            p.enableZoom && $(e),
                            p.enableRotate && Y(e)
                        }(e),
                        y = v.TOUCH_DOLLY_ROTATE;
                        break;
                    default:
                        y = v.NONE
                    }
                    break;
                default:
                    y = v.NONE
                }
                y !== v.NONE && p.dispatchEvent(m)
            }
        }
        function ae(e) {
            if (!1 !== p.enabled)
                switch (e.preventDefault(),
                y) {
                case v.TOUCH_ROTATE:
                    if (!1 === p.enableRotate)
                        return;
                    J(e),
                    p.update();
                    break;
                case v.TOUCH_PAN:
                    if (!1 === p.enablePan)
                        return;
                    Q(e),
                    p.update();
                    break;
                case v.TOUCH_DOLLY_PAN:
                    if (!1 === p.enableZoom && !1 === p.enablePan)
                        return;
                    !function(e) {
                        p.enableZoom && K(e),
                        p.enablePan && Q(e)
                    }(e),
                    p.update();
                    break;
                case v.TOUCH_DOLLY_ROTATE:
                    if (!1 === p.enableZoom && !1 === p.enableRotate)
                        return;
                    !function(e) {
                        p.enableZoom && K(e),
                        p.enableRotate && J(e)
                    }(e),
                    p.update();
                    break;
                default:
                    y = v.NONE
                }
        }
        function se(e) {
            !1 !== p.enabled && (p.dispatchEvent(g),
            y = v.NONE)
        }
        function ce(e) {
            !1 !== p.enabled && e.preventDefault()
        }
        p.domElement.addEventListener("contextmenu", ce),
        p.domElement.addEventListener("pointerdown", ee),
        p.domElement.addEventListener("wheel", re),
        p.domElement.addEventListener("touchstart", oe),
        p.domElement.addEventListener("touchend", se),
        p.domElement.addEventListener("touchmove", ae),
        this.update()
    };
    vl.prototype = Object.create(D.prototype),
    vl.prototype.constructor = vl;
    var yl = function(e, t) {
        vl.call(this, e, t),
        this.screenSpacePanning = !1,
        this.mouseButtons.LEFT = o.PAN,
        this.mouseButtons.RIGHT = o.ROTATE,
        this.touches.ONE = s,
        this.touches.TWO = l
    };
    (yl.prototype = Object.create(D.prototype)).constructor = yl;
    var bl = function(e, t) {
        void 0 === t && (console.warn('THREE.FlyControls: The second parameter "domElement" is now mandatory.'),
        t = document),
        this.object = e,
        this.domElement = t,
        t && this.domElement.setAttribute("tabindex", -1),
        this.movementSpeed = 1,
        this.rollSpeed = .005,
        this.dragToLook = !1,
        this.autoForward = !1;
        var n, r, i = this, o = {
            type: "change"
        }, a = 1e-6;
        function s(e, t) {
            return function() {
                t.apply(e, arguments)
            }
        }
        function c(e) {
            e.preventDefault()
        }
        this.tmpQuaternion = new W,
        this.mouseStatus = 0,
        this.moveState = {
            up: 0,
            down: 0,
            left: 0,
            right: 0,
            forward: 0,
            back: 0,
            pitchUp: 0,
            pitchDown: 0,
            yawLeft: 0,
            yawRight: 0,
            rollLeft: 0,
            rollRight: 0
        },
        this.moveVector = new q(0,0,0),
        this.rotationVector = new q(0,0,0),
        this.keydown = function(e) {
            if (!e.altKey) {
                switch (e.code) {
                case "ShiftLeft":
                case "ShiftRight":
                    this.movementSpeedMultiplier = .1;
                    break;
                case "KeyW":
                    this.moveState.forward = 1;
                    break;
                case "KeyS":
                    this.moveState.back = 1;
                    break;
                case "KeyA":
                    this.moveState.left = 1;
                    break;
                case "KeyD":
                    this.moveState.right = 1;
                    break;
                case "KeyR":
                    this.moveState.up = 1;
                    break;
                case "KeyF":
                    this.moveState.down = 1;
                    break;
                case "ArrowUp":
                    this.moveState.pitchUp = 1;
                    break;
                case "ArrowDown":
                    this.moveState.pitchDown = 1;
                    break;
                case "ArrowLeft":
                    this.moveState.yawLeft = 1;
                    break;
                case "ArrowRight":
                    this.moveState.yawRight = 1;
                    break;
                case "KeyQ":
                    this.moveState.rollLeft = 1;
                    break;
                case "KeyE":
                    this.moveState.rollRight = 1
                }
                this.updateMovementVector(),
                this.updateRotationVector()
            }
        }
        ,
        this.keyup = function(e) {
            switch (e.code) {
            case "ShiftLeft":
            case "ShiftRight":
                this.movementSpeedMultiplier = 1;
                break;
            case "KeyW":
                this.moveState.forward = 0;
                break;
            case "KeyS":
                this.moveState.back = 0;
                break;
            case "KeyA":
                this.moveState.left = 0;
                break;
            case "KeyD":
                this.moveState.right = 0;
                break;
            case "KeyR":
                this.moveState.up = 0;
                break;
            case "KeyF":
                this.moveState.down = 0;
                break;
            case "ArrowUp":
                this.moveState.pitchUp = 0;
                break;
            case "ArrowDown":
                this.moveState.pitchDown = 0;
                break;
            case "ArrowLeft":
                this.moveState.yawLeft = 0;
                break;
            case "ArrowRight":
                this.moveState.yawRight = 0;
                break;
            case "KeyQ":
                this.moveState.rollLeft = 0;
                break;
            case "KeyE":
                this.moveState.rollRight = 0
            }
            this.updateMovementVector(),
            this.updateRotationVector()
        }
        ,
        this.mousedown = function(e) {
            if (this.domElement !== document && this.domElement.focus(),
            e.preventDefault(),
            this.dragToLook)
                this.mouseStatus++;
            else {
                switch (e.button) {
                case 0:
                    this.moveState.forward = 1;
                    break;
                case 2:
                    this.moveState.back = 1
                }
                this.updateMovementVector()
            }
        }
        ,
        this.mousemove = function(e) {
            if (!this.dragToLook || this.mouseStatus > 0) {
                var t = this.getContainerDimensions()
                  , n = t.size[0] / 2
                  , r = t.size[1] / 2;
                this.moveState.yawLeft = -(e.pageX - t.offset[0] - n) / n,
                this.moveState.pitchDown = (e.pageY - t.offset[1] - r) / r,
                this.updateRotationVector()
            }
        }
        ,
        this.mouseup = function(e) {
            if (e.preventDefault(),
            this.dragToLook)
                this.mouseStatus--,
                this.moveState.yawLeft = this.moveState.pitchDown = 0;
            else {
                switch (e.button) {
                case 0:
                    this.moveState.forward = 0;
                    break;
                case 2:
                    this.moveState.back = 0
                }
                this.updateMovementVector()
            }
            this.updateRotationVector()
        }
        ,
        this.update = (n = new W,
        r = new q,
        function(e) {
            var t = e * i.movementSpeed
              , s = e * i.rollSpeed;
            i.object.translateX(i.moveVector.x * t),
            i.object.translateY(i.moveVector.y * t),
            i.object.translateZ(i.moveVector.z * t),
            i.tmpQuaternion.set(i.rotationVector.x * s, i.rotationVector.y * s, i.rotationVector.z * s, 1).normalize(),
            i.object.quaternion.multiply(i.tmpQuaternion),
            (r.distanceToSquared(i.object.position) > a || 8 * (1 - n.dot(i.object.quaternion)) > a) && (i.dispatchEvent(o),
            n.copy(i.object.quaternion),
            r.copy(i.object.position))
        }
        ),
        this.updateMovementVector = function() {
            var e = this.moveState.forward || this.autoForward && !this.moveState.back ? 1 : 0;
            this.moveVector.x = -this.moveState.left + this.moveState.right,
            this.moveVector.y = -this.moveState.down + this.moveState.up,
            this.moveVector.z = -e + this.moveState.back
        }
        ,
        this.updateRotationVector = function() {
            this.rotationVector.x = -this.moveState.pitchDown + this.moveState.pitchUp,
            this.rotationVector.y = -this.moveState.yawRight + this.moveState.yawLeft,
            this.rotationVector.z = -this.moveState.rollRight + this.moveState.rollLeft
        }
        ,
        this.getContainerDimensions = function() {
            return this.domElement != document ? {
                size: [this.domElement.offsetWidth, this.domElement.offsetHeight],
                offset: [this.domElement.offsetLeft, this.domElement.offsetTop]
            } : {
                size: [window.innerWidth, window.innerHeight],
                offset: [0, 0]
            }
        }
        ,
        this.dispose = function() {
            this.domElement.removeEventListener("contextmenu", c),
            this.domElement.removeEventListener("mousedown", u),
            this.domElement.removeEventListener("mousemove", l),
            this.domElement.removeEventListener("mouseup", h),
            window.removeEventListener("keydown", d),
            window.removeEventListener("keyup", p)
        }
        ;
        var l = s(this, this.mousemove)
          , u = s(this, this.mousedown)
          , h = s(this, this.mouseup)
          , d = s(this, this.keydown)
          , p = s(this, this.keyup);
        this.domElement.addEventListener("contextmenu", c),
        this.domElement.addEventListener("mousemove", l),
        this.domElement.addEventListener("mousedown", u),
        this.domElement.addEventListener("mouseup", h),
        window.addEventListener("keydown", d),
        window.addEventListener("keyup", p),
        this.updateMovementVector(),
        this.updateRotationVector()
    };
    bl.prototype = Object.create(D.prototype),
    bl.prototype.constructor = bl;
    var xl = {
        uniforms: {
            tDiffuse: {
                value: null
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: ["varying vec2 vUv;", "void main() {", "\tvUv = uv;", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
        fragmentShader: ["uniform float opacity;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "\tvec4 texel = texture2D( tDiffuse, vUv );", "\tgl_FragColor = opacity * texel;", "}"].join("\n")
    };
    function _l() {
        this.enabled = !0,
        this.needsSwap = !0,
        this.clear = !1,
        this.renderToScreen = !1
    }
    Object.assign(_l.prototype, {
        setSize: function() {},
        render: function() {
            console.error("THREE.Pass: .render() must be implemented in derived pass.")
        }
    }),
    _l.FullScreenQuad = function() {
        var e = new Yo(-1,1,1,-1,0,1)
          , t = new Ht;
        t.setAttribute("position", new Rt([-1, 3, 0, -1, -1, 0, 3, -1, 0],3)),
        t.setAttribute("uv", new Rt([0, 2, 0, 0, 2, 0],2));
        var n = function(e) {
            this._mesh = new an(t,e)
        };
        return Object.defineProperty(n.prototype, "material", {
            get: function() {
                return this._mesh.material
            },
            set: function(e) {
                this._mesh.material = e
            }
        }),
        Object.assign(n.prototype, {
            dispose: function() {
                this._mesh.geometry.dispose()
            },
            render: function(t) {
                t.render(this._mesh, e)
            }
        }),
        n
    }();
    var wl = function(e, t) {
        _l.call(this),
        this.textureID = void 0 !== t ? t : "tDiffuse",
        e instanceof dn ? (this.uniforms = e.uniforms,
        this.material = e) : e && (this.uniforms = hn.clone(e.uniforms),
        this.material = new dn({
            defines: Object.assign({}, e.defines),
            uniforms: this.uniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader
        })),
        this.fsQuad = new _l.FullScreenQuad(this.material)
    };
    wl.prototype = Object.assign(Object.create(_l.prototype), {
        constructor: wl,
        render: function(e, t, n) {
            this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = n.texture),
            this.fsQuad.material = this.material,
            this.renderToScreen ? (e.setRenderTarget(null),
            this.fsQuad.render(e)) : (e.setRenderTarget(t),
            this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
            this.fsQuad.render(e))
        }
    });
    var Ml = function(e, t) {
        _l.call(this),
        this.scene = e,
        this.camera = t,
        this.clear = !0,
        this.needsSwap = !1,
        this.inverse = !1
    };
    Ml.prototype = Object.assign(Object.create(_l.prototype), {
        constructor: Ml,
        render: function(e, t, n) {
            var r, i, o = e.getContext(), a = e.state;
            a.buffers.color.setMask(!1),
            a.buffers.depth.setMask(!1),
            a.buffers.color.setLocked(!0),
            a.buffers.depth.setLocked(!0),
            this.inverse ? (r = 0,
            i = 1) : (r = 1,
            i = 0),
            a.buffers.stencil.setTest(!0),
            a.buffers.stencil.setOp(o.REPLACE, o.REPLACE, o.REPLACE),
            a.buffers.stencil.setFunc(o.ALWAYS, r, 4294967295),
            a.buffers.stencil.setClear(i),
            a.buffers.stencil.setLocked(!0),
            e.setRenderTarget(n),
            this.clear && e.clear(),
            e.render(this.scene, this.camera),
            e.setRenderTarget(t),
            this.clear && e.clear(),
            e.render(this.scene, this.camera),
            a.buffers.color.setLocked(!1),
            a.buffers.depth.setLocked(!1),
            a.buffers.stencil.setLocked(!1),
            a.buffers.stencil.setFunc(o.EQUAL, 1, 4294967295),
            a.buffers.stencil.setOp(o.KEEP, o.KEEP, o.KEEP),
            a.buffers.stencil.setLocked(!0)
        }
    });
    var El = function() {
        _l.call(this),
        this.needsSwap = !1
    };
    El.prototype = Object.create(_l.prototype),
    Object.assign(El.prototype, {
        render: function(e) {
            e.state.buffers.stencil.setLocked(!1),
            e.state.buffers.stencil.setTest(!1)
        }
    });
    var Sl = function(e, t) {
        if (this.renderer = e,
        void 0 === t) {
            var n = {
                minFilter: m,
                magFilter: m,
                format: E
            }
              , r = e.getSize(new k);
            this._pixelRatio = e.getPixelRatio(),
            this._width = r.width,
            this._height = r.height,
            (t = new V(this._width * this._pixelRatio,this._height * this._pixelRatio,n)).texture.name = "EffectComposer.rt1"
        } else
            this._pixelRatio = 1,
            this._width = t.width,
            this._height = t.height;
        this.renderTarget1 = t,
        this.renderTarget2 = t.clone(),
        this.renderTarget2.texture.name = "EffectComposer.rt2",
        this.writeBuffer = this.renderTarget1,
        this.readBuffer = this.renderTarget2,
        this.renderToScreen = !0,
        this.passes = [],
        void 0 === xl && console.error("THREE.EffectComposer relies on CopyShader"),
        void 0 === wl && console.error("THREE.EffectComposer relies on ShaderPass"),
        this.copyPass = new wl(xl),
        this.clock = new na
    };
    Object.assign(Sl.prototype, {
        swapBuffers: function() {
            var e = this.readBuffer;
            this.readBuffer = this.writeBuffer,
            this.writeBuffer = e
        },
        addPass: function(e) {
            this.passes.push(e),
            e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
        },
        insertPass: function(e, t) {
            this.passes.splice(t, 0, e),
            e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
        },
        removePass: function(e) {
            const t = this.passes.indexOf(e);
            -1 !== t && this.passes.splice(t, 1)
        },
        isLastEnabledPass: function(e) {
            for (var t = e + 1; t < this.passes.length; t++)
                if (this.passes[t].enabled)
                    return !1;
            return !0
        },
        render: function(e) {
            void 0 === e && (e = this.clock.getDelta());
            var t, n, r = this.renderer.getRenderTarget(), i = !1, o = this.passes.length;
            for (n = 0; n < o; n++)
                if (!1 !== (t = this.passes[n]).enabled) {
                    if (t.renderToScreen = this.renderToScreen && this.isLastEnabledPass(n),
                    t.render(this.renderer, this.writeBuffer, this.readBuffer, e, i),
                    t.needsSwap) {
                        if (i) {
                            var a = this.renderer.getContext()
                              , s = this.renderer.state.buffers.stencil;
                            s.setFunc(a.NOTEQUAL, 1, 4294967295),
                            this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e),
                            s.setFunc(a.EQUAL, 1, 4294967295)
                        }
                        this.swapBuffers()
                    }
                    void 0 !== Ml && (t instanceof Ml ? i = !0 : t instanceof El && (i = !1))
                }
            this.renderer.setRenderTarget(r)
        },
        reset: function(e) {
            if (void 0 === e) {
                var t = this.renderer.getSize(new k);
                this._pixelRatio = this.renderer.getPixelRatio(),
                this._width = t.width,
                this._height = t.height,
                (e = this.renderTarget1.clone()).setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
            }
            this.renderTarget1.dispose(),
            this.renderTarget2.dispose(),
            this.renderTarget1 = e,
            this.renderTarget2 = e.clone(),
            this.writeBuffer = this.renderTarget1,
            this.readBuffer = this.renderTarget2
        },
        setSize: function(e, t) {
            this._width = e,
            this._height = t;
            var n = this._width * this._pixelRatio
              , r = this._height * this._pixelRatio;
            this.renderTarget1.setSize(n, r),
            this.renderTarget2.setSize(n, r);
            for (var i = 0; i < this.passes.length; i++)
                this.passes[i].setSize(n, r)
        },
        setPixelRatio: function(e) {
            this._pixelRatio = e,
            this.setSize(this._width, this._height)
        }
    });
    var Tl = function() {
        this.enabled = !0,
        this.needsSwap = !0,
        this.clear = !1,
        this.renderToScreen = !1
    };
    Object.assign(Tl.prototype, {
        setSize: function() {},
        render: function() {
            console.error("THREE.Pass: .render() must be implemented in derived pass.")
        }
    }),
    Tl.FullScreenQuad = function() {
        var e = new Yo(-1,1,1,-1,0,1)
          , t = new Ht;
        t.setAttribute("position", new Rt([-1, 3, 0, -1, -1, 0, 3, -1, 0],3)),
        t.setAttribute("uv", new Rt([0, 2, 0, 0, 2, 0],2));
        var n = function(e) {
            this._mesh = new an(t,e)
        };
        return Object.defineProperty(n.prototype, "material", {
            get: function() {
                return this._mesh.material
            },
            set: function(e) {
                this._mesh.material = e
            }
        }),
        Object.assign(n.prototype, {
            dispose: function() {
                this._mesh.geometry.dispose()
            },
            render: function(t) {
                t.render(this._mesh, e)
            }
        }),
        n
    }();
    var Ll = function(e, t, n, r, i) {
        _l.call(this),
        this.scene = e,
        this.camera = t,
        this.overrideMaterial = n,
        this.clearColor = r,
        this.clearAlpha = void 0 !== i ? i : 0,
        this.clear = !0,
        this.clearDepth = !1,
        this.needsSwap = !1,
        this._oldClearColor = new yt
    };
    function Al() {
        return (Al = Object.assign || function(e) {
            for (var t = 1; t < arguments.length; t++) {
                var n = arguments[t];
                for (var r in n)
                    Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }
        ).apply(this, arguments)
    }
    function Pl(e) {
        if (void 0 === e)
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e
    }
    function Cl(e, t) {
        return (Cl = Object.setPrototypeOf || function(e, t) {
            return e.__proto__ = t,
            e
        }
        )(e, t)
    }
    function Rl(e) {
        return (Rl = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
            return e.__proto__ || Object.getPrototypeOf(e)
        }
        )(e)
    }
    function Dl() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
            return !1;
        if (Reflect.construct.sham)
            return !1;
        if ("function" == typeof Proxy)
            return !0;
        try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}
            ))),
            !0
        } catch (e) {
            return !1
        }
    }
    function Ol(e, t, n) {
        return (Ol = Dl() ? Reflect.construct : function(e, t, n) {
            var r = [null];
            r.push.apply(r, t);
            var i = new (Function.bind.apply(e, r));
            return n && Cl(i, n.prototype),
            i
        }
        ).apply(null, arguments)
    }
    function Nl(e) {
        var t = "function" == typeof Map ? new Map : void 0;
        return (Nl = function(e) {
            if (null === e || (n = e,
            -1 === Function.toString.call(n).indexOf("[native code]")))
                return e;
            var n;
            if ("function" != typeof e)
                throw new TypeError("Super expression must either be null or a function");
            if (void 0 !== t) {
                if (t.has(e))
                    return t.get(e);
                t.set(e, r)
            }
            function r() {
                return Ol(e, arguments, Rl(this).constructor)
            }
            return r.prototype = Object.create(e.prototype, {
                constructor: {
                    value: r,
                    enumerable: !1,
                    writable: !0,
                    configurable: !0
                }
            }),
            Cl(r, e)
        }
        )(e)
    }
    Ll.prototype = Object.assign(Object.create(_l.prototype), {
        constructor: Ll,
        render: function(e, t, n) {
            var r, i, o = e.autoClear;
            e.autoClear = !1,
            void 0 !== this.overrideMaterial && (i = this.scene.overrideMaterial,
            this.scene.overrideMaterial = this.overrideMaterial),
            this.clearColor && (e.getClearColor(this._oldClearColor),
            r = e.getClearAlpha(),
            e.setClearColor(this.clearColor, this.clearAlpha)),
            this.clearDepth && e.clearDepth(),
            e.setRenderTarget(this.renderToScreen ? null : n),
            this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
            e.render(this.scene, this.camera),
            this.clearColor && e.setClearColor(this._oldClearColor, r),
            void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = i),
            e.autoClear = o
        }
    });
    var Il = {
        1: "Passed invalid arguments to hsl, please pass multiple numbers e.g. hsl(360, 0.75, 0.4) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75 }).\n\n",
        2: "Passed invalid arguments to hsla, please pass multiple numbers e.g. hsla(360, 0.75, 0.4, 0.7) or an object e.g. rgb({ hue: 255, saturation: 0.4, lightness: 0.75, alpha: 0.7 }).\n\n",
        3: "Passed an incorrect argument to a color function, please pass a string representation of a color.\n\n",
        4: "Couldn't generate valid rgb string from %s, it returned %s.\n\n",
        5: "Couldn't parse the color string. Please provide the color as a string in hex, rgb, rgba, hsl or hsla notation.\n\n",
        6: "Passed invalid arguments to rgb, please pass multiple numbers e.g. rgb(255, 205, 100) or an object e.g. rgb({ red: 255, green: 205, blue: 100 }).\n\n",
        7: "Passed invalid arguments to rgba, please pass multiple numbers e.g. rgb(255, 205, 100, 0.75) or an object e.g. rgb({ red: 255, green: 205, blue: 100, alpha: 0.75 }).\n\n",
        8: "Passed invalid argument to toColorString, please pass a RgbColor, RgbaColor, HslColor or HslaColor object.\n\n",
        9: "Please provide a number of steps to the modularScale helper.\n\n",
        10: "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
        11: 'Invalid value passed as base to modularScale, expected number or em string but got "%s"\n\n',
        12: 'Expected a string ending in "px" or a number passed as the first argument to %s(), got "%s" instead.\n\n',
        13: 'Expected a string ending in "px" or a number passed as the second argument to %s(), got "%s" instead.\n\n',
        14: 'Passed invalid pixel value ("%s") to %s(), please pass a value like "12px" or 12.\n\n',
        15: 'Passed invalid base value ("%s") to %s(), please pass a value like "12px" or 12.\n\n',
        16: "You must provide a template to this method.\n\n",
        17: "You passed an unsupported selector state to this method.\n\n",
        18: "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
        19: "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
        20: "expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
        21: "expects the objects in the first argument array to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
        22: "expects the first argument object to have the properties `prop`, `fromSize`, and `toSize`.\n\n",
        23: "fontFace expects a name of a font-family.\n\n",
        24: "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
        25: "fontFace expects localFonts to be an array.\n\n",
        26: "fontFace expects fileFormats to be an array.\n\n",
        27: "radialGradient requries at least 2 color-stops to properly render.\n\n",
        28: "Please supply a filename to retinaImage() as the first argument.\n\n",
        29: "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
        30: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
        31: "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation\n\n",
        32: "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s')\n\n",
        33: "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation\n\n",
        34: "borderRadius expects a radius value as a string or number as the second argument.\n\n",
        35: 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n',
        36: "Property must be a string value.\n\n",
        37: "Syntax Error at %s.\n\n",
        38: "Formula contains a function that needs parentheses at %s.\n\n",
        39: "Formula is missing closing parenthesis at %s.\n\n",
        40: "Formula has too many closing parentheses at %s.\n\n",
        41: "All values in a formula must have the same unit or be unitless.\n\n",
        42: "Please provide a number of steps to the modularScale helper.\n\n",
        43: "Please pass a number or one of the predefined scales to the modularScale helper as the ratio.\n\n",
        44: "Invalid value passed as base to modularScale, expected number or em/rem string but got %s.\n\n",
        45: "Passed invalid argument to hslToColorString, please pass a HslColor or HslaColor object.\n\n",
        46: "Passed invalid argument to rgbToColorString, please pass a RgbColor or RgbaColor object.\n\n",
        47: "minScreen and maxScreen must be provided as stringified numbers with the same units.\n\n",
        48: "fromSize and toSize must be provided as stringified numbers with the same units.\n\n",
        49: "Expects either an array of objects or a single object with the properties prop, fromSize, and toSize.\n\n",
        50: "Expects the objects in the first argument array to have the properties prop, fromSize, and toSize.\n\n",
        51: "Expects the first argument object to have the properties prop, fromSize, and toSize.\n\n",
        52: "fontFace expects either the path to the font file(s) or a name of a local copy.\n\n",
        53: "fontFace expects localFonts to be an array.\n\n",
        54: "fontFace expects fileFormats to be an array.\n\n",
        55: "fontFace expects a name of a font-family.\n\n",
        56: "linearGradient requries at least 2 color-stops to properly render.\n\n",
        57: "radialGradient requries at least 2 color-stops to properly render.\n\n",
        58: "Please supply a filename to retinaImage() as the first argument.\n\n",
        59: "Passed invalid argument to triangle, please pass correct pointingDirection e.g. 'right'.\n\n",
        60: "Passed an invalid value to `height` or `width`. Please provide a pixel based unit.\n\n",
        61: "Property must be a string value.\n\n",
        62: "borderRadius expects a radius value as a string or number as the second argument.\n\n",
        63: 'borderRadius expects one of "top", "bottom", "left" or "right" as the first argument.\n\n',
        64: "The animation shorthand only takes 8 arguments. See the specification for more information: http://mdn.io/animation.\n\n",
        65: "To pass multiple animations please supply them in arrays, e.g. animation(['rotate', '2s'], ['move', '1s'])\\nTo pass a single animation please supply them in simple values, e.g. animation('rotate', '2s').\n\n",
        66: "The animation shorthand arrays can only have 8 elements. See the specification for more information: http://mdn.io/animation.\n\n",
        67: "You must provide a template to this method.\n\n",
        68: "You passed an unsupported selector state to this method.\n\n",
        69: 'Expected a string ending in "px" or a number passed as the first argument to %s(), got %s instead.\n\n',
        70: 'Expected a string ending in "px" or a number passed as the second argument to %s(), got %s instead.\n\n',
        71: 'Passed invalid pixel value %s to %s(), please pass a value like "12px" or 12.\n\n',
        72: 'Passed invalid base value %s to %s(), please pass a value like "12px" or 12.\n\n',
        73: "Please provide a valid CSS variable.\n\n",
        74: "CSS variable not found and no default was provided.\n\n",
        75: "important requires a valid style object, got a %s instead.\n\n",
        76: "fromSize and toSize must be provided as stringified numbers with the same units as minScreen and maxScreen.\n\n",
        77: 'remToPx expects a value in "rem" but you provided it in "%s".\n\n',
        78: 'base must be set in "px" or "%" but you set it in "%s".\n'
    };
    function kl() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
            t[n] = arguments[n];
        var r, i = t[0], o = [];
        for (r = 1; r < t.length; r += 1)
            o.push(t[r]);
        return o.forEach((function(e) {
            i = i.replace(/%[a-z]/, e)
        }
        )),
        i
    }
    var zl = function(e) {
        var t, n;
        function r(t) {
            var n;
            if ("production" === process.env.NODE_ENV)
                n = e.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + t + " for more information.") || this;
            else {
                for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
                    i[o - 1] = arguments[o];
                n = e.call(this, kl.apply(void 0, [Il[t]].concat(i))) || this
            }
            return Pl(n)
        }
        return n = e,
        (t = r).prototype = Object.create(n.prototype),
        t.prototype.constructor = t,
        Cl(t, n),
        r
    }(Nl(Error));
    function Fl(e) {
        return Math.round(255 * e)
    }
    function Bl(e, t, n) {
        return Fl(e) + "," + Fl(t) + "," + Fl(n)
    }
    function Ul(e, t, n, r) {
        if (void 0 === r && (r = Bl),
        0 === t)
            return r(n, n, n);
        var i = (e % 360 + 360) % 360 / 60
          , o = (1 - Math.abs(2 * n - 1)) * t
          , a = o * (1 - Math.abs(i % 2 - 1))
          , s = 0
          , c = 0
          , l = 0;
        i >= 0 && i < 1 ? (s = o,
        c = a) : i >= 1 && i < 2 ? (s = a,
        c = o) : i >= 2 && i < 3 ? (c = o,
        l = a) : i >= 3 && i < 4 ? (c = a,
        l = o) : i >= 4 && i < 5 ? (s = a,
        l = o) : i >= 5 && i < 6 && (s = o,
        l = a);
        var u = n - o / 2;
        return r(s + u, c + u, l + u)
    }
    var Hl = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "639",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
    };
    var jl = /^#[a-fA-F0-9]{6}$/
      , Gl = /^#[a-fA-F0-9]{8}$/
      , Vl = /^#[a-fA-F0-9]{3}$/
      , Wl = /^#[a-fA-F0-9]{4}$/
      , ql = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i
      , Xl = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i
      , Yl = /^hsl\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i
      , Zl = /^hsla\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i;
    function $l(e) {
        if ("string" != typeof e)
            throw new zl(3);
        var t = function(e) {
            if ("string" != typeof e)
                return e;
            var t = e.toLowerCase();
            return Hl[t] ? "#" + Hl[t] : e
        }(e);
        if (t.match(jl))
            return {
                red: parseInt("" + t[1] + t[2], 16),
                green: parseInt("" + t[3] + t[4], 16),
                blue: parseInt("" + t[5] + t[6], 16)
            };
        if (t.match(Gl)) {
            var n = parseFloat((parseInt("" + t[7] + t[8], 16) / 255).toFixed(2));
            return {
                red: parseInt("" + t[1] + t[2], 16),
                green: parseInt("" + t[3] + t[4], 16),
                blue: parseInt("" + t[5] + t[6], 16),
                alpha: n
            }
        }
        if (t.match(Vl))
            return {
                red: parseInt("" + t[1] + t[1], 16),
                green: parseInt("" + t[2] + t[2], 16),
                blue: parseInt("" + t[3] + t[3], 16)
            };
        if (t.match(Wl)) {
            var r = parseFloat((parseInt("" + t[4] + t[4], 16) / 255).toFixed(2));
            return {
                red: parseInt("" + t[1] + t[1], 16),
                green: parseInt("" + t[2] + t[2], 16),
                blue: parseInt("" + t[3] + t[3], 16),
                alpha: r
            }
        }
        var i = ql.exec(t);
        if (i)
            return {
                red: parseInt("" + i[1], 10),
                green: parseInt("" + i[2], 10),
                blue: parseInt("" + i[3], 10)
            };
        var o = Xl.exec(t);
        if (o)
            return {
                red: parseInt("" + o[1], 10),
                green: parseInt("" + o[2], 10),
                blue: parseInt("" + o[3], 10),
                alpha: parseFloat("" + o[4])
            };
        var a = Yl.exec(t);
        if (a) {
            var s = "rgb(" + Ul(parseInt("" + a[1], 10), parseInt("" + a[2], 10) / 100, parseInt("" + a[3], 10) / 100) + ")"
              , c = ql.exec(s);
            if (!c)
                throw new zl(4,t,s);
            return {
                red: parseInt("" + c[1], 10),
                green: parseInt("" + c[2], 10),
                blue: parseInt("" + c[3], 10)
            }
        }
        var l = Zl.exec(t);
        if (l) {
            var u = "rgb(" + Ul(parseInt("" + l[1], 10), parseInt("" + l[2], 10) / 100, parseInt("" + l[3], 10) / 100) + ")"
              , h = ql.exec(u);
            if (!h)
                throw new zl(4,t,u);
            return {
                red: parseInt("" + h[1], 10),
                green: parseInt("" + h[2], 10),
                blue: parseInt("" + h[3], 10),
                alpha: parseFloat("" + l[4])
            }
        }
        throw new zl(5)
    }
    var Jl = function(e) {
        return 7 === e.length && e[1] === e[2] && e[3] === e[4] && e[5] === e[6] ? "#" + e[1] + e[3] + e[5] : e
    };
    function Ql(e) {
        var t = e.toString(16);
        return 1 === t.length ? "0" + t : t
    }
    function Kl(e, t, n) {
        if ("number" == typeof e && "number" == typeof t && "number" == typeof n)
            return Jl("#" + Ql(e) + Ql(t) + Ql(n));
        if ("object" == typeof e && void 0 === t && void 0 === n)
            return Jl("#" + Ql(e.red) + Ql(e.green) + Ql(e.blue));
        throw new zl(6)
    }
    function eu(e, t, n) {
        return function() {
            var r = n.concat(Array.prototype.slice.call(arguments));
            return r.length >= t ? e.apply(this, r) : eu(e, t, r)
        }
    }
    function tu(e) {
        return eu(e, e.length, [])
    }
    function nu(e, t) {
        if ("transparent" === t)
            return t;
        var n, r, i, o = $l(t), a = "number" == typeof o.alpha ? o.alpha : 1;
        return function(e, t, n, r) {
            if ("string" == typeof e && "number" == typeof t) {
                var i = $l(e);
                return "rgba(" + i.red + "," + i.green + "," + i.blue + "," + t + ")"
            }
            if ("number" == typeof e && "number" == typeof t && "number" == typeof n && "number" == typeof r)
                return r >= 1 ? Kl(e, t, n) : "rgba(" + e + "," + t + "," + n + "," + r + ")";
            if ("object" == typeof e && void 0 === t && void 0 === n && void 0 === r)
                return e.alpha >= 1 ? Kl(e.red, e.green, e.blue) : "rgba(" + e.red + "," + e.green + "," + e.blue + "," + e.alpha + ")";
            throw new zl(7)
        }(Al({}, o, {
            alpha: (n = 0,
            r = 1,
            i = (100 * a + 100 * parseFloat(e)) / 100,
            Math.max(n, Math.min(r, i)))
        }))
    }
    var ru = tu(nu)
      , iu = {
        Linear: {
            None: function(e) {
                return e
            }
        },
        Quadratic: {
            In: function(e) {
                return e * e
            },
            Out: function(e) {
                return e * (2 - e)
            },
            InOut: function(e) {
                return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
            }
        },
        Cubic: {
            In: function(e) {
                return e * e * e
            },
            Out: function(e) {
                return --e * e * e + 1
            },
            InOut: function(e) {
                return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
            }
        },
        Quartic: {
            In: function(e) {
                return e * e * e * e
            },
            Out: function(e) {
                return 1 - --e * e * e * e
            },
            InOut: function(e) {
                return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
            }
        },
        Quintic: {
            In: function(e) {
                return e * e * e * e * e
            },
            Out: function(e) {
                return --e * e * e * e * e + 1
            },
            InOut: function(e) {
                return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
            }
        },
        Sinusoidal: {
            In: function(e) {
                return 1 - Math.cos(e * Math.PI / 2)
            },
            Out: function(e) {
                return Math.sin(e * Math.PI / 2)
            },
            InOut: function(e) {
                return .5 * (1 - Math.cos(Math.PI * e))
            }
        },
        Exponential: {
            In: function(e) {
                return 0 === e ? 0 : Math.pow(1024, e - 1)
            },
            Out: function(e) {
                return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
            },
            InOut: function(e) {
                return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
            }
        },
        Circular: {
            In: function(e) {
                return 1 - Math.sqrt(1 - e * e)
            },
            Out: function(e) {
                return Math.sqrt(1 - --e * e)
            },
            InOut: function(e) {
                return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
            }
        },
        Elastic: {
            In: function(e) {
                return 0 === e ? 0 : 1 === e ? 1 : -Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI)
            },
            Out: function(e) {
                return 0 === e ? 0 : 1 === e ? 1 : Math.pow(2, -10 * e) * Math.sin(5 * (e - .1) * Math.PI) + 1
            },
            InOut: function(e) {
                return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? -.5 * Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) + 1
            }
        },
        Back: {
            In: function(e) {
                var t = 1.70158;
                return e * e * ((t + 1) * e - t)
            },
            Out: function(e) {
                var t = 1.70158;
                return --e * e * ((t + 1) * e + t) + 1
            },
            InOut: function(e) {
                var t = 2.5949095;
                return (e *= 2) < 1 ? e * e * ((t + 1) * e - t) * .5 : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
            }
        },
        Bounce: {
            In: function(e) {
                return 1 - iu.Bounce.Out(1 - e)
            },
            Out: function(e) {
                return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
            },
            InOut: function(e) {
                return e < .5 ? .5 * iu.Bounce.In(2 * e) : .5 * iu.Bounce.Out(2 * e - 1) + .5
            }
        }
    }
      , ou = "undefined" == typeof self && "undefined" != typeof process && process.hrtime ? function() {
        var e = process.hrtime();
        return 1e3 * e[0] + e[1] / 1e6
    }
    : "undefined" != typeof self && void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now.bind(self.performance) : void 0 !== Date.now ? Date.now : function() {
        return (new Date).getTime()
    }
      , au = function() {
        function e() {
            this._tweens = {},
            this._tweensAddedDuringUpdate = {}
        }
        return e.prototype.getAll = function() {
            var e = this;
            return Object.keys(this._tweens).map((function(t) {
                return e._tweens[t]
            }
            ))
        }
        ,
        e.prototype.removeAll = function() {
            this._tweens = {}
        }
        ,
        e.prototype.add = function(e) {
            this._tweens[e.getId()] = e,
            this._tweensAddedDuringUpdate[e.getId()] = e
        }
        ,
        e.prototype.remove = function(e) {
            delete this._tweens[e.getId()],
            delete this._tweensAddedDuringUpdate[e.getId()]
        }
        ,
        e.prototype.update = function(e, t) {
            void 0 === e && (e = ou()),
            void 0 === t && (t = !1);
            var n = Object.keys(this._tweens);
            if (0 === n.length)
                return !1;
            for (; n.length > 0; ) {
                this._tweensAddedDuringUpdate = {};
                for (var r = 0; r < n.length; r++) {
                    var i = this._tweens[n[r]]
                      , o = !t;
                    i && !1 === i.update(e, o) && !t && delete this._tweens[n[r]]
                }
                n = Object.keys(this._tweensAddedDuringUpdate)
            }
            return !0
        }
        ,
        e
    }()
      , su = {
        Linear: function(e, t) {
            var n = e.length - 1
              , r = n * t
              , i = Math.floor(r)
              , o = su.Utils.Linear;
            return t < 0 ? o(e[0], e[1], r) : t > 1 ? o(e[n], e[n - 1], n - r) : o(e[i], e[i + 1 > n ? n : i + 1], r - i)
        },
        Bezier: function(e, t) {
            for (var n = 0, r = e.length - 1, i = Math.pow, o = su.Utils.Bernstein, a = 0; a <= r; a++)
                n += i(1 - t, r - a) * i(t, a) * e[a] * o(r, a);
            return n
        },
        CatmullRom: function(e, t) {
            var n = e.length - 1
              , r = n * t
              , i = Math.floor(r)
              , o = su.Utils.CatmullRom;
            return e[0] === e[n] ? (t < 0 && (i = Math.floor(r = n * (1 + t))),
            o(e[(i - 1 + n) % n], e[i], e[(i + 1) % n], e[(i + 2) % n], r - i)) : t < 0 ? e[0] - (o(e[0], e[0], e[1], e[1], -r) - e[0]) : t > 1 ? e[n] - (o(e[n], e[n], e[n - 1], e[n - 1], r - n) - e[n]) : o(e[i ? i - 1 : 0], e[i], e[n < i + 1 ? n : i + 1], e[n < i + 2 ? n : i + 2], r - i)
        },
        Utils: {
            Linear: function(e, t, n) {
                return (t - e) * n + e
            },
            Bernstein: function(e, t) {
                var n = su.Utils.Factorial;
                return n(e) / n(t) / n(e - t)
            },
            Factorial: function() {
                var e = [1];
                return function(t) {
                    var n = 1;
                    if (e[t])
                        return e[t];
                    for (var r = t; r > 1; r--)
                        n *= r;
                    return e[t] = n,
                    n
                }
            }(),
            CatmullRom: function(e, t, n, r, i) {
                var o = .5 * (n - e)
                  , a = .5 * (r - t)
                  , s = i * i;
                return (2 * t - 2 * n + o + a) * (i * s) + (-3 * t + 3 * n - 2 * o - a) * s + o * i + t
            }
        }
    }
      , cu = function() {
        function e() {}
        return e.nextId = function() {
            return e._nextId++
        }
        ,
        e._nextId = 0,
        e
    }()
      , lu = new au
      , uu = function() {
        function e(e, t) {
            void 0 === t && (t = lu),
            this._object = e,
            this._group = t,
            this._isPaused = !1,
            this._pauseStart = 0,
            this._valuesStart = {},
            this._valuesEnd = {},
            this._valuesStartRepeat = {},
            this._duration = 1e3,
            this._initialRepeat = 0,
            this._repeat = 0,
            this._yoyo = !1,
            this._isPlaying = !1,
            this._reversed = !1,
            this._delayTime = 0,
            this._startTime = 0,
            this._easingFunction = iu.Linear.None,
            this._interpolationFunction = su.Linear,
            this._chainedTweens = [],
            this._onStartCallbackFired = !1,
            this._id = cu.nextId(),
            this._isChainStopped = !1,
            this._goToEnd = !1
        }
        return e.prototype.getId = function() {
            return this._id
        }
        ,
        e.prototype.isPlaying = function() {
            return this._isPlaying
        }
        ,
        e.prototype.isPaused = function() {
            return this._isPaused
        }
        ,
        e.prototype.to = function(e, t) {
            return this._valuesEnd = Object.create(e),
            void 0 !== t && (this._duration = t),
            this
        }
        ,
        e.prototype.duration = function(e) {
            return this._duration = e,
            this
        }
        ,
        e.prototype.start = function(e) {
            if (this._isPlaying)
                return this;
            if (this._group && this._group.add(this),
            this._repeat = this._initialRepeat,
            this._reversed)
                for (var t in this._reversed = !1,
                this._valuesStartRepeat)
                    this._swapEndStartRepeatValues(t),
                    this._valuesStart[t] = this._valuesStartRepeat[t];
            return this._isPlaying = !0,
            this._isPaused = !1,
            this._onStartCallbackFired = !1,
            this._isChainStopped = !1,
            this._startTime = void 0 !== e ? "string" == typeof e ? ou() + parseFloat(e) : e : ou(),
            this._startTime += this._delayTime,
            this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat),
            this
        }
        ,
        e.prototype._setupProperties = function(e, t, n, r) {
            for (var i in n) {
                var o = e[i]
                  , a = Array.isArray(o)
                  , s = a ? "array" : typeof o
                  , c = !a && Array.isArray(n[i]);
                if ("undefined" !== s && "function" !== s) {
                    if (c) {
                        var l = n[i];
                        if (0 === l.length)
                            continue;
                        l = l.map(this._handleRelativeValue.bind(this, o)),
                        n[i] = [o].concat(l)
                    }
                    if ("object" !== s && !a || !o || c)
                        void 0 === t[i] && (t[i] = o),
                        a || (t[i] *= 1),
                        r[i] = c ? n[i].slice().reverse() : t[i] || 0;
                    else {
                        for (var u in t[i] = a ? [] : {},
                        o)
                            t[i][u] = o[u];
                        r[i] = a ? [] : {},
                        this._setupProperties(o, t[i], n[i], r[i])
                    }
                }
            }
        }
        ,
        e.prototype.stop = function() {
            return this._isChainStopped || (this._isChainStopped = !0,
            this.stopChainedTweens()),
            this._isPlaying ? (this._group && this._group.remove(this),
            this._isPlaying = !1,
            this._isPaused = !1,
            this._onStopCallback && this._onStopCallback(this._object),
            this) : this
        }
        ,
        e.prototype.end = function() {
            return this._goToEnd = !0,
            this.update(1 / 0),
            this
        }
        ,
        e.prototype.pause = function(e) {
            return void 0 === e && (e = ou()),
            this._isPaused || !this._isPlaying || (this._isPaused = !0,
            this._pauseStart = e,
            this._group && this._group.remove(this)),
            this
        }
        ,
        e.prototype.resume = function(e) {
            return void 0 === e && (e = ou()),
            this._isPaused && this._isPlaying ? (this._isPaused = !1,
            this._startTime += e - this._pauseStart,
            this._pauseStart = 0,
            this._group && this._group.add(this),
            this) : this
        }
        ,
        e.prototype.stopChainedTweens = function() {
            for (var e = 0, t = this._chainedTweens.length; e < t; e++)
                this._chainedTweens[e].stop();
            return this
        }
        ,
        e.prototype.group = function(e) {
            return this._group = e,
            this
        }
        ,
        e.prototype.delay = function(e) {
            return this._delayTime = e,
            this
        }
        ,
        e.prototype.repeat = function(e) {
            return this._initialRepeat = e,
            this._repeat = e,
            this
        }
        ,
        e.prototype.repeatDelay = function(e) {
            return this._repeatDelayTime = e,
            this
        }
        ,
        e.prototype.yoyo = function(e) {
            return this._yoyo = e,
            this
        }
        ,
        e.prototype.easing = function(e) {
            return this._easingFunction = e,
            this
        }
        ,
        e.prototype.interpolation = function(e) {
            return this._interpolationFunction = e,
            this
        }
        ,
        e.prototype.chain = function() {
            for (var e = [], t = 0; t < arguments.length; t++)
                e[t] = arguments[t];
            return this._chainedTweens = e,
            this
        }
        ,
        e.prototype.onStart = function(e) {
            return this._onStartCallback = e,
            this
        }
        ,
        e.prototype.onUpdate = function(e) {
            return this._onUpdateCallback = e,
            this
        }
        ,
        e.prototype.onRepeat = function(e) {
            return this._onRepeatCallback = e,
            this
        }
        ,
        e.prototype.onComplete = function(e) {
            return this._onCompleteCallback = e,
            this
        }
        ,
        e.prototype.onStop = function(e) {
            return this._onStopCallback = e,
            this
        }
        ,
        e.prototype.update = function(e, t) {
            if (void 0 === e && (e = ou()),
            void 0 === t && (t = !0),
            this._isPaused)
                return !0;
            var n, r, i = this._startTime + this._duration;
            if (!this._goToEnd && !this._isPlaying) {
                if (e > i)
                    return !1;
                t && this.start(e)
            }
            if (this._goToEnd = !1,
            e < this._startTime)
                return !0;
            !1 === this._onStartCallbackFired && (this._onStartCallback && this._onStartCallback(this._object),
            this._onStartCallbackFired = !0),
            r = (e - this._startTime) / this._duration,
            r = 0 === this._duration || r > 1 ? 1 : r;
            var o = this._easingFunction(r);
            if (this._updateProperties(this._object, this._valuesStart, this._valuesEnd, o),
            this._onUpdateCallback && this._onUpdateCallback(this._object, r),
            1 === r) {
                if (this._repeat > 0) {
                    for (n in isFinite(this._repeat) && this._repeat--,
                    this._valuesStartRepeat)
                        this._yoyo || "string" != typeof this._valuesEnd[n] || (this._valuesStartRepeat[n] = this._valuesStartRepeat[n] + parseFloat(this._valuesEnd[n])),
                        this._yoyo && this._swapEndStartRepeatValues(n),
                        this._valuesStart[n] = this._valuesStartRepeat[n];
                    return this._yoyo && (this._reversed = !this._reversed),
                    void 0 !== this._repeatDelayTime ? this._startTime = e + this._repeatDelayTime : this._startTime = e + this._delayTime,
                    this._onRepeatCallback && this._onRepeatCallback(this._object),
                    !0
                }
                this._onCompleteCallback && this._onCompleteCallback(this._object);
                for (var a = 0, s = this._chainedTweens.length; a < s; a++)
                    this._chainedTweens[a].start(this._startTime + this._duration);
                return this._isPlaying = !1,
                !1
            }
            return !0
        }
        ,
        e.prototype._updateProperties = function(e, t, n, r) {
            for (var i in n)
                if (void 0 !== t[i]) {
                    var o = t[i] || 0
                      , a = n[i]
                      , s = Array.isArray(e[i])
                      , c = Array.isArray(a);
                    !s && c ? e[i] = this._interpolationFunction(a, r) : "object" == typeof a && a ? this._updateProperties(e[i], o, a, r) : "number" == typeof (a = this._handleRelativeValue(o, a)) && (e[i] = o + (a - o) * r)
                }
        }
        ,
        e.prototype._handleRelativeValue = function(e, t) {
            return "string" != typeof t ? t : "+" === t.charAt(0) || "-" === t.charAt(0) ? e + parseFloat(t) : parseFloat(t)
        }
        ,
        e.prototype._swapEndStartRepeatValues = function(e) {
            var t = this._valuesStartRepeat[e]
              , n = this._valuesEnd[e];
            this._valuesStartRepeat[e] = "string" == typeof n ? this._valuesStartRepeat[e] + parseFloat(n) : this._valuesEnd[e],
            this._valuesEnd[e] = t
        }
        ,
        e
    }()
      , hu = cu.nextId
      , du = lu
      , pu = du.getAll.bind(du)
      , fu = du.removeAll.bind(du)
      , mu = du.add.bind(du)
      , gu = du.remove.bind(du)
      , vu = du.update.bind(du)
      , yu = {
        Easing: iu,
        Group: au,
        Interpolation: su,
        now: ou,
        Sequence: cu,
        nextId: hu,
        Tween: uu,
        VERSION: "18.6.4",
        getAll: pu,
        removeAll: fu,
        add: mu,
        remove: gu,
        update: vu
    };
    function bu(e, t, n) {
        return t in e ? Object.defineProperty(e, t, {
            value: n,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : e[t] = n,
        e
    }
    function xu(e, t) {
        return function(e) {
            if (Array.isArray(e))
                return e
        }(e) || function(e, t) {
            if ("undefined" == typeof Symbol || !(Symbol.iterator in Object(e)))
                return;
            var n = []
              , r = !0
              , i = !1
              , o = void 0;
            try {
                for (var a, s = e[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value),
                !t || n.length !== t); r = !0)
                    ;
            } catch (e) {
                i = !0,
                o = e
            } finally {
                try {
                    r || null == s.return || s.return()
                } finally {
                    if (i)
                        throw o
                }
            }
            return n
        }(e, t) || wu(e, t) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function _u(e) {
        return function(e) {
            if (Array.isArray(e))
                return Mu(e)
        }(e) || function(e) {
            if ("undefined" != typeof Symbol && Symbol.iterator in Object(e))
                return Array.from(e)
        }(e) || wu(e) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }()
    }
    function wu(e, t) {
        if (e) {
            if ("string" == typeof e)
                return Mu(e, t);
            var n = Object.prototype.toString.call(e).slice(8, -1);
            return "Object" === n && e.constructor && (n = e.constructor.name),
            "Map" === n || "Set" === n ? Array.from(e) : "Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n) ? Mu(e, t) : void 0
        }
    }
    function Mu(e, t) {
        (null == t || t > e.length) && (t = e.length);
        for (var n = 0, r = new Array(t); n < t; n++)
            r[n] = e[n];
        return r
    }
    !function(e, t) {
        void 0 === t && (t = {});
        var n = t.insertAt;
        if (e && "undefined" != typeof document) {
            var r = document.head || document.getElementsByTagName("head")[0]
              , i = document.createElement("style");
            i.type = "text/css",
            "top" === n && r.firstChild ? r.insertBefore(i, r.firstChild) : r.appendChild(i),
            i.styleSheet ? i.styleSheet.cssText = e : i.appendChild(document.createTextNode(e))
        }
    }(".scene-nav-info {\n  bottom: 5px;\n  width: 100%;\n  text-align: center;\n  color: slategrey;\n  opacity: 0.7;\n  font-size: 10px;\n}\n\n.scene-tooltip {\n  color: lavender;\n  font-size: 15px;\n}\n\n.scene-nav-info, .scene-tooltip {\n  position: absolute;\n  font-family: sans-serif;\n  pointer-events: none;\n}\n\n.scene-container canvas:focus {\n  outline: none;\n}");
    var Eu = window.THREE ? window.THREE : {
        WebGLRenderer: ki,
        Scene: zi,
        PerspectiveCamera: fn,
        Raycaster: ya,
        TextureLoader: Fo,
        Vector2: k,
        Vector3: q,
        Box3: Z,
        Color: yt,
        Mesh: an,
        SphereGeometry: xo,
        MeshBasicMaterial: bt,
        BackSide: 1,
        EventDispatcher: D,
        MOUSE: o,
        Quaternion: W,
        Spherical: _a,
        Clock: na
    }
      , Su = bc({
        props: {
            width: {
                default: window.innerWidth,
                onChange: function(e, t, n) {
                    isNaN(e) && (t.width = n)
                }
            },
            height: {
                default: window.innerHeight,
                onChange: function(e, t, n) {
                    isNaN(e) && (t.height = n)
                }
            },
            backgroundColor: {
                default: "#000011"
            },
            backgroundImageUrl: {},
            onBackgroundImageLoaded: {},
            showNavInfo: {
                default: !0
            },
            skyRadius: {
                default: 5e4
            },
            objects: {
                default: []
            },
            enablePointerInteraction: {
                default: !0,
                onChange: function(e, t) {
                    t.hoverObj = null,
                    t.toolTipElem && (t.toolTipElem.innerHTML = "")
                },
                triggerUpdate: !1
            },
            lineHoverPrecision: {
                default: 1,
                triggerUpdate: !1
            },
            hoverOrderComparator: {
                default: function() {
                    return -1
                },
                triggerUpdate: !1
            },
            hoverFilter: {
                default: function() {
                    return !0
                },
                triggerUpdate: !1
            },
            tooltipContent: {
                triggerUpdate: !1
            },
            hoverDuringDrag: {
                default: !1,
                triggerUpdate: !1
            },
            clickAfterDrag: {
                default: !1,
                triggerUpdate: !1
            },
            onHover: {
                default: function() {},
                triggerUpdate: !1
            },
            onClick: {
                default: function() {},
                triggerUpdate: !1
            },
            onRightClick: {
                triggerUpdate: !1
            }
        },
        methods: {
            tick: function(e) {
                if (e.initialised) {
                    if (e.controls.update && e.controls.update(e.clock.getDelta()),
                    e.postProcessingComposer ? e.postProcessingComposer.render() : e.renderer.render(e.scene, e.camera),
                    e.extraRenderers.forEach((function(t) {
                        return t.render(e.scene, e.camera)
                    }
                    )),
                    e.enablePointerInteraction) {
                        var t = null;
                        if (e.hoverDuringDrag || !e.isPointerDragging) {
                            var n = this.intersectingObjects(e.pointerPos.x, e.pointerPos.y).filter((function(t) {
                                return e.hoverFilter(t.object)
                            }
                            )).sort((function(t, n) {
                                return e.hoverOrderComparator(t.object, n.object)
                            }
                            ))
                              , r = n.length ? n[0] : null;
                            t = r ? r.object : null,
                            e.intersectionPoint = r ? r.point : null
                        }
                        t !== e.hoverObj && (e.onHover(t, e.hoverObj),
                        e.toolTipElem.innerHTML = t && xc(e.tooltipContent)(t) || "",
                        e.hoverObj = t)
                    }
                    yu.update()
                }
                return this
            },
            getPointerPos: function(e) {
                var t = e.pointerPos;
                return {
                    x: t.x,
                    y: t.y
                }
            },
            cameraPosition: function(e, t, n, r) {
                var i = e.camera;
                if (t && e.initialised) {
                    var o = t
                      , a = n || {
                        x: 0,
                        y: 0,
                        z: 0
                    };
                    if (r) {
                        var s = Object.assign({}, i.position)
                          , c = h();
                        new yu.Tween(s).to(o, r).easing(yu.Easing.Quadratic.Out).onUpdate(l).start(),
                        new yu.Tween(c).to(a, r / 3).easing(yu.Easing.Quadratic.Out).onUpdate(u).start()
                    } else
                        l(o),
                        u(a);
                    return this
                }
                return Object.assign({}, i.position, {
                    lookAt: h()
                });
                function l(e) {
                    var t = e.x
                      , n = e.y
                      , r = e.z;
                    void 0 !== t && (i.position.x = t),
                    void 0 !== n && (i.position.y = n),
                    void 0 !== r && (i.position.z = r)
                }
                function u(t) {
                    e.controls.target = new Eu.Vector3(t.x,t.y,t.z)
                }
                function h() {
                    return Object.assign(new Eu.Vector3(0,0,-1e3).applyQuaternion(i.quaternion).add(i.position))
                }
            },
            zoomToFit: function(e) {
                for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, r = arguments.length, i = new Array(r > 3 ? r - 3 : 0), o = 3; o < r; o++)
                    i[o - 3] = arguments[o];
                return this.fitToBbox(this.getBbox.apply(this, i), t, n)
            },
            fitToBbox: function(e, t) {
                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0
                  , r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 10
                  , i = e.camera;
                if (t) {
                    var o = new Eu.Vector3(0,0,0)
                      , a = 2 * Math.max.apply(Math, _u(Object.entries(t).map((function(e) {
                        var t = xu(e, 2)
                          , n = t[0]
                          , r = t[1];
                        return Math.max.apply(Math, _u(r.map((function(e) {
                            return Math.abs(o[n] - e)
                        }
                        ))))
                    }
                    ))))
                      , s = (1 - 2 * r / e.height) * i.fov
                      , c = a / Math.atan(s * Math.PI / 180)
                      , l = c / i.aspect
                      , u = Math.max(c, l);
                    if (u > 0) {
                        var h = o.clone().sub(i.position).normalize().multiplyScalar(-u);
                        this.cameraPosition(h, o, n)
                    }
                }
                return this
            },
            getBbox: function(e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : function() {
                    return !0
                }
                  , n = new Eu.Box3(new Eu.Vector3(0,0,0),new Eu.Vector3(0,0,0))
                  , r = e.objects.filter(t);
                return r.length ? (r.forEach((function(e) {
                    return n.expandByObject(e)
                }
                )),
                Object.assign.apply(Object, _u(["x", "y", "z"].map((function(e) {
                    return bu({}, e, [n.min[e], n.max[e]])
                }
                ))))) : null
            },
            getScreenCoords: function(e, t, n, r) {
                var i = new Eu.Vector3(t,n,r);
                return i.project(this.camera()),
                {
                    x: (i.x + 1) * e.width / 2,
                    y: -(i.y - 1) * e.height / 2
                }
            },
            getSceneCoords: function(e, t, n) {
                var r = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0
                  , i = new Eu.Vector2(t / e.width * 2 - 1,-n / e.height * 2 + 1)
                  , o = new Eu.Raycaster;
                return o.setFromCamera(i, e.camera),
                Object.assign({}, o.ray.at(r, new Eu.Vector3))
            },
            intersectingObjects: function(e, t, n) {
                var r = new Eu.Vector2(t / e.width * 2 - 1,-n / e.height * 2 + 1)
                  , i = new Eu.Raycaster;
                return i.params.Line.threshold = e.lineHoverPrecision,
                i.setFromCamera(r, e.camera),
                i.intersectObjects(e.objects, !0)
            },
            renderer: function(e) {
                return e.renderer
            },
            scene: function(e) {
                return e.scene
            },
            camera: function(e) {
                return e.camera
            },
            postProcessingComposer: function(e) {
                return e.postProcessingComposer
            },
            controls: function(e) {
                return e.controls
            },
            tbControls: function(e) {
                return e.controls
            }
        },
        stateInit: function() {
            return {
                scene: new Eu.Scene,
                camera: new Eu.PerspectiveCamera,
                clock: new Eu.Clock
            }
        },
        init: function(e, t) {
            var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}
              , r = n.controlType
              , i = void 0 === r ? "trackball" : r
              , o = n.rendererConfig
              , a = void 0 === o ? {} : o
              , s = n.extraRenderers
              , c = void 0 === s ? [] : s
              , l = n.waitForLoadComplete
              , u = void 0 === l || l;
            e.innerHTML = "",
            e.appendChild(t.container = document.createElement("div")),
            t.container.className = "scene-container",
            t.container.style.position = "relative",
            t.container.appendChild(t.navInfo = document.createElement("div")),
            t.navInfo.className = "scene-nav-info",
            t.navInfo.textContent = {
                orbit: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
                trackball: "Left-click: rotate, Mouse-wheel/middle-click: zoom, Right-click: pan",
                fly: "WASD: move, R|F: up | down, Q|E: roll, up|down: pitch, left|right: yaw"
            }[i] || "",
            t.navInfo.style.display = t.showNavInfo ? null : "none",
            t.toolTipElem = document.createElement("div"),
            t.toolTipElem.classList.add("scene-tooltip"),
            t.container.appendChild(t.toolTipElem),
            t.pointerPos = new Eu.Vector2,
            t.pointerPos.x = -2,
            t.pointerPos.y = -2,
            ["pointermove", "pointerdown"].forEach((function(e) {
                return t.container.addEventListener(e, (function(e) {
                    if (!t.isPointerDragging && "pointermove" === e.type && e.pressure > 0 && [e.movementX, e.movementY].some((function(t) {
                        return Math.abs(t) > ("touch" === e.pointerType ? 1 : 0)
                    }
                    )) && (t.isPointerDragging = !0),
                    t.enablePointerInteraction) {
                        var n = (r = t.container,
                        i = r.getBoundingClientRect(),
                        o = window.pageXOffset || document.documentElement.scrollLeft,
                        a = window.pageYOffset || document.documentElement.scrollTop,
                        {
                            top: i.top + a,
                            left: i.left + o
                        });
                        t.pointerPos.x = e.pageX - n.left,
                        t.pointerPos.y = e.pageY - n.top,
                        t.toolTipElem.style.top = "".concat(t.pointerPos.y, "px"),
                        t.toolTipElem.style.left = "".concat(t.pointerPos.x, "px"),
                        t.toolTipElem.style.transform = "translate(-".concat(t.pointerPos.x / t.width * 100, "%, 21px)")
                    }
                    var r, i, o, a
                }
                ), {
                    passive: !0
                })
            }
            )),
            t.container.addEventListener("pointerup", (function(e) {
                t.isPointerDragging && (t.isPointerDragging = !1,
                !t.clickAfterDrag) || requestAnimationFrame((function() {
                    0 === e.button && t.onClick(t.hoverObj || null, e, t.intersectionPoint),
                    2 === e.button && t.onRightClick && t.onRightClick(t.hoverObj || null, e, t.intersectionPoint)
                }
                ))
            }
            ), {
                passive: !0,
                capture: !0
            }),
            t.container.addEventListener("contextmenu", (function(e) {
                t.onRightClick && e.preventDefault()
            }
            )),
            t.renderer = new Eu.WebGLRenderer(Object.assign({
                antialias: !0,
                alpha: !0
            }, a)),
            t.renderer.setPixelRatio(Math.min(2, window.devicePixelRatio)),
            t.container.appendChild(t.renderer.domElement),
            t.extraRenderers = c,
            t.extraRenderers.forEach((function(e) {
                e.domElement.style.position = "absolute",
                e.domElement.style.top = "0px",
                e.domElement.style.pointerEvents = "none",
                t.container.appendChild(e.domElement)
            }
            )),
            t.postProcessingComposer = new Sl(t.renderer),
            t.postProcessingComposer.addPass(new Ll(t.scene,t.camera)),
            t.controls = new {
                trackball: gl,
                orbit: vl,
                fly: bl
            }[i](t.camera,t.renderer.domElement),
            "fly" === i && (t.controls.movementSpeed = 300,
            t.controls.rollSpeed = Math.PI / 6,
            t.controls.dragToLook = !0),
            "trackball" !== i && "orbit" !== i || (t.controls.minDistance = .1,
            t.controls.maxDistance = t.skyRadius,
            t.controls.addEventListener("start", (function() {
                return t.controlsEngaged = !0
            }
            )),
            t.controls.addEventListener("change", (function() {
                t.controlsEngaged && (t.controlsDragging = !0)
            }
            )),
            t.controls.addEventListener("end", (function() {
                t.controlsEngaged = !1,
                t.controlsDragging = !1
            }
            ))),
            [t.renderer, t.postProcessingComposer].concat(_u(t.extraRenderers)).forEach((function(e) {
                return e.setSize(t.width, t.height)
            }
            )),
            t.camera.aspect = t.width / t.height,
            t.camera.updateProjectionMatrix(),
            t.camera.position.z = 1e3,
            t.scene.add(t.skysphere = new Eu.Mesh),
            t.skysphere.visible = !1,
            t.loadComplete = t.scene.visible = !u,
            window.scene = t.scene
        },
        update: function(e, t) {
            if (e.width && e.height && (t.hasOwnProperty("width") || t.hasOwnProperty("height")) && (e.container.style.width = e.width,
            e.container.style.height = e.height,
            [e.renderer, e.postProcessingComposer].concat(_u(e.extraRenderers)).forEach((function(t) {
                return t.setSize(e.width, e.height)
            }
            )),
            e.camera.aspect = e.width / e.height,
            e.camera.updateProjectionMatrix()),
            t.hasOwnProperty("skyRadius") && e.skyRadius && (e.controls.hasOwnProperty("maxDistance") && t.skyRadius && (e.controls.maxDistance = e.skyRadius),
            e.camera.far = 2.5 * e.skyRadius,
            e.camera.updateProjectionMatrix(),
            e.skysphere.geometry = new Eu.SphereGeometry(e.skyRadius)),
            t.hasOwnProperty("backgroundColor")) {
                var n = $l(e.backgroundColor).alpha;
                void 0 === n && (n = 1),
                e.renderer.setClearColor(new Eu.Color(ru(1, e.backgroundColor)), n)
            }
            function r() {
                e.loadComplete = e.scene.visible = !0
            }
            t.hasOwnProperty("backgroundImageUrl") && (e.backgroundImageUrl ? (new Eu.TextureLoader).load(e.backgroundImageUrl, (function(t) {
                e.skysphere.material = new Eu.MeshBasicMaterial({
                    map: t,
                    side: Eu.BackSide
                }),
                e.skysphere.visible = !0,
                e.onBackgroundImageLoaded && setTimeout(e.onBackgroundImageLoaded),
                !e.loadComplete && r()
            }
            )) : (e.skysphere.visible = !1,
            e.skysphere.material.map = null,
            !e.loadComplete && r())),
            t.hasOwnProperty("showNavInfo") && (e.navInfo.style.display = e.showNavInfo ? null : "none"),
            t.hasOwnProperty("objects") && ((t.objects || []).forEach((function(t) {
                return e.scene.remove(t)
            }
            )),
            e.objects.forEach((function(t) {
                return e.scene.add(t)
            }
            )))
        }
    });
    function Tu(e, t) {
        var n = new t;
        return {
            linkProp: function(t) {
                return {
                    default: n[t](),
                    onChange: function(n, r) {
                        r[e][t](n)
                    },
                    triggerUpdate: !1
                }
            },
            linkMethod: function(t) {
                return function(n) {
                    for (var r = n[e], i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), a = 1; a < i; a++)
                        o[a - 1] = arguments[a];
                    var s = r[t].apply(r, o);
                    return s === r ? this : s
                }
            }
        }
    }
    var Lu = window.THREE ? window.THREE : {
        AmbientLight: Jo,
        DirectionalLight: $o,
        Vector3: q
    }
      , Au = Tu("forceGraph", ml)
      , Pu = Object.assign.apply(Object, r(["jsonUrl", "graphData", "numDimensions", "dagMode", "dagLevelDistance", "dagNodeFilter", "onDagError", "nodeRelSize", "nodeId", "nodeVal", "nodeResolution", "nodeColor", "nodeAutoColorBy", "nodeOpacity", "nodeVisibility", "nodeThreeObject", "nodeThreeObjectExtend", "linkSource", "linkTarget", "linkVisibility", "linkColor", "linkAutoColorBy", "linkOpacity", "linkWidth", "linkResolution", "linkCurvature", "linkCurveRotation", "linkMaterial", "linkThreeObject", "linkThreeObjectExtend", "linkPositionUpdate", "linkDirectionalArrowLength", "linkDirectionalArrowColor", "linkDirectionalArrowRelPos", "linkDirectionalArrowResolution", "linkDirectionalParticles", "linkDirectionalParticleSpeed", "linkDirectionalParticleWidth", "linkDirectionalParticleColor", "linkDirectionalParticleResolution", "forceEngine", "d3AlphaDecay", "d3VelocityDecay", "d3AlphaMin", "ngraphPhysics", "warmupTicks", "cooldownTicks", "cooldownTime", "onEngineTick", "onEngineStop"].map((function(t) {
        return e({}, t, Au.linkProp(t))
    }
    ))))
      , Cu = Object.assign.apply(Object, r(["refresh", "getGraphBbox", "d3Force", "d3ReheatSimulation", "emitParticle"].map((function(t) {
        return e({}, t, Au.linkMethod(t))
    }
    ))))
      , Ru = Tu("renderObjs", Su)
      , Du = Object.assign.apply(Object, r(["width", "height", "backgroundColor", "showNavInfo", "enablePointerInteraction"].map((function(t) {
        return e({}, t, Ru.linkProp(t))
    }
    ))))
      , Ou = Object.assign.apply(Object, r(["cameraPosition", "postProcessingComposer"].map((function(t) {
        return e({}, t, Ru.linkMethod(t))
    }
    ))).concat([{
        graph2ScreenCoords: Ru.linkMethod("getScreenCoords"),
        screen2GraphCoords: Ru.linkMethod("getSceneCoords")
    }]));
    function Nu(e) {
        for (var t = e; t && !t.hasOwnProperty("__graphObjType"); )
            t = t.parent;
        return t
    }
    return bc({
        props: n(n({
            nodeLabel: {
                default: "name",
                triggerUpdate: !1
            },
            linkLabel: {
                default: "name",
                triggerUpdate: !1
            },
            linkHoverPrecision: {
                default: 1,
                onChange: function(e, t) {
                    return t.renderObjs.lineHoverPrecision(e)
                },
                triggerUpdate: !1
            },
            enableNavigationControls: {
                default: !0,
                onChange: function(e, t) {
                    var n = t.renderObjs.controls();
                    n && (n.enabled = e)
                },
                triggerUpdate: !1
            },
            enableNodeDrag: {
                default: !0,
                triggerUpdate: !1
            },
            onNodeDrag: {
                default: function() {},
                triggerUpdate: !1
            },
            onNodeDragEnd: {
                default: function() {},
                triggerUpdate: !1
            },
            onNodeClick: {
                default: function() {},
                triggerUpdate: !1
            },
            onNodeRightClick: {
                default: function() {},
                triggerUpdate: !1
            },
            onNodeHover: {
                default: function() {},
                triggerUpdate: !1
            },
            onLinkClick: {
                default: function() {},
                triggerUpdate: !1
            },
            onLinkRightClick: {
                default: function() {},
                triggerUpdate: !1
            },
            onLinkHover: {
                default: function() {},
                triggerUpdate: !1
            },
            onBackgroundClick: {
                default: function() {},
                triggerUpdate: !1
            },
            onBackgroundRightClick: {
                default: function() {},
                triggerUpdate: !1
            }
        }, Pu), Du),
        methods: n(n({
            zoomToFit: function(e, t, n) {
                for (var r, i = arguments.length, o = new Array(i > 3 ? i - 3 : 0), a = 3; a < i; a++)
                    o[a - 3] = arguments[a];
                return e.renderObjs.fitToBbox((r = e.forceGraph).getGraphBbox.apply(r, o), t, n),
                this
            },
            pauseAnimation: function(e) {
                return null !== e.animationFrameRequestId && (cancelAnimationFrame(e.animationFrameRequestId),
                e.animationFrameRequestId = null),
                this
            },
            resumeAnimation: function(e) {
                return null === e.animationFrameRequestId && this._animationCycle(),
                this
            },
            _animationCycle: function(e) {
                e.enablePointerInteraction && (this.renderer().domElement.style.cursor = null),
                e.forceGraph.tickFrame(),
                e.renderObjs.tick(),
                e.animationFrameRequestId = requestAnimationFrame(this._animationCycle)
            },
            scene: function(e) {
                return e.renderObjs.scene()
            },
            camera: function(e) {
                return e.renderObjs.camera()
            },
            renderer: function(e) {
                return e.renderObjs.renderer()
            },
            controls: function(e) {
                return e.renderObjs.controls()
            },
            tbControls: function(e) {
                return e.renderObjs.tbControls()
            },
            _destructor: function() {
                this.pauseAnimation(),
                this.graphData({
                    nodes: [],
                    links: []
                })
            }
        }, Cu), Ou),
        stateInit: function(e) {
            var t = e.controlType
              , n = e.rendererConfig
              , r = e.extraRenderers;
            return {
                forceGraph: new ml,
                renderObjs: Su({
                    controlType: t,
                    rendererConfig: n,
                    extraRenderers: r
                })
            }
        },
        init: function(e, t) {
            e.innerHTML = "",
            e.appendChild(t.container = document.createElement("div")),
            t.container.style.position = "relative";
            var n = document.createElement("div");
            t.container.appendChild(n),
            t.renderObjs(n);
            var r, i = t.renderObjs.camera(), o = t.renderObjs.renderer(), a = t.renderObjs.controls();
            a.enabled = !!t.enableNavigationControls,
            t.lastSetCameraZ = i.position.z,
            t.container.appendChild(r = document.createElement("div")),
            r.className = "graph-info-msg",
            r.textContent = "",
            t.forceGraph.onLoading((function() {
                r.textContent = "Loading..."
            }
            )).onFinishLoading((function() {
                r.textContent = ""
            }
            )).onUpdate((function() {
                t.graphData = t.forceGraph.graphData(),
                0 === i.position.x && 0 === i.position.y && i.position.z === t.lastSetCameraZ && t.graphData.nodes.length && (i.lookAt(t.forceGraph.position),
                t.lastSetCameraZ = i.position.z = 170 * Math.cbrt(t.graphData.nodes.length))
            }
            )).onFinishUpdate((function() {
                if (t._dragControls) {
                    var e = t.graphData.nodes.find((function(e) {
                        return e.__initialFixedPos && !e.__disposeControlsAfterDrag
                    }
                    ));
                    e ? e.__disposeControlsAfterDrag = !0 : t._dragControls.dispose(),
                    t._dragControls = void 0
                }
                if (t.enableNodeDrag && t.enablePointerInteraction && "d3" === t.forceEngine) {
                    var n = t._dragControls = new Ea(t.graphData.nodes.map((function(e) {
                        return e.__threeObj
                    }
                    )).filter((function(e) {
                        return e
                    }
                    )),i,o.domElement);
                    n.addEventListener("dragstart", (function(e) {
                        a.enabled = !1,
                        e.object.__initialPos = e.object.position.clone(),
                        e.object.__prevPos = e.object.position.clone();
                        var t = Nu(e.object).__data;
                        !t.__initialFixedPos && (t.__initialFixedPos = {
                            fx: t.fx,
                            fy: t.fy,
                            fz: t.fz
                        }),
                        !t.__initialPos && (t.__initialPos = {
                            x: t.x,
                            y: t.y,
                            z: t.z
                        }),
                        ["x", "y", "z"].forEach((function(e) {
                            return t["f".concat(e)] = t[e]
                        }
                        )),
                        o.domElement.classList.add("grabbable")
                    }
                    )),
                    n.addEventListener("drag", (function(e) {
                        var n = Nu(e.object);
                        if (!e.object.hasOwnProperty("__graphObjType")) {
                            var r = e.object.__initialPos
                              , i = e.object.__prevPos
                              , o = e.object.position;
                            n.position.add(o.clone().sub(i)),
                            i.copy(o),
                            o.copy(r)
                        }
                        var a = n.__data
                          , s = n.position
                          , c = {
                            x: s.x - a.x,
                            y: s.y - a.y,
                            z: s.z - a.z
                        };
                        ["x", "y", "z"].forEach((function(e) {
                            return a["f".concat(e)] = a[e] = s[e]
                        }
                        )),
                        t.forceGraph.d3AlphaTarget(.3).resetCountdown(),
                        a.__dragged = !0,
                        t.onNodeDrag(a, c)
                    }
                    )),
                    n.addEventListener("dragend", (function(e) {
                        delete e.object.__initialPos,
                        delete e.object.__prevPos;
                        var r = Nu(e.object).__data;
                        r.__disposeControlsAfterDrag && (n.dispose(),
                        delete r.__disposeControlsAfterDrag);
                        var i = r.__initialFixedPos
                          , s = r.__initialPos
                          , c = {
                            x: s.x - r.x,
                            y: s.y - r.y,
                            z: s.z - r.z
                        };
                        i && (["x", "y", "z"].forEach((function(e) {
                            var t = "f".concat(e);
                            void 0 === i[t] && delete r[t]
                        }
                        )),
                        delete r.__initialFixedPos,
                        delete r.__initialPos,
                        r.__dragged && (delete r.__dragged,
                        t.onNodeDragEnd(r, c))),
                        t.forceGraph.d3AlphaTarget(0).resetCountdown(),
                        t.enableNavigationControls && (a.enabled = !0,
                        a.domElement && a.domElement.ownerDocument && a.domElement.ownerDocument.dispatchEvent(new PointerEvent("pointerup",{
                            pointerType: "mouse"
                        }))),
                        o.domElement.classList.remove("grabbable")
                    }
                    ))
                }
            }
            )),
            t.renderObjs.objects([new Lu.AmbientLight(12303291), new Lu.DirectionalLight(16777215,.6), t.forceGraph]).hoverOrderComparator((function(e, t) {
                var n = Nu(e);
                if (!n)
                    return 1;
                var r = Nu(t);
                if (!r)
                    return -1;
                var i = function(e) {
                    return "node" === e.__graphObjType
                };
                return i(r) - i(n)
            }
            )).tooltipContent((function(e) {
                var n = Nu(e);
                return n && xc(t["".concat(n.__graphObjType, "Label")])(n.__data) || ""
            }
            )).hoverDuringDrag(!1).onHover((function(e) {
                var n = Nu(e);
                if (n !== t.hoverObj) {
                    var r = t.hoverObj ? t.hoverObj.__graphObjType : null
                      , i = t.hoverObj ? t.hoverObj.__data : null
                      , o = n ? n.__graphObjType : null
                      , a = n ? n.__data : null;
                    r && r !== o && t["on".concat("node" === r ? "Node" : "Link", "Hover")](null, i),
                    o && t["on".concat("node" === o ? "Node" : "Link", "Hover")](a, r === o ? i : null),
                    t.hoverObj = n
                }
            }
            )).clickAfterDrag(!1).onClick((function(e, n) {
                var r = Nu(e);
                r ? t["on".concat("node" === r.__graphObjType ? "Node" : "Link", "Click")](r.__data, n) : t.onBackgroundClick(n)
            }
            )).onRightClick((function(e, n) {
                var r = Nu(e);
                r ? t["on".concat("node" === r.__graphObjType ? "Node" : "Link", "RightClick")](r.__data, n) : t.onBackgroundRightClick(n)
            }
            )),
            this._animationCycle()
        }
    })
}
));
